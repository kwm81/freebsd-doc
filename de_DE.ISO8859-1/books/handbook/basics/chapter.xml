<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r42938
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="basics">
  <title>Grundlagen des UNIX Betriebssystems</title>
    <!--
    <authorgroup>
      <author><personname><firstname>Chris</firstname><surname>Shumway</surname></personname><contrib>Umgeschrieben von </contrib></author>
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Uwe</firstname><surname>Pierau</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
    -->

  <sect1 xml:id="basics-synopsis">
    <title>Übersicht</title>

   <para>Dieses Kapitel umfasst die grundlegenden Kommandos
     und Funktionsweisen des &os;-Betriebssystems.  Viel von diesem
     Material gilt auch für jedes andere &unix;-artige System.
     Neue Benutzer von &os; sollten dieses Kapitel aufmerksam
     lesen.</para>

   <para>Dieser Abschnitt behandelt die folgenden Themen:</para>

   <itemizedlist>
     <listitem>
       <para>virtuelle Konsolen,</para>
     </listitem>
     <listitem>
       <para>Zugriffsrechte unter &unix; sowie Datei-Flags unter &os;,</para>
     </listitem>
     <listitem>
       <para>Zugriffskontrolllisten für Dateisysteme,</para>
     </listitem>
     <listitem>
       <para>die Verzeichnisstruktur von &os;,</para>
     </listitem>
     <listitem>
       <para>Organisation von Dateisystemen unter &os;,</para>
     </listitem>
     <listitem>
       <para>Ein- und Abhängen von Dateisystemen,</para>
     </listitem>
     <listitem>
       <para>Prozesse, Dämonen und Signale,</para>
     </listitem>
     <listitem>
       <para>Shells und die Login-Umgebung,</para>
     </listitem>
     <listitem>
       <para>Texteditoren,</para>
     </listitem>
     <listitem>
       <para>Geräte und Gerätedateien,</para>
     </listitem>
     <listitem>
       <para>wie Sie in den Manualpages nach weiteren Informationen
	 suchen können.</para>
     </listitem>
   </itemizedlist>
  </sect1>

  <sect1 xml:id="consoles">
    <title>Virtuelle Konsolen und Terminals</title>
    <indexterm><primary>virtuelle Konsole</primary></indexterm>
    <indexterm><primary>Terminals</primary></indexterm>
    <indexterm><primary>Konsole</primary></indexterm>

      <para>Wenn das &os;-System so konfiguriert wurde, dass es ohne
	eine grafische Benutzeroberfläche startet, wird das System
	nach dem Start einen Anmeldeprompt ausgeben, wie in diesem
	Beispiel zu sehen:</para>

      <screen>FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:</screen>

      <para>Die erste Zeile enthält einige Informationen über das
	System.  <literal>amd64</literal> zeigt an, dass auf dem
	System in diesem Beispiel eine 64-Bit Version von &os;
	läuft.  Der Hostname ist
	<systemitem>pc3.example.org</systemitem> und
	<filename>ttyv0</filename> gibt an, dass dies die
	<quote>Systemkonsole</quote> ist.  Die zweite Zeile zeigt den
	Anmeldeprompt.</para>

      <para>Da &os; ein Mehrbenutzersystem ist, muss es die
	verschiedenen Benutzer voneinander unterscheiden können.  Dies
	wird dadurch erreicht, dass sich jeder Benutzer zuerst am
	System anmelden muss, um Zugriff auf die Programme zu
	bekommen.  Jeder Benutzer hat einen eindeutigen
	<quote>Benutzernamen</quote> und ein persönliches
	<quote>Kennwort</quote>.</para>

      <para>Um sich auf der Systemkonsole anzumelden, geben Sie den
	Benutzernamen ein, der während der Systeminstallation, wie in
	<link linkend="bsdinstall-addusers"/> beschrieben,
	konfiguriert wurde und drücken Sie <keycap>Enter</keycap>.
	Geben Sie dann das zum Benutzernamen zugeordnete Passwort ein
	und drücken <keycap>Enter</keycap>.  Das Passwort wird aus
	Sicherheitsgründen
	<emphasis>nicht angezeigt</emphasis>.</para>

      <para>Sobald das richtige Passwort eingegeben wird, wird die
	Nachricht des Tages (<acronym>MOTD</acronym>) gefolgt von
	einer Eingabeaufforderung ausgegeben.  In Abhängigkeit der
	verwendeten Shell des Benutzers wird der Prompt mit dem
	Zeichen <literal>#</literal>, <literal>$</literal> oder
	<literal>%</literal> dargestellt.  Der Prompt zeigt an,  dass
	der Benutzer jetzt an der &os; Systemkonsole angemeldet ist
	und nun alle verfügbaren Befehle probieren kann.</para>

    <sect2 xml:id="consoles-virtual">
      <title>Virtuelle Konsolen</title>

      <para>Obwohl die Systemkonsole dazu verwendet werden kann, um
	mit dem System zu interagieren,  wird sich ein Benutzer in der
	Regel an einer virtuellen Konsole im &os;-System anmelden.
	Das liegt daran, dass die Systemmeldungen standardmäßig auf
	der Systemkonsole angezeigt werden und somit die Meldungen des
	Befehls oder einer Datei, die der Benutzer gerade bearbeitet,
	überschrieben werden.</para>

      <para>In der Voreinstellung ist &os; so konfiguriert, dass viele
	virtuelle Konsolen zur Eingabe von Befehlen zur Verfügung
	stehen.  Jede virtuelle Konsole verfügt über einen eigenen
	Anmeldeprompt und eine Shell.  Sie können ganz einfach
	zwischen den virtuellen Konsolen umschalten.  Dies ist 
	vergleichbar mit mehreren geöffneten Fenstern in einer
	graphischen Umgebung.</para>

      <para>Die Tastenkombinationen
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>
	bis
	<keycombo><keycap>Alt</keycap><keycap>F8</keycap></keycombo>
	sind in &os; zum Umschalten zwischen virtuellen Konsolen
	reserviert.  Verwenden Sie
	<keycombo><keycap>Alt</keycap><keycap>F1</keycap></keycombo>
	um auf die Systemkonsole (<filename>ttyv0</filename>) zu
	wechseln,
	<keycombo><keycap>Alt</keycap><keycap>F2</keycap></keycombo>
	für die erste virtuelle Konsole (<filename>ttyv1</filename>,
	<keycombo><keycap>Alt</keycap><keycap>F3</keycap></keycombo>
	für die zweite virtuelle Konsole (<filename>ttyv2</filename>,
	und so weiter.</para>

      <para>Beim Wechsel von einer Konsole zur nächsten wird die
	Bildschirmausgabe von &os; verwaltet.  Dies erzeugt die
	Illusion mehrerer Bildschirme und Tastaturen, an denen
	Kommandos abgesetzt werden können.  Die Programme, die in
	einer virtuellen Konsole gestartet werden, laufen auch dann
	weiter, wenn der Benutzer auf eine andere virtuelle Konsole
	wechselt.</para>

      <para>Lesen Sie &man.syscons.4;, &man.atkbd.4;,
	&man.vidcontrol.1; und &man.kbdcontrol.1; für eine recht
	technische Beschreibung der &os;-Konsole und der
	Tastatur-Treiber.</para>

      <para>In &os; wird die Anzahl der verfügbaren virtuellen
	Konsolen in diesem Abschnitt von
	<filename>/etc/ttys</filename> konfiguriert:</para>

      <programlisting># name	getty			      type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         cons25  on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv2   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv3   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv4   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv5   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv6   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv7   "/usr/libexec/getty Pc"         cons25  on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure</programlisting>

      <para>Um eine virtuelle Konsole zu deaktivieren, setzen Sie ein
	Kommentarzeichen (<literal>#</literal> an den Anfang der Zeile
	für die entsprechende Konsole.  Um bspw. die Anzahl der
	verfügbaren virtuellen Konsolen von acht auf vier zu
	reduzieren, setzen Sie ein <literal>#</literal> an den Anfang
	der letzten vier Zeilen, den virtuellen Konsolen
	<filename>ttyv5</filename> bis <filename>ttyv8</filename>.
	Kommentieren Sie nicht die Zeile für die Systemkonsole
	<filename>ttyv0</filename> aus!  Beachten Sie, dass die
	letzte virtuelle Konsole (<filename>ttyv8</filename>) zum
	Wechsel auf die graphische Oberfläche gedacht ist, wenn
	&xorg; wie im <xref linkend="x11"/> installiert und
	konfiguriert ist.</para>

      <para>&man.ttys.5; enthält eine ausführliche
	Beschreibung der Spalten dieser Datei und der verfügbaren
	Optionen für virtuelle Konsolen.</para>
    </sect2>

    <sect2 xml:id="consoles-singleuser">
      <title>Single-User-Modus</title>

      <para>Das &os; Boot-Menü verfügt über eine Option
	<quote>Boot Single User</quote>.  Wird diese Option
	gewählt, bootet das System in einen speziellen Modus, der als
	<quote>Single-User-Modus</quote> bekannt ist.  Dieser Modus
	wird normalerweise zur Reparatur des Systems verwendet,
	bspw. wenn das System nicht mehr startet, oder das
	<systemitem class="username">root</systemitem>-Passwort
	zurückgesetzt werden muss.  Im Single-User-Modus haben Sie
	keinen Zugriff auf das Netzwerk und es stehen Ihnen keine
	weiteren virtuellen Konsolen zur Verfügung.  Allerdings
	haben Sie vollen Zugriff auf das System und in der
	Voreinstellung wird das <systemitem
	  class="username">root</systemitem>-Passwort nicht
	benötigt.  Aus diesem Grund wird ein physischer Zugriff
	auf die Tastatur benötigt, um in diesem Modus zu booten.
	Zur Absicherung eines &os;-Systems sollte ermittelt werden,
	welche Personen physischen Zugriff auf die Tastatur bekommen
	sollen.</para>

      <para>Die Einstellungen für den Single-User-Modus befinden sich
	diesem Abschnitt von <filename>/etc/ttys</filename>:</para>

      <programlisting># name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</programlisting>

      <para>In der Voreinstellung ist der Status auf
	<literal>secure</literal> eingestellt.  Das setzt voraus, dass
	der physische Zugriff auf die Tastatur entweder unwichtig ist,
	oder über eine Sicherheitsrichtlinie geregelt wird.  Wenn der
	Status auf <literal>insecure</literal> eingestellt wird, wird
	davon ausgegangen, dass die Umgebung selbst unsicher ist, da
	jeder Zugriff auf die Tastatur hat.  &os; wird dann nach dem
	<systemitem class="username">root</systemitem>-Passwort
	fragen, wenn ein Benutzer versucht in den Single-User-Modus zu
	booten.</para>

      <note>
	<para><emphasis>Setzen Sie <literal>insecure</literal> nicht
	    leichtfertig ein</emphasis>!  Wenn das
	  <systemitem class="username">root</systemitem>-Passwort
	  vergessen wird, wird es schwierig in den
	  Single-User-Modus zu gelangen, wenn man den Bootprozess von
	  &os; nicht genau versteht.</para>
      </note>
    </sect2>

    <sect2 xml:id="consoles-vidcontrol">
      <title>Den Videomodus der Konsole anpassen</title>

      <para>Der Standard-Videomodus der &os;-Konsole kann auf jeden
	Modus eingestellt werden, der von der Grafikkarte und dem
	Monitor unterstützt wird (beispielsweise 1024x768 oder
	1280x1024).  Um eine andere Einstellung zu verwenden, muss
	das <literal>VESA</literal>-Modul geladen werden:</para>

      <screen>&prompt.root; <userinput>kldload vesa</userinput></screen>

      <para>Um festzustellen, welche Video-Modi von der Hardware
	unterstützt werden, nutzen Sie &man.vidcontrol.1;.  Um eine
	Liste aller unterstützten Modi zu sehen, verwenden Sie diesen
	Befehl:</para>

      <screen>&prompt.root; <userinput>vidcontrol -i mode</userinput></screen>

      <para>Die Ausgabe dieses Befehls listet alle Videomodi, die von
	der Hardware unterstützt werden.  Um einen neuen Video-Modi zu
	wählen, wird der entsprechende Modus als
	<systemitem class="username">root</systemitem>-Benutzer an
	&man.vidcontrol.1; übergeben:</para>

      <screen>&prompt.root; <userinput>vidcontrol MODE_279</userinput></screen>

      <para>Um diese Einstellung dauerhaft zu speichern, muss
	folgende Zeile in <filename>/etc/rc.conf</filename>
	hinzugefügt werden:</para>

      <programlisting>allscreens_flags="MODE_279"</programlisting>
    </sect2>
  </sect1>

  <sect1 xml:id="permissions">
    <title>Zugriffsrechte</title>
    <indexterm><primary>UNIX</primary></indexterm>

    <para>In &os; besitzt jede Datei und jedes Verzeichnis einen Satz
      von Zugriffsrechten.  Es stehen mehrere Programme zum Anzeigen
      und Bearbeiten dieser Rechte zur Verfügung.  Ein Verständnis für
      die Funktionsweise von Zugriffsrechten ist notwendig, um
      sicherzustellen, dass Benutzer nur auf die von ihnen benötigten
      Dateien zugreifen können und nicht auf die Dateien des
      Betriebssystems oder von anderen Benutzern.</para>

    <para>In diesem Abschnitt werden die traditionellen
      Zugriffsrechte von &unix; beschrieben.  Informationen
      zu feingranularen Zugriffsrechten für Dateisysteme finden
      Sie im <xref linkend="fs-acl"/>.</para>

    <para>In &unix; werden die grundlegenden Zugriffsrechte in
      drei Typen unterteilt: Lesen, Scheiben und Ausführen.
      Diese Zugriffstypen werden verwendet, um den Dateizugriff
      für den Besitzer der Datei, die Gruppe und alle anderen zu
      bestimmen.  Die Lese-, Schreib- und Ausführungsberechtigungen
      werden mit den Buchstaben <literal>r</literal>,
      <literal>w</literal> und <literal>x</literal> dargestellt.
      Alternativ können die Berechtigungen als binäre Zahlen
      dargestellt werden, da jede Berechtigung entweder aktiviert
      oder deaktiviert (<literal>0</literal>) ist.  Wenn die
      Berechtigung als Zahl dargestellt wird, ist die Reihenfolge
      immer als <literal>rwx</literal> zu lesen, wobei
      <literal>r</literal> den Wert <literal>4</literal> hat,
      <literal>w</literal> den Wert <literal>2</literal> und
      <literal>x</literal> den Wert <literal>1</literal>.</para>

    <para>In Tabelle 4.1 sind die einzelnen nummerischen und
      alphabetischen Möglichkeiten zusammengefasst.  Das Zeichen
      <literal>-</literal> in der Spalte
      <quote>Auflistung im Verzeichnis</quote> besagt, dass eine
      eine Berechtigung deaktiviert ist.</para>

    <indexterm><primary>Zugriffsrechte</primary></indexterm>
    <indexterm>
      <primary>Dateizugriffsrechte</primary>
    </indexterm>
    <table frame="none" pgwide="1">
      <title>&unix; Zugriffsrechte</title>

      <tgroup cols="3">
	<thead>
	  <row>
	    <entry>Wert</entry>
	    <entry>Zugriffsrechte</entry>
	    <entry>Auflistung im Verzeichnis</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry>0</entry>
	    <entry>Kein Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>---</literal></entry>
	  </row>

	  <row>
	    <entry>1</entry>
	    <entry>Kein Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>--x</literal></entry>
	  </row>

	  <row>
	    <entry>2</entry>
	    <entry>Kein Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>-w-</literal></entry>
	  </row>

	  <row>
	    <entry>3</entry>
	    <entry>Kein Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>-wx</literal></entry>
	  </row>

	  <row>
	    <entry>4</entry>
	    <entry>Lesen, Kein Schreiben, Kein Ausführen</entry>
	    <entry><literal>r--</literal></entry>
	  </row>

	  <row>
	    <entry>5</entry>
	    <entry>Lesen, Kein Schreiben, Ausführen</entry>
	    <entry><literal>r-x</literal></entry>
	  </row>

	  <row>
	    <entry>6</entry>
	    <entry>Lesen, Schreiben, Kein Ausführen</entry>
	    <entry><literal>rw-</literal></entry>
	  </row>

	  <row>
	    <entry>7</entry>
	    <entry>Lesen, Schreiben, Ausführen</entry>
	    <entry><literal>rwx</literal></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <indexterm>
      <primary>&man.ls.1;</primary>
    </indexterm>
    <indexterm><primary>Verzeichnisse</primary></indexterm>

    <para>Benutzen Sie das Argument <option>-l</option> mit
      &man.ls.1;, um eine ausführliche Verzeichnisauflistung
      zu sehen, die in einer Spalte die Zugriffsrechte für den
      Besitzer, die Gruppe und alle anderen enthält.
      Die Ausgabe von <command>ls -l</command> könnte
      wie folgt aussehen:</para>

    <screen>&prompt.user; <userinput>ls -l</userinput>
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt</screen>

    <para>Das erste Zeichen (ganz links) der ersten Spalte zeigt an,
      ob es sich um eine normale Datei, ein Verzeichnis, ein
      zeichenorientiertes Gerät, ein Socket oder irgendeine andere
      Pseudo-Datei handelt.  In diesem Beispiel zeigt <literal>-</literal> eine
      normale Datei an.  Die nächsten drei Zeichen,
      dargestellt als <literal>rw-</literal>, ergeben die Rechte
      für den Datei-Besitzer.  Die drei Zeichen danach
      <literal>r--</literal> die Rechte der Gruppe, zu der die Datei
      gehört.  Die letzten drei Zeichen, <literal>r--</literal>,
      geben die Rechte für den Rest der Welt an.  Ein Minus
      bedeutet, dass das Recht nicht gegeben ist.  In diesem Beispiel
      sind die Zugriffsrechte also: der Eigentümer kann die Datei
      lesen und schreiben, die Gruppe kann lesen und alle anderen
      können auch nur lesen.  Entsprechend obiger Tabelle
      wären die Zugriffsrechte für diese Datei
      <literal>644</literal>, worin jede Ziffer die drei Teile der
      Zugriffsrechte dieser Datei verkörpert.</para>

    <para>Wie kontrolliert das System die Rechte von Hardware-Geräten?
      &os; behandelt die meisten Hardware-Geräte als Dateien, welche
      Programme öffnen, lesen und mit Daten beschreiben können.  Diese
      speziellen Gerätedateien sind in <filename>/dev</filename>
      gespeichert.</para>

    <para>Verzeichnisse werden ebenfalls wie Dateien behandelt.  Sie
      haben Lese-, Schreib- und Ausführ-Rechte.  Das
      Ausführungs-Bit hat eine etwas andere Bedeutung für
      ein Verzeichnis als für eine Datei.  Die Ausführbarkeit
      eines Verzeichnisses bedeutet, dass in das Verzeichnis,
      zum Beispiel mit &man.cd.1;, gewechselt werden kann.
      Das bedeutet auch, dass in dem Verzeichnis auf Dateien, deren
      Namen bekannt sind, zugegriffen werden kann, vorausgesetzt die
      Zugriffsrechte der Dateien lassen dies zu.</para>

    <para>Das Leserecht auf einem Verzeichnis erlaubt es, sich den Inhalt
      des Verzeichnisses anzeigen zu lassen.  Um eine Datei mit bekanntem
      Namen in einem Verzeichnis zu löschen, müssen auf dem
      Verzeichnis Schreib- <emphasis>und</emphasis> Ausführ-Rechte
      gesetzt sein.</para>

    <para>Es gibt noch mehr Rechte, aber die werden vor allem in
      speziellen Umständen benutzt, wie zum Beispiel bei
      SetUID-Binaries und Verzeichnissen mit gesetztem Sticky-Bit.
      Mehr über Zugriffsrechte von Dateien und wie sie gesetzt werden,
      finden Sie in &man.chmod.1;.</para>

    <sect2>
      <info><title>Symbolische Zugriffsrechte</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigesteuert von </contrib></author>
	</authorgroup>
      </info>

      
      <indexterm>
	<primary>Zugriffsrechte</primary>
	<secondary>symbolische</secondary>
      </indexterm>

      <para>Symbolische Zugriffsrechte verwenden Zeichen anstelle von
	oktalen Werten, um die Berechtigungen für Dateien oder
	Verzeichnisse festzulegen.  Zugriffsrechte verwenden die
	Syntax <replaceable>Wer</replaceable>,
	<replaceable>Aktion</replaceable> und
	<replaceable>Berechtigung</replaceable>. Die folgenden
	Werte stehen zur Auswahl:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Option</entry>
	      <entry>Symbol</entry>
	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	<tbody>
	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>u</entry>
	    <entry>Benutzer (<foreignphrase>user</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>g</entry>
	    <entry>Gruppe (<foreignphrase>group</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>o</entry>
	    <entry>Andere (<foreignphrase>other</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Wer</replaceable></entry>
	    <entry>a</entry>
	    <entry>Alle</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>+</entry>
	    <entry>Berechtigungen hinzufügen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>-</entry>
	    <entry>Berechtigungen entziehen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Aktion</replaceable></entry>
	    <entry>=</entry>
	    <entry>Berechtigungen explizit setzen</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>r</entry>
	    <entry>lesen (<foreignphrase>read</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>w</entry>
	    <entry>schreiben (<foreignphrase>write</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>x</entry>
	    <entry>ausführen
	      (<foreignphrase>execute</foreignphrase>)</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>t</entry>
	    <entry>Sticky-Bit</entry>
	  </row>

	  <row>
	    <entry><replaceable>Berechtigung</replaceable></entry>
	    <entry>s</entry>
	    <entry>Set-UID oder Set-GID</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <para>Diese symbolischen Werte werden zusammen mit &man.chmod.1;
      verwendet.  Beispielsweise würde der folgende Befehl den Zugriff
      auf <replaceable>FILE</replaceable> für alle anderen Benutzer
      verbieten:</para>

    <screen>&prompt.user; <userinput>chmod go= FILE</userinput></screen>

    <para>Wenn Sie mehr als eine Änderung der Rechte einer
      Datei vornehmen wollen, können Sie eine durch Kommata
      getrennte Liste der Rechte angeben.  Das folgende Beispiel
      entzieht der Gruppe und der Welt die Schreibberechtigung auf
      <replaceable>FILE</replaceable> und fügt für jeden
      Ausführungsrechte hinzu:</para>

    <screen>&prompt.user; <userinput>chmod go-w,a+x FILE</userinput></screen>

<!--
    <para>Mit symbolischen Zugriffsrechten können Sie Rechte
      hinzufügen oder Rechte wegnehmen.  Numerische Zugriffsrechte
      erlauben nur das explizite Setzen der Zugriffsrechte.</para>
-->
    </sect2>

    <sect2>
      <info><title>&os; Datei-Flags</title>
	<authorgroup>
	  <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      <para>Zusätzlich zu den Zugriffsrechten unterstützt &os; auch
	die Nutzung von <quote>Datei-Flags</quote>.  Diese erhöhen die
	Sicherheit des Systems, indem sie eine verbesserte Kontrolle
	von Dateien erlauben.  Verzeichnisse werden allerdings nicht
	unterstützt.  Mit dem Einsatz von Datei-Flags kann sogar
	<systemitem class="username">root</systemitem> daran gehindert
	werden, Dateien zu löschen oder zu verändern.</para>

      <para>Datei-Flags werden mit &man.chflags.1; verändert.  Um
	beispielsweise auf der Datei <filename>file1</filename> das
	<quote>unlöschbar</quote>-Flag zu aktivieren, geben Sie
	folgenden Befehl ein:</para>

      <screen>&prompt.root; <userinput>chflags sunlink file1</userinput></screen>

      <para>Um dieses Flag zu deaktivieren, setzen Sie ein
	<quote>no</quote> vor <option>sunlink</option>:</para>

      <screen>&prompt.root; <userinput>chflags nosunlink file1</userinput></screen>

      <para>Um die Flags einer Datei anzuzeigen, verwenden Sie
	&man.ls.1; zusammen mit <option>-lo</option>:</para>

      <screen>&prompt.root; <userinput>ls -lo file1</userinput></screen>

      <programlisting>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</programlisting>

      <para>Einige Datei-Flags können nur vom
	<systemitem class="username">root</systemitem>-Benutzer
	gesetzt oder gelöscht werden.  Andere wiederum können
	auch vom Eigentümer der Datei gesetzt werden.  Weitere
	Informationen hierzu finden sich in &man.chflags.1; und
	&man.chflags.2;.</para>
    </sect2>

    <sect2>
      <info><title>Die Berechtigungen <literal>setuid</literal>,
          <literal>setgid</literal>, und
          <literal>sticky</literal></title>
        <authorgroup>
          <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
        </authorgroup>
      </info>

      

      <para>Anders als die Berechtigungen, die bereits angesprochen wurden,
        existieren drei weitere Einstellungen, über die alle
        Administratoren Bescheid wissen sollten.  Dies sind die Berechtigungen
        <literal>setuid</literal>, <literal>setgid</literal> und
        <literal>sticky</literal>.</para>

      <para>Diese Einstellungen sind wichtig für manche &unix;-Operationen,
        da sie Funktionalitäten zur Verfügung stellen, die
        normalerweise nicht an gewöhnliche Anwender vergeben wird.
        Um diese zu verstehen, muss der Unterschied zwischen der realen
        und der effektiven Benutzer-ID erwähnt werden.</para>

      <para>Die reale Benutzer-ID ist die <acronym>UID</acronym>, welche den
        Prozess besitzt oder gestartet hat.  Die effektive
        <acronym>UID</acronym> ist diejenige, als die der Prozess läuft.
        Beispielsweise wird &man.passwd.1; mit der realen ID des Benutzers
        ausgeführt, der sein Passwort ändert. Um jedoch die
        Passwortdatenbank zu bearbeiten, wird es effektiv als
        <systemitem class="username">root</systemitem>-Benutzer ausgeführt.  Das
        ermöglicht es normalen Benutzern, ihr Passwort zu ändern, ohne
        einen <errorname>Permission Denied</errorname>-Fehler angezeigt zu
        bekommen.</para>

      <para>Die setuid-Berechtigung kann durch das Voranstellen bei einer
        Berechtigungsgruppe mit der Nummer Vier (4) gesetzt werden, wie im
        folgenden Beispiel gezeigt wird:</para>

      <screen>&prompt.root; <userinput>chmod 4755 suidexample.sh</userinput></screen>

      <para>Die Berechtigungen auf <filename>suidexample.sh</filename>
        sehen jetzt wie folgt aus:</para>

      <programlisting>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</programlisting>

      <para>Beachten Sie, dass ein <literal>s</literal> jetzt Teil der
	Berechtigungen des Dateibesitzers geworden ist, welches
        das Ausführen-Bit ersetzt.  Dies ermöglicht es Werkzeugen
        mit erhöhten Berechtigungen zu laufen, wie z.B.
        <command>passwd</command>.</para>

      <note>
	<para>Die <literal>nosuid</literal> &man.mount.8;-Option
	  bewirkt, dass solche Anwendungen stillschweigend scheitern,
	  ohne den Anwender darüber zu informieren.  Diese Option ist
	  nicht völlig zuverlässig, da ein
	  <literal>nosuid</literal>-Wrapper in der Lage wäre, dies zu
          umgehen.</para>
      </note>

      <para>Um dies in Echtzeit zu beobachten, öffnen Sie zwei
	Terminals.  Starten Sie auf einem <command>passwd</command>
	als normaler Benutzer.  Während es auf die Passworteingabe
	wartet, überprüfen Sie die Prozesstabelle und sehen Sie sich
	die Informationen für &man.passwd.1; an:</para>

      <para>Im Terminal A:</para>

      <screen>Changing local password for trhodes
Old Password:</screen>

      <para>Im Terminal B:</para>

      <screen>&prompt.root; <userinput>ps aux | grep passwd</userinput></screen>

      <screen>trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</screen>

      <para>Obwohl &man.passwd.1; als normaler Benutzer ausgeführt
	wird, benutzt es die effektive <acronym>UID</acronym> von
	<systemitem class="username">root</systemitem>.</para>

      <para>Die <literal>setgid</literal>-Berechtigung führt die gleiche
        Aktion wie die <literal>setuid</literal>-Berechtigung durch, allerdings
        verändert sie die Gruppenberechtigungen.  Wenn eine Anwendung
        oder ein Werkzeug mit dieser Berechtigung ausgeführt wird,
        erhält es die Berechtigungen basierend auf der Gruppe, welche die
        Datei besitzt und nicht die des Benutzers, der den Prozess gestartet
        hat.</para>

      <para>Um die <literal>setgid</literal>-Berechtigung auf einer
	Datei zu setzen, geben Sie &man.chmod.1; eine führende
	Zwei (2) mit:</para>

      <screen>&prompt.root; <userinput>chmod 2755 sgidexample.sh</userinput></screen>

      <para>Beachten Sie in der folgenden Auflistung,
        dass das <literal>s</literal> sich jetzt in dem Feld befindet, das
        für die Berechtigungen der Gruppe bestimmt ist:</para>

      <screen>-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</screen>

      <note>
        <para>Obwohl es sich bei dem in diesen Beispielen gezeigten Shellskript
          um eine ausführbare Datei handelt, wird es nicht mit einer
          anderen <acronym>EUID</acronym> oder effektiven Benutzer-ID
          ausgeführt.  Das ist so, weil Shellskripte keinen Zugriff auf
          &man.setuid.2;-Systemaufrufe erhalten.</para>
      </note>

      <para>Die <literal>setuid</literal> und
	<literal>setgid</literal> Berechtigungs-Bits können die
	Systemsicherheit verringern, da sie erhöhte Rechte
	ermöglichen.  Das dritte Berechtigungs-Bit, das
	<literal>sticky bit</literal> kann die Sicherheit eines
	Systems erhöhen.</para>

      <para>Wenn das <literal>sticky bit</literal> auf einem
	Verzeichnis angewendet wird, erlaubt es das Löschen von
	Dateien nur durch den Besitzer der Datei.  Dies ist nützlich,
	um die Löschung von Dateien in öffentlichen Verzeichnissen wie
	<filename>/tmp</filename>, durch Benutzer denen diese Dateien
	nicht gehören, zu verhindern.  Um diese Berechtigung
	anzuwenden, stellen Sie der Berechtigung eine Eins (1)
	voran:</para>

      <screen>&prompt.root; <userinput>chmod 1777 /tmp</userinput></screen>

      <para>Das <literal>sticky bit</literal> kann anhand des
	<literal>t</literal> ganz am Ende der Berechtigungen abgelesen
	werden.</para>

      <screen>&prompt.root; <userinput>ls -al / | grep tmp</userinput></screen>

      <screen>drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</screen>

    </sect2>
  </sect1>

  <sect1 xml:id="dirstructure">
    <title>Verzeichnis-Strukturen</title>
    <indexterm><primary>Verzeichnis Hierarchien</primary></indexterm>

    <para>Die &os;-Verzeichnishierarchie ist die Grundlage, um
      ein umfassendes Verständnis des Systems zu erlangen.
      Das wichtigste Verzeichnis ist das Root-Verzeichnis
      <quote>/</quote>.  Dieses Verzeichnis ist das
      erste, das während des Bootens eingehangen wird.  Es
      enthält das notwendige Basissystem, um das Betriebssystem in den
      Mehrbenutzerbetrieb zu bringen.  Das Root-Verzeichnis enthält
      auch die Mountpunkte für Dateisysteme, die beim Wechsel in
      den Multiuser-Modus eingehängt werden.</para>

    <para>Ein Mountpunkt ist ein Verzeichnis, in das zusätzliche
      Dateisysteme (in der Regel unterhalb des Wurzelverzeichnisses)
      eingehängt werden können.  Dieser Vorgang wird in
      <xref linkend="disk-organization"/> ausführlich beschrieben.
      Standard-Mountpunkte sind <filename>/usr</filename>,
      <filename>/var</filename>, <filename>/tmp</filename>,
      <filename>/mnt</filename> sowie <filename>/cdrom</filename>.
      Auf diese Verzeichnisse verweisen üblicherweise Einträge
      in <filename>/etc/fstab</filename>.  Diese Datei ist
      eine Tabelle mit verschiedenen Dateisystemen und Mountpunkten,
      vom System gelesen werden.  Die meisten der Dateisysteme in
      <filename>/etc/fstab</filename> werden beim Booten automatisch
      durch das Skript &man.rc.8; gemountet, wenn die zugehörigen
      Einträge nicht mit <option>noauto</option>
      versehen sind.  Weitere Informationen zu diesem Thema finden Sie
      im <xref linkend="disks-fstab"/>.</para>

    <para>Eine vollständige Beschreibung der Dateisystem-Hierarchie
      finden Sie in &man.hier.7;.  Die folgende Aufstellung gibt einen
      kurzen Überblick über die am häufigsten verwendeten
      Verzeichnisse:</para>

    <para>
      <informaltable frame="none" pgwide="1">
        <tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Verzeichnis</entry>
	      <entry>Beschreibung</entry>
	    </row>
	  </thead>
	  <tbody valign="top">
            <row>
	      <entry><filename>/</filename></entry>
	      <entry>Wurzelverzeichnis des Dateisystems.</entry>
            </row>

	    <row>
	      <entry><filename>/bin/</filename></entry>
	      <entry>Grundlegende Werkzeuge für den Single-User-Modus
		sowie den Mehrbenutzerbetrieb.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/</filename></entry>
	      <entry>Programme und Konfigurationsdateien, die während
		des Bootens benutzt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/boot/defaults/</filename></entry>
	      <entry>Vorgaben für die Boot-Konfiguration.  Weitere
		Details finden Sie in &man.loader.conf.5;.</entry>
	    </row>

	    <row>
	      <entry><filename>/dev/</filename></entry>
	      <entry>Gerätedateien.  Weitere Details finden Sie in
		&man.intro.4;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/</filename></entry>
	      <entry>Konfigurationsdateien und Skripten des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/defaults/</filename></entry>
	      <entry>Vorgaben für die System Konfigurationsdateien.
		Weitere Details finden Sie in &man.rc.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/mail/</filename></entry>
	      <entry>Konfigurationsdateien von MTAs wie
		&man.sendmail.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/namedb/</filename></entry>
	      <entry>Konfigurationsdateien von
		&man.named.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/periodic/</filename></entry>
	      <entry>Täglich, wöchentlich oder monatlich laufende
		Skripte, die von &man.cron.8; gestartet werden.
		Weitere Details finden Sie in
		&man.periodic.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/etc/ppp/</filename></entry>
	      <entry>Konfigurationsdateien von &man.ppp.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/mnt/</filename></entry>
	      <entry>Ein leeres Verzeichnis, das von Systemadministratoren
		häufig als temporärer Mountpunkt genutzt wird.</entry>
	    </row>

	    <row>
	      <entry><filename>/proc/</filename></entry>
	      <entry>Prozess Dateisystem.  Weitere Details finden Sie
		in &man.procfs.5; und &man.mount.procfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/rescue/</filename></entry>
	      <entry>Statisch gelinkte Programme zur Wiederherstellung
		des Systems, wie in &man.rescue.8;
		beschrieben.</entry>
	    </row>

	    <row>
	      <entry><filename>/root/</filename></entry>
	      <entry>Home Verzeichnis von <systemitem class="username">root</systemitem>.</entry>
	    </row>

	    <row>
	      <entry><filename>/sbin/</filename></entry>
	      <entry>Systemprogramme und administrative Werkzeuge, die
		grundlegend für den Single-User-Modus und den
		Mehrbenutzerbetrieb sind.</entry>
	    </row>

	    <row>
	      <entry><filename>/tmp/</filename></entry>
	      <entry>Temporäre Dateien, die für gewöhnlich
		bei einem Neustart des Systems verloren gehen.
		Häufig wird ein speicherbasiertes Dateisystem unter
		<filename>/tmp</filename>
		eingehängt.  Dieser Vorgang kann automatisiert werden,
		wenn tmpmfs-bezogene Variablen von &man.rc.conf.5;
		verwendet werden, oder ein entsprechender
		Eintrag in <filename>/etc/fstab</filename> existiert.
		Weitere Informationen finden Sie in
		&man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/</filename></entry>
	      <entry>Der Großteil der Benutzerprogramme und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/bin/</filename></entry>
	      <entry>Gebräuchliche Werkzeuge, Programmierhilfen und
		Anwendungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/include/</filename></entry>
	      <entry>Standard C include-Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/lib/</filename></entry>
	      <entry>Bibliotheken.</entry>
	    </row>


	    <row>
	      <entry><filename>/usr/libdata/</filename></entry>
	      <entry>Daten verschiedener Werkzeuge.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/libexec/</filename></entry>
	      <entry>System-Dämonen und System-Werkzeuge, die von
		anderen Programmen ausgeführt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/local/</filename></entry>

	      <entry>Lokale Programme und Bibliotheken.  Die
		Ports-Sammlung von &os; benutzt dieses Verzeichnis
		als Zielverzeichnis für Anwendungen.  Innerhalb von
		<filename>/usr/local</filename> sollte das von
		&man.hier.7; beschriebene Layout für
		<filename>/usr</filename> benutzt werden.  Das
		<filename>man</filename> Verzeichnis wird direkt unter
		<filename>/usr/local</filename> anstelle unter
		<filename>/usr/local/share</filename> angelegt.  Die
		Dokumentation der Ports findet sich in
		<filename>share/doc/<replaceable>port</replaceable></filename>.
	      </entry>
	    </row>

	    <row>
	      <entry><filename>/usr/obj/</filename></entry>
	      <entry>Von der Architektur abhängiger Verzeichnisbaum,
		der durch das Bauen von <filename>/usr/src</filename>
		entsteht.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/ports/</filename></entry>
	      <entry>Die &os;-Ports-Sammlung (optional).</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/sbin/</filename></entry>
	      <entry>System-Dämonen und System-Werkzeuge, die von
		Benutzern ausgeführt werden.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/share/</filename></entry>
	      <entry>Von der Architektur unabhängige Dateien.</entry>
	    </row>

	    <row>
	      <entry><filename>/usr/src/</filename></entry>
	      <entry>Quelldateien von BSD und/oder lokalen
		Ergänzungen.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/</filename></entry>
	      <entry>Wird für mehrere Zwecke genutzt und enthält
		Logdateien, temporäre Daten und Spooldateien.
		Manchmal wird ein speicherbasiertes Dateisystem unter
		<filename>/var</filename>
		eingehängt.  Dieser Vorgang kann automatisiert werden,
		wenn die varmfs-bezogenen Variablen von
		&man.rc.conf.5; verwendet werden, oder ein
		entsprechender Eintrag in
		<filename>/etc/fstab</filename> existiert.  Weitere
		Informationen finden Sie in &man.mdmfs.8;.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/log/</filename></entry>
	      <entry>Verschiedene Logdateien des Systems.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/mail/</filename></entry>
	      <entry>Postfächer der Benutzer.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/spool/</filename></entry>
	      <entry>Verschiedene Spool-Verzeichnisse der Drucker- und
		Mailsysteme.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/tmp/</filename></entry>
	      <entry>Temporäre Dateien, die in der Regel auch bei
		einem Neustart des Systems erhalten bleiben, es sei
		denn, bei
	        <filename>/var</filename> handelt es
	        sich um ein speicherbasiertes Dateisystem.</entry>
	    </row>

	    <row>
	      <entry><filename>/var/yp/</filename></entry>
	      <entry>NIS maps.</entry>
	    </row>

	  </tbody>
	</tgroup>
      </informaltable>
    </para>
  </sect1>

  <sect1 xml:id="disk-organization">
      <title>Festplatten, Slices und Partitionen</title>

      <para>&os; identifiziert Dateien anhand eines Dateinamens.
	In Dateinamen wird zwischen Groß- und Kleinschreibung
	unterschieden:  <filename>readme.txt</filename> und
	<filename>README.TXT</filename> bezeichnen daher zwei
	verschiedene Dateien.  &os; benutzt keine Dateiendungen,
	um den Typ der Datei zu bestimmen, egal ob es sich um ein
	Programm, ein Dokument oder um andere Daten handelt.</para>

      <para>Dateien werden in Verzeichnissen gespeichert.  In einem
	Verzeichnis können sich keine oder hunderte Dateien
	befinden.  Ein Verzeichnis kann auch andere Verzeichnisse
	enthalten und so eine Hierarchie von Verzeichnissen aufbauen,
	die die Ablage von Daten erleichtert.</para>

      <para>In Dateinamen werden Verzeichnisse durch einen
	Schrägstrich (<literal>/</literal>,
	<foreignphrase>Slash</foreignphrase>) getrennt.  Wenn z.B.
	das Verzeichnis <filename>foo</filename>
	ein Verzeichnis <filename>bar</filename>
	enthält, in dem sich die Datei <filename>readme.txt</filename>
	befindet, lautet der vollständige Name der Datei (oder der
	<firstterm>Pfad</firstterm> zur Datei)
	<filename>foo/bar/readme.txt</filename>.  Beachten Sie, dass
	sich dies von &windows; unterscheidet, wo der
	<literal>\</literal> (<foreignphrase>Backslash</foreignphrase>
	für die Trennung von Datei- und Verzeichnisnamen
	verwendet wird.  &os; benutzt keine Laufwerkbuchstaben oder
	Laufwerknamen im Pfad.  Beispielsweise würde man unter
	&os; nicht <filename>c:/foo/bar/readme.txt</filename>
	eingeben.</para>

      <para>Verzeichnisse und Dateien werden in einem Dateisystem
	gespeichert.  Jedes Dateisystem besitzt genau ein
	<firstterm>Wurzelverzeichnis</firstterm>, das so genannte
	<foreignphrase>Root-Directory</foreignphrase>.  Dieses
	Wurzelverzeichnis kann weitere Verzeichnisse enthalten.
	Ein Dateisystem wird als Wurzeldateisystem festgelegt, und
	jedes weitere Dateisystem wird unter dem Wurzeldateisystem
	<firstterm>eingehangen</firstterm>.  Daher scheint jedes
	Verzeichnis, unabhängig von der Anzahl der Platten, auf der
	selben Platte zu liegen.</para>

      <para>Betrachten wir die drei Dateisysteme <literal>A</literal>,
	<literal>B</literal> und <literal>C</literal>.  Jedes
	Dateisystem besitzt ein eigenes Wurzelverzeichnis, das
	zwei andere Verzeichnisse enthält:
	<filename>A1</filename>, <filename>A2</filename>,
	<filename>B1</filename>, <filename>B2</filename>,
	<filename>C1</filename> und <filename>C2</filename>.</para>

      <para>Das Wurzeldateisystem soll <literal>A</literal> sein.
	&man.ls.1; zeigt darin die beiden Verzeichnisse
	<filename>A1</filename> und <filename>A2</filename> an.
	Der Verzeichnisbaum sieht wie folgt aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir1"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Ein Dateisystem wird in einem Verzeichnis eines anderen
	Dateisystems eingehangen.  Wir hängen nun das Dateisystem
	<literal>B</literal> in das Verzeichnis
	<filename>A1</filename> ein.  Das Wurzelverzeichnis von
	<literal>B</literal> ersetzt nun das Verzeichnis
	<filename>A1</filename> und die Verzeichnisse des Dateisystems
	<literal>B</literal> werden sichtbar:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir2"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- B1
 |     |
 |     `--- B2
 |
 `--- A2</literallayout>
	</textobject>
      </mediaobject>

      <para>Jede Datei in den Verzeichnissen
	<filename>B1</filename> oder <filename>B2</filename> kann
	über den Pfad <filename>/A1/B1</filename> oder
	<filename>/A1/B2</filename> erreicht werden.  Dateien aus dem
	Verzeichnis <filename>/A1</filename> sind jetzt verborgen.
	Wenn das Dateisystem <literal>B</literal> wieder
	<firstterm>abgehangen</firstterm> wird
	(<foreignphrase>umount</foreignphrase>), erscheinen die
	verborgenen Dateien wieder.</para>

      <para>Wenn das Dateisystem <literal>B</literal> unter dem
	Verzeichnis <filename>A2</filename>
	eingehangen würde, sähe der Verzeichnisbaum
	so aus:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir3"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Die Dateien des Dateisystems <literal>B</literal> wären
	unter den Pfaden <filename>/A2/B1</filename> und
	<filename>/A2/B2</filename> erreichbar.</para>

      <para>Dateisysteme können übereinander eingehangen
	werden.  Der folgende Baum entsteht, wenn im letzten
	Beispiel das Dateisystem <literal>C</literal> in das Verzeichnis
	<filename>B1</filename> des Dateisystems
	<literal>B</literal> eingehangen wird:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir4"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |
 `--- A2
       |
       +--- B1
       |     |
       |     +--- C1
       |     |
       |     `--- C2
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para><literal>C</literal> könnte auch im Verzeichnis
	<filename>A1</filename> eingehangen
	werden:</para>

      <mediaobject>
	<imageobject>
	  <imagedata fileref="install/example-dir5"/>
	</imageobject>

	<textobject>
	  <literallayout class="monospaced"> /
 |
 +--- A1
 |     |
 |     +--- C1
 |     |
 |     `--- C2
 |
 `--- A2
       |
       +--- B1
       |
       `--- B2</literallayout>
	</textobject>
      </mediaobject>

      <para>Sie können sogar mit nur einem großen
	Dateisystem auskommen.  Dies hat mehrere Nachteile
	und einen Vorteil.</para>

      <itemizedlist>
	<title>Vorteile mehrerer Dateisysteme</title>

	<listitem>
	  <para>Die Dateisysteme können mit unterschiedlichen
	    Optionen (<foreignphrase>mount options</foreignphrase>)
	    eingehangen werden.  Beispielsweise kann das
	    Wurzeldateisystem schreibgeschützt eingehangen werden,
	    sodass es für Benutzer nicht möglich ist, versehentlich
	    kritische Dateien zu editieren oder zu löschen.
	    Von Benutzern beschreibbare Dateisysteme
	    wie <filename>/home</filename>
	    können mit der Option <firstterm>nosuid</firstterm>
	    eingehangen werden, wenn sie von anderen Dateisystemen
	    getrennt sind.  Die <firstterm>SUID</firstterm>- und
	    <firstterm>GUID</firstterm>-Bits verlieren auf solchen
	    Dateisystemen ihre Wirkung und die Sicherheit des
	    Systems kann dadurch erhöht werden.</para>
	</listitem>

	<listitem>
	  <para>Die Lage von Dateien im Dateisystem wird, abhängig
	    vom Gebrauch des Dateisystems, automatisch von &os;
	    optimiert.  Ein Dateisystem mit vielen kleinen Dateien,
	    die häufig geschrieben werden, wird anders behandelt
	    als ein Dateisystem mit wenigen großen Dateien.
	    Mit nur einem Dateisystem ist diese Optimierung
	    unmöglich.</para>
	</listitem>

	<listitem>
	  <para>In der Regel übersteht ein &os;-Dateisystem auch
	    einen Stromausfall.  Allerdings kann ein Stromausfall zu
	    einem kritischen Zeitpunkt das Dateisystem beschädigen.
	    Wenn die Daten über mehrere Dateisysteme verteilt
	    sind, lässt sich das System mit hoher
	    Wahrscheinlichkeit noch starten.  Dies erleichtert
	    das Zurückspielen von Datensicherungen.</para>
	</listitem>
      </itemizedlist>

      <itemizedlist>
	<title>Vorteil eines einzelnen Dateisystems</title>

	<listitem>
	  <para>Dateisysteme haben eine festgelegte Größe.
	    Es kann passieren, dass Sie eine Partition
	    vergrößern müssen.  Dies ist nicht leicht:
	    Sie müssen die Daten sichern, das Dateisystem
	    vergrößert anlegen und die gesicherten
	    Daten zurückspielen.</para>

	  <important>
	    <para>&os; kennt den Befehl &man.growfs.8;, mit dem man
	      Dateisysteme im laufenden Betrieb
	      vergrößern kann.</para>
	  </important>
	</listitem>
      </itemizedlist>

      <para>Dateisysteme befinden sich in Partitionen (damit sind
	nicht die normalen &ms-dos;-Partitionen gemeint).  Jede Partition
	wird mit einem Buchstaben von <literal>a</literal> bis
	<literal>h</literal> bezeichnet und kann nur ein Dateisystem
	enthalten.  Dateisysteme können daher über ihren
	Mount-Point, den Punkt an dem sie eingehangen sind, oder
	den Buchstaben der Partition, in der sie liegen, identifiziert
	werden.</para>

      <para>&os; benutzt einen Teil der Platte für den
	<firstterm>Swap-Bereich</firstterm>, um
	<firstterm>virtuellen Speicher</firstterm> zur Verfügung zu
	stellen.  Dadurch kann der Rechner Anwendungen mehr Speicher
	zur Verfügung stellen als tatsächlich eingebaut
	ist.  Wenn der Speicher knapp wird, kann &os; nicht benutzte
	Daten in den Swap-Bereich auslagern.  Die ausgelagerten
	Daten können später wieder in den Speicher
	geholt werden (dafür werden dann andere Daten
	ausgelagert).</para>

      <para>Für einige Partitionen gelten besondere
        Konventionen:</para>

      <informaltable frame="none" pgwide="1">
	<tgroup cols="2">
	  <colspec colwidth="1*"/>
	  <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Partition</entry>

	      <entry>Konvention</entry>
	    </row>
	  </thead>

	  <tbody valign="top">
	    <row>
	      <entry><literal>a</literal></entry>

	      <entry>Enthält normalerweise
		das Wurzeldateisystem.</entry>
	    </row>

	    <row>
	      <entry><literal>b</literal></entry>

	      <entry>Enthält normalerweise
		den Swap-Bereich.</entry>
	    </row>

	    <row>
	      <entry><literal>c</literal></entry>

	      <entry>Ist normalerweise genauso groß wie
		die Slice in der die Partition liegt.  Werkzeuge,
		die auf der kompletten Slice arbeiten, wie ein
		Bad-Block-Scanner, können so die
		<literal>c</literal>-Partition benutzen.
		Für gewöhnlich wird in dieser Partition kein
		Dateisystem angelegt.</entry>
	    </row>

	    <row>
	      <entry><literal>d</literal></entry>

	      <entry>Früher hatte die <literal>d</literal>-Partition
		eine besondere Bedeutung.  Heute ist dies nicht mehr der
		Fall und die Partition <literal>d</literal> kann wie
		jede andere Partition auch verwendet werden.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </informaltable>

      <para>In &os; werden Festplatten in Slices, welche in &windows;
	als Partitionen bekannt sind, aufgeteilt und von
	1 bis 4 durchnummeriert.  Diese werden dann in Partitionen
	unterteilt, welche wiederum Dateisysteme enthalten und mit
	Buchstaben benannt werden.</para>

      <indexterm><primary>Slices</primary></indexterm>
      <indexterm><primary>Partitionen</primary></indexterm>
      <indexterm><primary>dangerously dedicated</primary></indexterm>

      <para>Die Slice-Nummern werden mit vorgestelltem
	<literal>s</literal> hinter den Gerätenamen gestellt:
	<quote>da0<emphasis>s1</emphasis></quote>
	ist die erste Slice auf dem ersten SCSI-Laufwerk.  Auf einer
	Festplatte gibt es höchstens vier Slices.  In einer
	Slice des passenden Typs kann es weitere logische Slices
	geben.  Diese erweiterten Slices werden ab fünf durchnummeriert:
	<quote>ad0<emphasis>s5</emphasis></quote> ist
	die erste erweiterte Slice auf einer IDE-Platte.  Diese
	Geräte werden von Dateisystemen benutzt, die sich in
	einer kompletten Slice befinden müssen.</para>

      <para>Slices, <quote>dangerously dedicated</quote>-Festplatten
	und andere Platten enthalten Partitionen, die mit Buchstaben
	von <literal>a</literal> bis <literal>h</literal> bezeichnet
	werden.  Der Buchstabe wird an den Gerätenamen
	gehangen: <quote>da0<emphasis>a</emphasis></quote>
	ist die <literal>a</literal>-Partition des ersten
	<literal>da</literal>-Laufwerks.  Dieses Laufwerk ist
	<quote>dangerously dedicated</quote>.
	<quote>ad1s3<emphasis>e</emphasis></quote> ist
	die fünfte Partition in der dritten Slice der zweiten
	IDE-Platte.</para>

      <para>Schließlich wird noch jede Festplatte des Systems
	eindeutig bezeichnet.  Der Name einer Festplatte beginnt mit
	einem Code, der den Typ der Platte bezeichnet.  Es folgt eine
	Nummer, die angibt, um welche Festplatte es sich handelt.
	Anders als bei Slices werden Festplatten von Null beginnend
	durchnummeriert.  Gängige Festplatten-Namen sind in
	<xref linkend="basics-dev-codes"/> aufgeführt.</para>

      <para>Wenn Sie eine Partition angeben, beinhaltet das den
	Plattennamen, <literal>s</literal>, die Slice-Nummer und den
	Buchstaben der Partition.
	Einige Beispiele finden Sie in
	<xref linkend="basics-disk-slice-part"/>.</para>

      <para>Der Aufbau einer Festplatte wird in
	<xref linkend="basics-concept-disk-model"/> dargestellt.</para>

      <para>Bei der Installation von &os; legen Sie Slices auf der
	Festplatte an, erstellen Partitionen für &os; innerhalb der
	Slice, erstellen ein Dateisystem oder Auslagerungsbereiche und
	entscheiden, welche Dateisysteme wo eingehangen werden.</para>

      <table frame="none" pgwide="1" xml:id="basics-dev-codes">
	<title>Laufwerk-Codes</title>

	<tgroup cols="2">
          <colspec colwidth="1*"/>
          <colspec colwidth="5*"/>

	  <thead>
	    <row>
	      <entry>Code</entry>

	      <entry>Bedeutung</entry>
	    </row>
	  </thead>

	  <tbody>
	    <row>
	      <entry><filename>ad</filename></entry>

	      <entry>ATAPI (IDE) Festplatte</entry>
	    </row>

	    <row>
	      <entry><filename>da</filename></entry>

	      <entry>SCSI-Festplatte</entry>
	    </row>

	    <row>
	      <entry><filename>acd</filename></entry>

	      <entry>ATAPI (IDE) CD-ROM</entry>
	    </row>

	    <row>
	      <entry><filename>cd</filename></entry>

	      <entry>SCSI-CD-ROM</entry>
	    </row>

	    <row>
	      <entry><filename>fd</filename></entry>

	      <entry>Disketten-Laufwerk</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>

      <example xml:id="basics-disk-slice-part">
	<title>Namen von Platten, Slices und Partitionen</title>

	<informaltable frame="none" pgwide="1">
	  <tgroup cols="2">
            <colspec colwidth="1*"/>
            <colspec colwidth="5*"/>

	    <thead>
	      <row>
		<entry>Name</entry>

		<entry>Bedeutung</entry>
	      </row>
	    </thead>

	    <tbody>
	      <row>
		<entry><filename>ad0s1a</filename></entry>

		<entry>Die erste Partition (<literal>a</literal>)
		  in der ersten Slice (<literal>s1</literal>) der
		  ersten IDE-Festplatte (<literal>ad0</literal>).</entry>
	      </row>

	      <row>
		<entry><filename>da1s2e</filename></entry>

		<entry>Die fünfte Partition (<literal>e</literal>)
		  der zweiten Slice (<literal>s2</literal>) auf
		  der zweiten SCSI-Festplatte
		  (<literal>da1</literal>).</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</informaltable>
      </example>

      <example xml:id="basics-concept-disk-model">
	<title>Aufteilung einer Festplatte</title>

	<para>Das folgende Diagramm zeigt die Sicht von &os; auf die
	  erste IDE-Festplatte des Systems.  Die Platte soll
	  4&nbsp;GB groß sein und zwei Slices (&ms-dos;-Partitionen)
	  mit je 2&nbsp;GB besitzen.  Die erste Slice enthält
	  ein &ms-dos;-Laufwerk (<filename>C:</filename>), die zweite
	  Slice wird von &os; benutzt.  Die &os;-Installation in
	  diesem Beispiel verwendet drei Datenpartitionen und einen
	  Auslagerungsbereich.</para>

	<para>Jede der drei Partitionen enthält ein Dateisystem.
	  Das Wurzeldateisystem ist die <literal>a</literal>-Partition.
	  In der <literal>e</literal>-Partition befindet sich
	  der <filename>/var</filename>-Verzeichnisbaum
	  und in der <literal>f</literal>-Partition befindet sich
	  der Verzeichnisbaum unterhalb von
	  <filename>/usr</filename>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="install/disk-layout"/>
          </imageobject>

          <textobject>
	    <literallayout class="monospaced">.-----------------.  --.
|                 |    |
|  DOS / Windows  |    |
:                 :     &gt;  First slice, ad0s1
:                 :    |
|                 |    |
:=================:  ==:                               --.
|                 |    |  Partition a, mounted as /      |
|                 |     &gt; referred to as ad0s2a          |
|                 |    |                                 |
:-----------------:  ==:                                 |
|                 |    |  Partition b, used as swap      |
|                 |     &gt; referred to as ad0s2b          |
|                 |    |                                 |
:-----------------:  ==:                                 |  Partition c, no
|                 |    |  Partition e, used as /var       &gt; file system, all
|                 |     &gt; referred to as ad0s2e          |  of FreeBSD slice,
|                 |    |                                 |  ad0s2c
:-----------------:  ==:                                 |
|                 |    |                                 |
:                 :    |  Partition f, used as /usr      |
:                 :     &gt; referred to as ad0s2f          |
:                 :    |                                 |
|                 |    |                                 |
|                 |  --'                                 |
`-----------------'                                    --'</literallayout>
          </textobject>
        </mediaobject>
      </example>
  </sect1>

  <sect1 xml:id="mount-unmount">
    <title>Anhängen und Abhängen von Dateisystemen</title>

    <para>Ein Dateisystem wird am besten als ein Baum mit der
      Wurzel <filename>/</filename> veranschaulicht.
      <filename>/dev</filename>, <filename>/usr</filename>, und
      die anderen Verzeichnisse im Rootverzeichnis sind Zweige,
      die wiederum eigene Zweige wie <filename>/usr/local</filename>
      haben können.</para>

    <indexterm><primary>Root-Dateisystem</primary></indexterm>
    <para>Es gibt verschiedene Gründe, bestimmte dieser Verzeichnisse
      auf eigenen Dateisystemen anzulegen.  <filename>/var</filename>
      enthält <filename>log/</filename>, <filename>spool/</filename>
      sowie verschiedene andere temporäre
      Dateien und kann sich daher schnell füllen.  Es empfiehlt sich,
      <filename>/var</filename> von <filename>/</filename> zu trennen,
      da es schlecht ist, wenn das Root-Dateisystem voll
      läuft.</para>

    <para>Ein weiterer Grund bestimmte Verzeichnisbäume auf
      andere Dateisysteme zu legen, ist gegeben, wenn sich die
      Verzeichnisbäume auf gesonderten physikalischen oder
      virtuellen Platten, wie
      <link linkend="network-nfs">Network File System</link>
      oder CD-ROM-Laufwerken, befinden.</para>

    <sect2 xml:id="disks-fstab">
      <title>Die <filename>fstab</filename> Datei</title>

      <indexterm>
	 <primary>Dateisysteme</primary>
	 <secondary>fstab</secondary>
      </indexterm>
      <para>Während des Boot-Prozesses (<xref linkend="boot"/>)
	werden in <filename>/etc/fstab</filename> aufgeführte
	Verzeichnisse, sofern sie nicht mit der Option
	<option>noauto</option> versehen sind, automatisch angehangen.
	Diese Datei enthält Einträge in folgendem Format:</para>

      <programlisting><replaceable>device</replaceable>	<replaceable>/mount-point</replaceable>	<replaceable>fstype</replaceable>	<replaceable>options</replaceable>	<replaceable>dumpfreq</replaceable>	<replaceable>passno</replaceable></programlisting>

      <variablelist>
	<varlistentry>
	  <term><literal>device</literal></term>

	  <listitem>
            <para>Ein existierender Gerätename
	      wie in <xref linkend="disks-naming"/> beschrieben.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>mount-point</literal></term>

	  <listitem>
            <para>Ein existierendes Verzeichnis, auf dem
	      das Dateisystem gemountet wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>fstype</literal></term>

	  <listitem>
            <para>Der Typ des Dateisystems,
	      der an &man.mount.8; weitergegeben wird.  &os;s
	      Standarddateisystem ist <literal>ufs</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>options</literal></term>

	  <listitem>
	    <para>Entweder <option>rw</option>
	      für beschreibbare Dateisysteme oder <option>ro</option>
	      für schreibgeschützte Dateisysteme, gefolgt von
	      weiteren benötigten Optionen.  Eine häufig verwendete
	      Option ist <option>noauto</option> für Dateisysteme,
	      die während der normalen Bootsequenz nicht angehangen
	      werden sollen.  Weitere Optionen finden sich
	      in &man.mount.8;.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>dumpfreq</literal></term>

	  <listitem><para>Wird von &man.dump.8; benutzt, um bestimmen
	      zu können, welche Dateisysteme gesichert werden müssen.
	      Fehlt der Wert, wird <literal>0</literal>
	      angenommen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>passno</literal></term>

	  <listitem><para>Bestimmt die Reihenfolge, in der die Dateisysteme
	      überprüft werden sollen.  Für Dateisysteme,
	      die übersprungen werden sollen, ist
	      <literal>passno</literal> auf <literal>0</literal> zu setzen.  Für das
	      Root-Dateisystem, das vor allen anderen überprüft
	      werden muss, sollte der Wert von
	      <literal>passno</literal> <literal>1</literal> betragen.  Allen anderen
	      Dateisystemen sollten Werte größer <literal>1</literal> zugewiesen
	      werden.  Wenn mehrere Dateisysteme den gleichen Wert
	      besitzen, wird &man.fsck.8; versuchen, diese parallel zu
	      überprüfen.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Lesen Sie &man.fstab.5; für weitere Informationen über das
	Format von <filename>/etc/fstab</filename> und dessen
	Optionen.</para>
    </sect2>

    <sect2 xml:id="disks-mount">
      <title>Verwendung von &man.mount.8;</title>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>anhängen</secondary>
      </indexterm>

      <para>Dateisysteme werden mit &man.mount.8; eingehängt.  In der
	grundlegenden Form wird es wie folgt benutzt:</para>

      <informalexample>
	<screen>&prompt.root; <userinput>mount <replaceable>device</replaceable>
<replaceable>mountpoint</replaceable></userinput></screen>
      </informalexample>

      <para>Dieser Befehl bietet viele Optionen, die in &man.mount.8;
	beschrieben werden.  Die am häufigsten verwendeten Optionen
	sind:</para>

      <variablelist>
	<title>Optionen von <command>mount</command></title>

	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
            <para>Hängt alle Dateisysteme aus
	      <filename>/etc/fstab</filename> an.  Davon ausgenommen
	      sind Dateisysteme, die mit <quote>noauto</quote> markiert
	      sind, die mit der Option <option>-t</option> ausgeschlossen
	      wurden und Dateisysteme, die schon angehangen sind.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-d</option></term>

	  <listitem>
            <para>Führt alles bis auf den
	      <function>mount</function>-Systemaufruf aus.
	      Nützlich ist diese Option in Verbindung
	      mit <option>-v</option>.  Damit wird angezeigt, was
	      &man.mount.8; tatsächlich versuchen
	      würde, um das Dateisystem anzuhängen.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-f</option></term>

	  <listitem>
	    <para>Erzwingt das Anhängen eines unsauberen Dateisystems
	      (riskant) oder die Rücknahme des Schreibzugriffs, wenn
	      der Status des Dateisystems von beschreibbar auf
	      schreibgeschützt geändert wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-r</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem schreibgeschützt ein.  Dies
	      kann auch durch Angabe von <option>-o ro</option>
	      erreicht werden.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-t</option>
	    <replaceable>fstype</replaceable></term>

	  <listitem>
            <para>Hängt das Dateisystem mit dem angegebenen Typ an,
	      oder hängt nur Dateisysteme mit dem angegebenen Typ
	      an, wenn <option>-a</option> angegeben wurde.
	      <quote>ufs</quote> ist das Standarddateisystem.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-u</option></term>

	  <listitem>
	    <para>Aktualisiert die Mountoptionen des Dateisystems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Geschwätzig sein.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-w</option></term>

	  <listitem>
	    <para>Hängt das Dateisystem beschreibbar an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Die folgenden Optionen können durch eine Kommata
	separierte Liste an <option>-o</option> übergeben
	werden:</para>

      <variablelist>
	<varlistentry>
	  <term>nosuid</term>

	  <listitem>
	    <para>SetUID und SetGID Bits werden auf dem Dateisystem
	      nicht beachtet.  Dies ist eine nützliche
	      Sicherheitsfunktion.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 xml:id="disks-umount">
      <title>Verwendung von &man.umount.8;</title>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>abhängen</secondary>
      </indexterm>

      <para>&man.umount.8; hängt ein Dateisysstem ab. Dieser Befehl
	akzeptiert als Parameter entweder
	einen Mountpoint, einen Gerätenamen, <option>-a</option>
	oder <option>-A</option>.</para>

      <para>Jede Form akzeptiert <option>-f</option>, um das
	Abhängen zu erzwingen, und <option>-v</option>, um
	etwas geschwätziger zu sein.  Seien Sie bitte vorsichtig mit
	<option>-f</option>, da der Computer abstürzen kann oder es
	können Daten auf dem Dateisystem beschädigt werden.</para>

      <para>Um alle Dateisysteme abzuhängen, oder nur diejenigen, die
	mit <option>-t</option> gelistet werden, wird
	<option>-a</option> oder <option>-A</option> benutzt.
	Beachten Sie, dass <option>-a</option> das Root-Dateisystem
	nicht aushängt.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="basics-processes">
    <title>Prozesse</title>

    <para>&os; ist ein Multitasking-Betriebssystem.  Jedes
      Programm, das zu irgendeiner Zeit läuft wird als
      <firstterm>Prozess</firstterm> bezeichnet.  Jedes laufende
      Kommando startet mindestens einen neuen Prozess.  Dazu gibt
      es eine Reihe von Systemprozessen, die von &os; ausgeführt
      werden.</para>

    <para>Jeder Prozess wird durch eine eindeutige Nummer identifiziert,
      die <firstterm>Prozess-ID</firstterm>
      (<firstterm>PID</firstterm>) genannt wird.  Prozesse haben ebenso
      wie Dateien einen Besitzer und eine Gruppe, die festlegen, welche
      Dateien und Geräte der Prozess benutzen kann.  Die meisten
      Prozesse haben auch einen Elternprozess, der sie gestartet hat.
      Beispielsweise ist die Shell ein Prozess.  Jedes in Shell
      gestartete Kommando ist dann ein neuer Prozess, der die Shell
      als Elternprozess besitzt.  Die Ausnahme hiervon ist ein
      spezieller Prozess namens &man.init.8;, der beim booten immer
      als erstes gestartet wird und der immer die
      <acronym>PID</acronym> 1 hat.</para>

    <para>Um die Prozesse auf dem System zu sehen, benutzen Sie
      &man.ps.1; und &man.top.1;.  Eine statische Liste der laufenden
      Prozesse, deren <acronym>PID</acronym>s, Speicherverbrauch und
      die Kommandozeile, mit der sie gestartet wurden, erhalten Sie
      mit &man.ps.1;.  Um alle laufenden Prozesse in einer Anzeige zu
      sehen, die alle paar Sekunden aktualisiert wird, so dass Sie
      interaktiv sehen können was der Computer macht, benutzen Sie
      &man.top.1;.</para>

    <para>In der Voreinstellung zeigt &man.ps.1; nur die laufenden
      Prozesse, die dem Benutzer gehören.  Zum Beispiel:</para>

    <screen>&prompt.user; <userinput>ps</userinput>
  PID  TT  STAT      TIME COMMAND
  298  p0  Ss     0:01.10 tcsh
 7078  p0  S      2:40.88 xemacs mdoc.xsl (xemacs-21.1.14)
37393  p0  I      0:03.11 xemacs freebsd.dsl (xemacs-21.1.14)
72210  p0  R+     0:00.00 ps
  390  p1  Is     0:01.14 tcsh
 7059  p2  Is+    1:36.18 /usr/local/bin/mutt -y
 6688  p3  IWs    0:00.00 tcsh
10735  p4  IWs    0:00.00 tcsh
20256  p5  IWs    0:00.00 tcsh
  262  v0  IWs    0:00.00 -tcsh (tcsh)
  270  v0  IW+    0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16
  280  v0  IW+    0:00.00 xinit /home/nik/.xinitrc -- -bpp 16
  284  v0  IW     0:00.00 /bin/sh /home/nik/.xinitrc
  285  v0  S      0:38.45 /usr/X11R6/bin/sawfish</screen>

    <para>Die Ausgabe von &man.ps.1; ist in einer Anzahl von Spalten
      organisiert.  Die <literal>PID</literal> Spalte zeigt die
      Prozess-ID.  <acronym>PID</acronym>s werden von 1 beginnend bis
      99999 zugewiesen und fangen wieder von vorne an.  Ist eine
      <acronym>PID</acronym> bereits vergeben, wird diese allerdings
      nicht erneut vergeben.  Die Spalte <literal>TT</literal> zeigt
      den Terminal, auf dem das Programm läuft.
      <literal>STAT</literal> zeigt den Status des Programms und
      <literal>TIME</literal> gibt die Zeit an, die das Programm auf
      der CPU gelaufen ist.  Dies ist nicht unbedingt die Zeit, die
      seit dem Start des Programms vergangen ist, da die meisten
      Programme hauptsächlich auf bestimmte Dinge warten, bevor sie
      wirklich CPU-Zeit verbrauchen.  Unter der Spalte
      <literal>COMMAND</literal> findet sich schließlich die
      Kommandozeile, mit der das Programm gestartet wurde.</para>

    <para>&man.ps.1; besitzt viele Optionen, um die angezeigten Informationen
      zu beeinflussen.  Eine nützliche Kombination ist
      <literal>auxww</literal>.  <option>a</option> zeigt Information
      über alle laufenden Prozesse aller Benutzer. Der Name des
      Besitzers des Prozesses, sowie Informationen
      über den Speicherverbrauch werden mit <option>u</option>
      angezeigt.  <option>x</option> zeigt auch Dämonen-Prozesse an,
      und <option>ww</option> veranlasst &man.ps.1; die komplette
      Kommandozeile für jeden Befehl anzuzeigen, anstatt sie
      abzuschneiden, wenn sie zu lang für die Bildschirmausgabe
      wird.</para>

    <para>Die Ausgabe von &man.top.1; sieht ähnlich aus:</para>

    <screen>&prompt.user; <userinput>top</userinput>
last pid: 72257;  load averages:  0.13,  0.09,  0.03    up 0+13:38:33  22:39:10
47 processes:  1 running, 46 sleeping
CPU states: 12.6% user,  0.0% nice,  7.8% system,  0.0% interrupt, 79.7% idle
Mem: 36M Active, 5256K Inact, 13M Wired, 6312K Cache, 15M Buf, 408K Free
Swap: 256M Total, 38M Used, 217M Free, 15% Inuse

  PID USERNAME PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND
72257 nik       28   0  1960K  1044K RUN      0:00 14.86%  1.42% top
 7078 nik        2   0 15280K 10960K select   2:54  0.88%  0.88% xemacs-21.1.14
  281 nik        2   0 18636K  7112K select   5:36  0.73%  0.73% XF86_SVGA
  296 nik        2   0  3240K  1644K select   0:12  0.05%  0.05% xterm
  175 root       2   0   924K   252K select   1:41  0.00%  0.00% syslogd
 7059 nik        2   0  7260K  4644K poll     1:38  0.00%  0.00% mutt
...</screen>

    <para>Die Ausgabe ist in zwei Abschnitte geteilt.  In den ersten
      fünf Kopfzeilen finden sich die zuletzt zugeteilte
      <acronym>PID</acronym>, die Systemauslastung
      (engl. <foreignphrase>load average</foreignphrase>), die
      Systemlaufzeit (die Zeit seit dem letzten Reboot) und die
      momentane Zeit.  Die weiteren Zahlen im Kopf beschreiben wie
      viele Prozesse momentan laufen (im Beispiel 47), wie viel
      Speicher und Swap verbraucht wurde und wie viel Zeit das System
      in den verschiedenen CPU-Modi verbringt.</para>

    <para>Darunter befinden sich einige Spalten mit ähnlichen
      Informationen wie in der Ausgabe von &man.ps.1;,
      beispielsweise die <acronym>PID</acronym>, den Besitzer, die
      verbrauchte CPU-Zeit und das Kommando, das den Prozess gestartet
      hat.  &man.top.1; zeigt in zwei Spalten den Speicherverbrauch
      des Prozesses an.  Die erste Spalte gibt
      den gesamten Speicherverbrauch des Prozesses an, in der zweiten
      Spalte wird der aktuelle Verbrauch angegeben.
      <application>mutt</application> hat im gezeigten Beispiel
      insgesamt 8&nbsp;MB Speicher verbraucht.  Momentan benutzt
      es allerdings nur 5&nbsp;MB.</para>

    <para>Die Anzeige wird von &man.top.1; automatisch alle zwei
      Sekunden aktualisiert.  Ein anderer Intervall kann mit
      <option>-s</option> spezifiziert werden.</para>
  </sect1>

  <sect1 xml:id="basics-daemons">
    <title>Dämonen, Signale und Stoppen von Prozessen</title>

    <para>Wenn Sie einen Editor benutzen, können Sie ihn leicht
      bedienen und Dateien laden, weil der Editor dafür Vorsorge
      getroffen hat und auf einem <firstterm>Terminal</firstterm>
      läuft.  Manche Programme erwarten keine Eingaben von einem
      Benutzer und lösen sich bei erster Gelegenheit von ihrem
      Terminal.  Ein Webserver zum Beispiel antwortet auf
      Web-Anfragen und nicht auf Benutzereingaben.  Mail-Server sind
      ein weiteres Beispiel für diesen Typ von Anwendungen.</para>

    <para>Diese Programme sind als <firstterm>Dämonen</firstterm>
      bekannt.  Der Begriff Dämon stammt aus der griechischen
      Mythologie und bezeichnet ein Wesen, das weder gut noch böse ist
      und welches unsichtbar nützliche Aufgaben verrichtet.  Deshalb
      ist das BSD Maskottchen dieser fröhlich aussehende Dämon mit
      Turnschuhen und Dreizack.</para>

    <para>Programme, die als Dämon laufen, werden entsprechend einer
      Konvention mit einem <quote>d</quote> am Ende benannt.
      <application>BIND</application> steht beispielsweise für
      Berkeley Internet Name Domain, das tatsächlich laufende Programm
      heißt aber &man.named.8;.  Der <application>Apache</application>
      Webserver wird <command>httpd</command> genannt und der
      Druckerspool-Dämon heißt &man.lpd.8;.  Dies ist allerdings nur
      eine Konvention. Der Dämon der Anwendung
      <application>Sendmail</application> heißt beispielsweise
      &man.sendmail.8; und nicht <literal>maild</literal>.</para>

    <para>Eine Möglichkeit mit einem Dämon oder einem laufenden
      Prozess zu kommunizieren, ist über das Versenden von
      <firstterm>Signalen</firstterm> mittels &man.kill.1;.  Es gibt
      eine Reihe von verschiedenen Signalen.  Manche haben eine feste
      Bedeutung, während andere in der Dokumentation der Anwendung
      beschrieben sind.  Ein Benutzer kann ein Signal nur an einen
      Prozess senden, welcher ihm gehört.  Wird versucht ein Signal
      an einen Prozess eines anderen Benutzers zu senden, resultiert
      dies in einem Zugriffsfehler mangels fehlender Berechtigungen.
      Die Ausnahme ist der
      <systemitem class="username">root</systemitem>-Benutzer, welcher
      jedem Prozess Signale senden kann.</para>

    <para>&os; kann auch ein Signal an einen Prozess senden.  Wenn
      eine Anwendung schlecht geschrieben ist und auf Speicher
      zugreift, auf den sie nicht zugreifen soll, so sendet &os; dem
      Prozess das <firstterm>Segmentation Violation</firstterm> Signal
      (<literal>SIGSEGV</literal>).  Wenn eine Anwendung den &man.alarm.3;
      Systemaufruf benutzt hat, um nach einiger Zeit benachrichtigt zu
      werden, bekommt sie das Alarm Signal (<literal>SIGALRM</literal>)
      gesendet.</para>

    <para>Zwei Signale können benutzt werden, um einen Prozess zu stoppen:
      <literal>SIGTERM</literal> und <literal>SIGKILL</literal>.
      <literal>SIGTERM</literal> fordert den Prozess höflich zum
      Beenden auf.  Der Prozess kann das Signal abfangen und hat dann
      Gelegenheit Logdateien  zu schließen und die Aktion, die er
      durchführte, abzuschließen.  In manchen Situationen kann der
      Prozess <literal>SIGTERM</literal> ignorieren, wenn er eine
      Aktion durchführt, die nicht unterbrochen werden darf.</para>

    <para><literal>SIGKILL</literal> kann von keinem Prozess ignoriert
      werden.  Das Signal lässt sich mit <quote>Mich interessiert
      nicht, was du gerade machst, hör sofort auf damit!</quote>
      umschreiben.  Wird einem Prozess <literal>SIGKILL</literal>
      geschickt, dann wird &os; diesen sofort beenden<footnote>
	<para>Es gibt Fälle, in denen ein Prozess nicht unterbrochen
	  werden kann.  Wenn ein Prozess zum Beispiel eine Datei von
	  einem anderen Rechner auf dem Netzwerk liest und dieser
	  Rechner nicht erreichbar ist, dann ist der Prozess nicht zu
	  unterbrechen.  Wenn der Prozess den Lesezugriff nach einem
	  Timeout von typischerweise zwei Minuten aufgibt, dann wird
	  er beendet.</para>
      </footnote>.</para>

    <para>Andere häufig verwendete Signale sind
      <literal>SIGHUP</literal>, <literal>SIGUSR1</literal> und
      <literal>SIGUSR2</literal>.  Diese Signale sind für allgemeine
      Zwecke vorgesehen und verschiedene Anwendungen werden
      unterschiedlich auf diese Signale reagieren.</para>

    <para>Ändern Sie beispielsweise die Konfiguration eines
      Webservers, so muss dieser angewiesen werden, seine
      Konfiguration neu zu lesen.  Ein Neustart von
      <command>httpd</command> würde dazu führen, dass der Server für
      kurze Zeit nicht erreichbar ist.  Senden Sie dem Dämon
      stattdessen das <literal>SIGHUP</literal>-Signal.  Es sei
      erwähnt, dass verschiedene Dämonen sich anders verhalten.  Lesen
      Sie bitte die Dokumentation des entsprechenden Dämonen um zu
      überprüfen, ob der Dämon bei einem <literal>SIGHUP</literal> die
      gewünschten Ergebnisse erzielt.</para>

    <procedure>
      <title>Verschicken von Signalen</title>

      <para>Das folgende Beispiel zeigt, wie Sie &man.inetd.8; ein
	Signal schicken.  Die Konfigurationsdatei von
	&man.inetd.8; ist <filename>/etc/inetd.conf</filename>.
	Diese Konfigurationsdatei liest &man.inetd.8; ein,
	wenn er <literal>SIGHUP</literal> empfängt.</para>

      <step>
	<para>Suchen Sie mit &man.pgrep.1; die <acronym>PID</acronym>
	  des Prozesses, dem Sie ein Signal schicken wollen.  In
	  diesem Beispiel ist die <acronym>PID</acronym> von
	  &man.inetd.8; 198:</para>

	<screen>&prompt.user; <userinput>pgrep -l inetd</userinput>
198 inetd -wW</screen>

      </step>

      <step>
	<para>Benutzen Sie &man.kill.1;, um ein Signal zu senden.  Da
	  &man.inetd.8; dem Benutzer <systemitem
	    class="username">root</systemitem> gehört, müssen
	  Sie zuerst mit &man.su.1;
	  <systemitem class="username">root</systemitem>
	  werden:</para>

	<screen>&prompt.user; <userinput>su</userinput>
<prompt>Password:</prompt>
&prompt.root; <userinput>/bin/kill -s HUP 198</userinput></screen>

	<para>&man.kill.1; wird, wie andere &unix; Kommandos auch,
	  keine Ausgabe erzeugen, wenn das Kommando erfolgreich war.
	  Wird versucht, einem Prozess der nicht dem Benutzer
	  gehört, ein Signal zu senden, dann wird die Meldung
	  <errorname>kill: <replaceable>PID</replaceable>: Operation
	    not permitted</errorname> ausgegeben.  Ein Tippfehler bei
	  der Eingabe der <acronym>PID</acronym> führt dazu, dass das
	  Signal an einen falschen Prozess gesendet wird, was zu
	  negativen Ergebnissen führen kann, oder das Signal wird an
	  eine <acronym>PID</acronym> gesendet die derzeit nicht in
	  Gebrauch ist, was zu dem Fehler
	  <errorname>kill: <replaceable>PID</replaceable>: No such
	    process</errorname> führt.</para>

	<note>
	  <title>Warum sollte man <command>/bin/kill</command>
	    benutzen?</title>

	  <para>Viele Shells stellen <command>kill</command> als internes
	    Kommando zur Verfügung, das heißt die Shell sendet
	    das Signal direkt, anstatt <filename>/bin/kill</filename>
	    zu starten.  Beachten Sie, dass die unterschiedlichen
	    Shells eine andere Syntax benutzen, um die Namen der
	    Signale anzugeben.  Anstatt jede Syntax zu
	    lernen, kann es einfacher sein, <command>/bin/kill
	      <replaceable>...</replaceable></command> direkt
	    aufzurufen.</para>
	</note>
      </step>
    </procedure>

    <para>Beim Versenden von anderen Signalen, ersetzen
      Sie <literal>TERM</literal> oder <literal>KILL</literal> in der
      Kommandozeile mit dem entsprechenden Signal.</para>

    <important>
      <para>Das zufällige Beenden eines Prozesses kann gravierende
	Auswirkungen haben.  Insbesondere &man.init.8;, mit der
	<acronym>PID</acronym> 1, ist ein Spezialfall.
	<command>/bin/kill -s KILL 1</command> ist ein schneller,
	jedoch nicht empfohlener Weg, das System herunterzufahren.
	Überprüfen Sie die Argumente von &man.kill.1;
	<emphasis>immer</emphasis> zweimal <emphasis>bevor</emphasis>
	Sie <keycap>Return</keycap> drücken.</para>
    </important>
  </sect1>

  <sect1 xml:id="shells">
    <title>Shells</title>
    <indexterm><primary>Shells</primary></indexterm>
    <indexterm><primary>Kommandozeile</primary></indexterm>

    <para>&os; stellt mit der Shell eine Kommandozeilen-Schnittstelle
      zur Verfügung.  Eine Shell empfängt Befehle von einem
      Eingabekanal und führt diese aus.  Viele Shells bieten bieten
      eingebaute Funktionen, die die tägliche Arbeit erleichtern,
      beispielsweise eine Dateiverwaltung, die Vervollständigung von
      Dateinamen (Globbing), Kommandozeilen-Editor, sowie Makros und
      Umgebungsvariablen.  &os; enthält einige Shells, darunter die
      Bourne Shell (&man.sh.1;) und die verbesserte C-Shell
      (&man.tcsh.1;).  Weitere Shells, wie <command>zsh</command> oder
      <command>bash</command>, befinden sich in der
      Ports-Sammlung.</para>

    <para>Die verwendete Shell ist letztlich eine Frage des
      Geschmacks.  Ein C-Programmierer, findet vielleicht eine
      C-artige Shell wie &man.tcsh.1; angenehmer.  Ein
      &linux;-Benutzer bevorzugt vielleicht <command>bash</command>.
      Jede Shell hat ihre speziellen Eigenschaften, die mit der
      bevorzugten Arbeitsumgebung des Benutzers harmonieren kann oder
      nicht.  Deshalb stehen mehrere Shells zur Auswahl.</para>

    <para>Ein verbreitetes Merkmal in Shells ist die
      Dateinamen-Vervollständigung.  Nachdem der Benutzer einige
      Buchstaben eines Kommandos oder eines Dateinamen eingeben hat,
      vervollständigt die Shell den Rest automatisch durch
      drücken der <keycap>Tab</keycap>-Taste.  Angenommen, Sie
      haben zwei Dateien <filename>foobar</filename> und
      <filename>foo.bar</filename>.  Um <filename>foo.bar</filename>
      zu löschen,  geben Sie folgendes ein:
      <command>rm fo[Tab].[Tab]</command></para>

    <para>Die Shell sollte dann <command>rm
      foo[BEEP].bar</command> ausgeben.</para>

    <para>[BEEP] meint den Rechner-Piepser, den die Shell ausgibt um
      anzuzeigen, dass es den Dateinamen nicht vervollständigen
      konnte, da es mehrere Möglichkeiten gibt.  Beide Dateien
      <filename>foobar</filename> und <filename>foo.bar</filename>
      beginnen mit <literal>fo</literal>.  Nach der Eingabe von
      <literal>.</literal> und erneutem drücken der
      <keycap>Tab</keycap>-Taste, war die Shell in der Lage den Rest
      auszufüllen.</para>

    <indexterm><primary>Umgebungsvariablen</primary></indexterm>

    <para>Ein weiteres Merkmal der Shell ist der Gebrauch von
      Umgebungsvariablen.  Dies sind veränderbare Schlüsselpaare
      im Umgebungsraum der Shell, die jedes von der Shell aufgerufene
      Programm lesen kann.  Daher enthält der Umgebungsraum viele
      Konfigurationsdaten für Programme.  Die folgende Liste zeigt
      verbreitete Umgebungsvariablen und deren Bedeutung:</para>

    <informaltable frame="none" pgwide="1">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Variable</entry>
	    <entry>Beschreibung</entry>
	  </row>
	</thead>

	<tbody>
	  <row>
	    <entry><envar>USER</envar></entry>
	    <entry>Name des angemeldeten Benutzers.</entry>
	  </row>

	  <row>
	    <entry><envar>PATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Programmen.</entry>
	  </row>

	  <row>
	    <entry><envar>DISPLAY</envar></entry>
	    <entry>Der Name des
	      <application>Xorg</application>-Bildschirms, auf dem
	      Ausgaben erfolgen sollen.</entry>
	  </row>

	  <row>
	    <entry><envar>SHELL</envar></entry>
	    <entry>Die aktuelle Shell.</entry>
	  </row>

	  <row>
	    <entry><envar>TERM</envar></entry>
	    <entry>Name des Terminaltyps des Benutzers.  Benutzt, um die
              Fähigkeiten des Terminals zu bestimmen.</entry>
	  </row>

	  <row>
	    <entry><envar>TERMCAP</envar></entry>
	    <entry>Datenbankeintrag der Terminal Escape Codes,
              benötigt um verschieden Terminalfunktionen
              auszuführen.</entry>
	  </row>

	  <row>
	    <entry><envar>OSTYPE</envar></entry>
	    <entry>Typ des Betriebssystems.</entry>
	  </row>

	  <row>
	    <entry><envar>MACHTYPE</envar></entry>
	    <entry>Die CPU-Architektur des Systems.</entry>
	  </row>

	  <row>
	    <entry><envar>EDITOR</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Editor.</entry>
	  </row>

	  <row>
	    <entry><envar>PAGER</envar></entry>
	    <entry>Vom Benutzer bevorzugter Text-Betrachter.</entry>
	  </row>

	  <row>
	    <entry><envar>MANPATH</envar></entry>
	    <entry>Liste mit Verzeichnissen (getrennt durch Doppelpunkt)
              zum Suchen nach Manualpages.</entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>

    <indexterm>
      <primary>Shells</primary>
      <secondary>Bourne Shell</secondary>
    </indexterm>
    <para>Das Setzen von Umgebungsvariablen unterscheidet sich
      von Shell zu Shell.  In &man.tcsh.1; und &man.csh.1; wird dazu
      <command>setenv</command> benutzt.  &man.sh.1; und
      <command>bash</command> benutzen <command>export</command> um
      Umgebungsvariablen zu setzen.  Dieses Beispiel für die
      &man.tcsh.1;-Shell setzt die Variable <envar>EDITOR</envar> auf
      <filename>/usr/local/bin/emacs</filename>:</para>

    <screen>&prompt.user; <userinput>setenv EDITOR /usr/local/bin/emacs</userinput></screen>

    <para>Der entsprechende Befehl für <command>bash</command>
      wäre:</para>

    <screen>&prompt.user; <userinput>export EDITOR="/usr/local/bin/emacs"</userinput></screen>

    <para>Um eine Umgebungsvariable zu expandieren, geben Sie in der
      Kommandozeile das Zeichen <literal>$</literal> vor dessen Namen
      ein.  Zum Beispiel gibt <command>echo $TERM</command> den
      aktuellen Wert von<envar>$TERM</envar> aus.</para>

    <para>Shells behandeln Spezialzeichen, so genannte Metazeichen,
      als besondere Darstellungen für Daten.  Das häufigste Zeichen
      ist <literal>*</literal>, das eine beliebige Anzahl Zeichen in
      einem Dateinamen repräsentiert.  Metazeichen können zur
      Vervollständigung von Dateinamen (Globbing) benutzt werden.
      Beispielsweise liefert <command>echo *</command> nahezu das
      gleiche wie &man.ls.1;, da die Shell alle Dateinamen die mit
      <literal>*</literal> übereinstimmen, an <command>echo</command>
      weitergibt.</para>

    <para>Um zu verhindern, dass die Shell ein Sonderzeichen
      interpretiert, schützt man es, indem man einen
      Backslash (<literal>\</literal>) voranstellt.  Zum Beispiel
      zeigt <command>echo $TERM</command> die Einstellung des
      Terminals an, wohingegen <command>echo \$TERM</command> einfach
      die Zeichenfolge <literal>$TERM</literal> ausgibt.</para>

    <sect2 xml:id="changing-shells">
      <title>Ändern der Shell</title>

      <para>Der einfachste Weg die Standard Shell zu ändern, ist
        <command>chsh</command> zu benutzen.
        <command>chsh</command> startet den Editor, welcher durch
	die Umgebungsvariable <envar>EDITOR</envar> gesetzt ist.
	Standardmäßig ist dies &man.vi.1;.
        Tragen Sie in die Zeile die mit <quote>Shell:</quote> beginnt,
        den absoluten Pfad der neuen Shell ein.</para>

      <para>Alternativ setzt <command>chsh -s</command> die Shell,
	ohne dabei einen Editor aufzurufen.  Um die Shell
        zum Beispiel auf <command>bash</command> zu ändern, geben Sie
	folgenden Befehl ein:</para>

      <screen>&prompt.user; <userinput>chsh -s /usr/local/bin/bash</userinput></screen>

      <note>
	<para>Die neue Shell <emphasis>muss</emphasis> in
	  <filename>/etc/shells</filename> aufgeführt sein.  Wurde die
	  Shell aus der &os; Ports-Sammlung installiert, so wie in
	  <xref linkend="ports"/> beschrieben, sollte sie automatisch
	  zu dieser Datei hinzugefügt worden sein.  Wenn der Eintrag
	  fehlt, nutzen Sie folgenden Befehl, und ersetzen Sie den
	  Pfad mit dem Pfad zur gewünschten Shell:</para>

      <screen>&prompt.root; <userinput>echo &quot;/usr/local/bin/bash&quot; &gt;&gt; /etc/shells</userinput></screen>

       <para>Danach kann &man.chsh.1; erneut aufgerufen werden.</para>
     </note>
   </sect2>
  </sect1>

  <sect1 xml:id="editors">
    <title>Text-Editoren</title>
    <indexterm><primary>Text Editoren</primary></indexterm>
    <indexterm><primary>Editoren</primary></indexterm>

    <para>Die meiste Konfiguration unter &os; wird durch
      das Editieren von Textdateien erledigt.  Deshalb ist es eine
      gute Idee, mit einem Texteditor vertraut zu werden.  &os; hat
      ein paar davon im Basissystem und sehr viel mehr in der
      Ports-Sammlung.</para>

    <indexterm>
      <primary>&man.ee.1;</primary>
    </indexterm>

    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>ee</command></secondary>
    </indexterm>

    <para>Ein einfach zu erlernender Editor ist &man.ee.1;, was für
      <foreignphrase>easy editor</foreignphrase> steht.  Um diesen
      Editor zu starten, gibt man in der Kommandozeile <command>ee
	<replaceable>filename</replaceable></command> ein, wobei
      <replaceable>filename</replaceable> den Namen der zu
      editierenden Datei darstellt.  Einmal im Editor, finden sich
      alle Editor-Funktionen oben im Display aufgelistet.  Das
      Einschaltungszeichen <literal>^</literal> steht für die
      <keycap>Ctrl</keycap> (oder <keycap>Strg</keycap>) Taste, mit
      <literal>^e</literal> ist also die Tastenkombination
      <keycombo
	action="simul"><keycap>Ctrl</keycap><keycap>e</keycap></keycombo>
      gemeint.  Um &man.ee.1; zu verlassen, drücken Sie
      <keycap>Esc</keycap> und wählen dann im Hauptmenü <option>leave
        editor</option> aus.  Der Editor fragt nach, ob Sie speichern
      möchten, wenn die Datei verändert wurde.</para>

    <indexterm>
      <primary>&man.vi.1;</primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary>&man.vi.1;</secondary>
    </indexterm>
    <indexterm>
      <primary><command>emacs</command></primary>
    </indexterm>
    <indexterm>
      <primary>Text Editoren</primary>
      <secondary><command>emacs</command></secondary>
    </indexterm>

    <para>&os; verfügt über leistungsfähigere Editoren wie &man.vi.1;
      als Teil des Basissystems.  Andere Editoren wie
      <package>editors/emacs</package> und
      <package>editors/vim</package> sind Teil der Ports-Sammlung.
      Diese Editoren bieten höhere Funktionalität, jedoch auf Kosten
      einer etwas schwierigeren Erlernbarkeit.  Das Erlernen eines
      leistungsfähigeren Editors, wie <application>vim</application>
      oder <application>Emacs</application>, kann auf lange Sicht Zeit
      einsparen.</para>

    <para>Viele Anwendungen, die Dateien verändern oder Texteingabe
      erwarten, werden automatisch einen Texteditor öffnen.  Um den
      Standardeditor zu ändern, wird die Umgebungsvariable
      <envar>EDITOR</envar> gesetzt, wie im Abschnitt
      <xref linkend="shells"/> beschrieben.</para>
  </sect1>

  <sect1 xml:id="basics-devices">
    <title>Geräte und Gerätedateien</title>

    <para>Der Begriff Gerät wird meist in Verbindung mit Hardware
      wie Laufwerken, Druckern, Grafikkarten oder Tastaturen gebraucht.
      Der Großteil der Meldungen, die beim Booten von &os; angezeigt
      werden, beziehen sich auf gefundene Geräte.  Eine Kopie dieser
      Bootmeldungen wird in <filename>/var/run/dmesg.boot</filename>
      gespeichert.</para>

    <para>Jedes Gerät verfügt über einen Gerätenamen und Gerätenummer.
      Zum Beispiel steht <filename>acd0</filename> für das erste
      IDE CD-ROM Laufwerk, während <filename>kbd0</filename> die
      Tastatur repräsentiert.</para>

    <para>Auf die meisten Geräte wird unter &os; über spezielle
      Gerätedateien im <filename>/dev</filename> Verzeichnis
      zugegriffen.</para>
  </sect1>

  <sect1 xml:id="basics-more-information">
    <title>Weitere Informationen</title>

    <sect2 xml:id="basics-man">
      <title>Manualpages</title>
      <indexterm><primary>Manualpages</primary></indexterm>

      <para>Die umfassendste Dokumentation rund um &os; gibt es in
        Form von Manualpages.  Annähernd jedes Programm im System
        bringt eine kurze Referenzdokumentation mit, die die
        grundsätzliche Funktion und verschiedene Parameter
	erklärt.  Diese Manuals können mit <command>man</command>
	eingesehen werden:</para>

      <screen>&prompt.user; <userinput>man <replaceable>Kommando</replaceable></userinput></screen>

      <para><replaceable>Kommando</replaceable> ist der Name des
	Kommandos, über das man etwas erfahren will.  Um
	beispielsweise mehr über das Kommando &man.ls.1; zu
	erfahren, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>man ls</userinput></screen>

      <para>Die Online-Manuals sind in nummerierte Sektionen
        unterteilt:</para>

      <orderedlist>
	<listitem>
	  <para>Benutzerkommandos.</para>
	</listitem>

	<listitem>
	  <para>Systemaufrufe und Fehlernummern.</para>
	</listitem>

	<listitem>
	  <para>Funktionen der C Bibliothek.</para>
	</listitem>

	<listitem>
	  <para>Gerätetreiber.</para>
	</listitem>

	<listitem>
	  <para>Dateiformate.</para>
	</listitem>

	<listitem>
	  <para>Spiele und andere Unterhaltung.</para>
	</listitem>

	<listitem>
	  <para>Verschiedene Informationen.</para>
	</listitem>

	<listitem>
	  <para>Systemverwaltung und -Kommandos.</para>
	</listitem>

	<listitem>
	  <para>Kernel Entwickler.</para>
	</listitem>
      </orderedlist>

      <para>In einigen Fällen kann dasselbe Thema in mehreren
	Sektionen auftauchen.  Es gibt zum Beispiel ein
	&man.chmod.1; Benutzerkommando und einen
	<function>chmod()</function> Systemaufruf.  Um &man.man.1;
	mitzuteilen, aus welcher Sektion die Information angezeigt
	werden soll, kann die Sektionsnummer mit angeben
	werden:</para>

      <screen>&prompt.user; <userinput>man 1 chmod</userinput></screen>

      <para>Dies wird Ihnen die Manualpage für das Benutzerkommando
	&man.chmod.1; zeigen.  Verweise auf eine Sektion der
	Manualpages werden traditionell in Klammern gesetzt.  So
	bezieht sich &man.chmod.1; auf das Benutzerkommando und
	&man.chmod.2; auf den Systemaufruf.</para>

      <para>Wenn der Name des Kommandos nicht bekannt ist, benutzt
	man <command>man -k</command>, um nach Schlüsselbegriffen in
	den Kommandobeschreibungen zu suchen:</para>

      <screen>&prompt.user; <userinput>man -k <replaceable>mail</replaceable>
</userinput></screen>

      <para>Dieser Befehl zeigt eine Liste von Kommandos, deren
        Beschreibung das Schlüsselwort
        <quote>mail</quote> enthält.  Die gleiche Funktionalität
        erhalten Sie auch, wenn Sie &man.apropos.1;
        benutzen.</para>

      <para>Um herauszufinden, was die Kommandos in
	<filename>/usr/bin</filename> tun, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>man -f *</userinput></screen>

      <para>Dasselbe erreichen Sie durch Eingabe von:</para>

      <screen>&prompt.user; <userinput>cd /usr/bin</userinput>
&prompt.user; <userinput>whatis *</userinput></screen>

    </sect2>

    <sect2 xml:id="basics-info">
      <title>GNU Info Dateien</title>

      <para>&os; enthält viele Anwendungen und Utilities der Free
	Software Foundation (FSF).  Zusätzlich zu den Manualpages
	können diese Programme Hypertext-Dokumente enthalten, die
	<literal>info</literal>-Seiten genannt werden.  Diese
	Dokumente können mit &man.info.1; ansehen kann.  Wenn
	<package>editors/emacs</package> installiert ist, kann auch
	der info-Modus von <application>emacs</application> benutzt
	werden.</para>

      <para>Um &man.info.1; zu benutzen, geben Sie ein:</para>

      <screen>&prompt.user; <userinput>info</userinput></screen>

      <para>Eine kurze Einführung gibt es mit
        <literal>h</literal>; eine Befehlsreferenz erhalten Sie durch
        Eingabe von: <literal>?</literal>.</para>
    </sect2>
  </sect1>
</chapter>
