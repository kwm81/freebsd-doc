<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/disks/chapter.xml,v 1.187 2012/04/26 19:32:48 bcr Exp $
     basiert auf: r44389
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="disks">
  <info><title>Speichermedien</title>
    <authorgroup>
      <author><personname><firstname>Bernd</firstname><surname>Warken</surname></personname><contrib>Übersetzt von </contrib></author>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname></author>
    </authorgroup>
  </info>

  <sect1 xml:id="disks-synopsis">
    <title>Übersicht</title>

    <para>Dieses Kapitel behandelt die Benutzung von Laufwerken unter
      &os;.  Hierzu zählen speichergestützte Laufwerke, Netzlaufwerke,
      <acronym>SCSI</acronym>/<acronym>IDE</acronym>-Geräte und
      Geräte, die die <acronym>USB</acronym>-Schnittstelle
      benutzen.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes
      wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Begriffe, die &os; verwendet, um die
	  Organisation der Daten auf einem physikalischen Laufwerk
	  zu beschreiben.</para>
      </listitem>

      <listitem>
	<para>Wie Sie zusätzliche Laufwerke zu einem &os;-System
	  hinzufügen.</para>
      </listitem>

      <listitem>
	<para>Wie Sie &os; zur Verwendung von
	  <acronym>USB</acronym>-Speichermedien konfigurieren.</para>
      </listitem>

      <listitem>
	<para>Wie virtuelle Dateisysteme, zum Beispiel RAM-Disks,
	  eingerichtet werden.</para>
      </listitem>

      <listitem>
	<para>Wie Sie mit Quotas die Benutzung von Laufwerken
	  einschränken können.</para>
      </listitem>

      <listitem>
	<para>Wie Sie Partitionen verschlüsseln, um Ihre Daten
	  zu schützen.</para>
      </listitem>

      <listitem>
	<para>Wie unter &os; <acronym>CD</acronym>s und
	  <acronym>DVD</acronym>s gebrannt werden.</para>
      </listitem>

      <listitem>
	<para>Wie Sie die unter &os; erhältlichen
	  Backup-Programme benutzen.</para></listitem>

      <listitem>
	<para>Was Dateisystem-Schnappschüsse sind und wie sie
	  eingesetzt werden.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen,</para>

    <itemizedlist>
      <listitem>
	<para>sollten Sie wissen, wie Sie einen
	  <link linkend="kernelconfig">neuen &os;-Kernel konfigurieren
	    und installieren</link> können.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="disks-naming">
    <title>Gerätenamen</title>

    <para>Die folgende Tabelle zeigt die von &os; unterstützten
      Speichergeräte und deren Gerätenamen.</para>

    <table xml:id="disk-naming-physical-table" frame="none">
      <title>Namenskonventionen von physikalischen Laufwerken</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Laufwerkstyp</entry>
	    <entry>Gerätename</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><acronym>IDE</acronym>-Festplatten</entry>
	    <entry><literal>ad</literal> oder
	      <literal>ada</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>IDE</acronym>-<acronym>CD-ROM</acronym>-Laufwerke</entry>
	    <entry><literal>acd</literal> oder
	      <literal>cd</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>SATA</acronym>-Festplatten</entry>
	    <entry><literal>ad</literal> oder
	      <literal>ada</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>SATA</acronym>-<acronym>CD-ROM</acronym>-Laufwerke</entry>
	    <entry><literal>acd</literal> oder
	      <literal>cd</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>SCSI</acronym>-Festplatten und
	      <acronym>USB</acronym>-Speichermedien</entry>
	    <entry><literal>da</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>SCSI</acronym>-<acronym>CD-ROM</acronym>-Laufwerke</entry>
	    <entry><literal>cd</literal></entry>
	  </row>

	  <row>
	    <entry>Verschiedene proprietäre <acronym>CD-ROM</acronym>-Laufwerke</entry>
	    <entry><literal>mcd</literal> für Mitsumi
	      <acronym>CD-ROM</acronym> und <literal>scd</literal> für
	      Sony <acronym>CD-ROM</acronym></entry>
	  </row>

	  <row>
	    <entry>Diskettenlaufwerke</entry>
	    <entry><literal>fd</literal></entry>
	  </row>

	  <row>
	    <entry><acronym>SCSI</acronym>-Bandlaufwerke</entry>
	    <entry><literal>sa</literal></entry>
          </row>

	  <row>
	    <entry><acronym>IDE</acronym>-Bandlaufwerke</entry>
	    <entry><literal>ast</literal></entry>
	  </row>

	  <row>
	    <entry>Flash-Laufwerke</entry>
	    <entry><literal>fla</literal> für &diskonchip;
	      Flash-Device</entry>
	  </row>

	  <row>
	    <entry>RAID-Laufwerke</entry>
	    <entry><literal>aacd</literal> für &adaptec; AdvancedRAID,
	      <literal>mlxd</literal> und <literal>mlyd</literal>
	      für &mylex;,
	      <literal>amrd</literal> für AMI &megaraid;,
	      <literal>idad</literal> für Compaq Smart RAID,
	      <literal>twed</literal> für &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 xml:id="disks-adding">
    <info><title>Hinzufügen von Laufwerken</title>
      <authorgroup>
	<author><personname><firstname>David</firstname><surname>O'Brian</surname></personname><contrib>Im Original von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>hinzufügen</secondary>
    </indexterm>

    <para>Dieser Abschnitt beschreibt, wie Sie ein neues
      <acronym>SATA</acronym>-Laufwerk zu einer Maschine
      hinzufügen, die momentan nur ein Laufwerk hat.  Dazu schalten
      Sie zuerst den Rechner aus und installieren das Laufwerk
      entsprechend der Anleitungen Ihres Rechners, Ihres Controllers
      und des Laufwerkherstellers.  Starten Sie das System neu und
      melden Sie sich als Benutzer
      <systemitem class="username">root</systemitem> an.</para>

    <para>Kontrollieren Sie <filename>/var/run/dmesg.boot</filename>,
      um sicherzustellen, dass das neue Laufwerk gefunden wurde.  In
      diesem Beispiel erscheint das neu hinzugefügte
      <acronym>SATA</acronym>-Laufwerk als
      <filename>ada1</filename>.</para>

    <indexterm><primary>Partitionen</primary></indexterm>
    <indexterm>
      <primary><command>gpart</command></primary>
    </indexterm>

    <para>In diesem Beispiel wird eine einzige große Partition auf der
      Festplatte erstellt.  Verwendet wird das <link
	xlink:href="https://de.wikipedia.org/wiki/GUID_Partition_Table"><acronym>GPT</acronym></link>-Partionsschema,
      welches gegenüber dem älteren und weniger vielseitigen
      <acronym>MBR</acronym>-Schema bevorzug wird.</para>

    <note>
      <para>Wenn die hinzugefügte Festplatte nicht leer ist, können
	alte Partitionsinformationen mit
	<command>gpart delete</command> entfernt werden. Details
	finden Sie in &man.gpart.8;.</para>
    </note>

    <para>Zuerst wird das Partitionsschema erstellt und dann eine
      einzelne Partition angefügt:</para>

    <screen>&prompt.root; <userinput>gpart create -s GPT ada1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs ada1</userinput></screen>

    <para>Je nach Anwendung kann es wünschenswert sein, mehrere
      kleinere Partitionen zu haben.  In &man.gpart.8; finden Sie
      Optionen zum Erstellen von kleineren Partitionen.</para>

    <para>Ein Dateisystem wird auf der neuen, leeren Festplatte
      erstellt:</para>

    <screen>&prompt.root; <userinput>newfs -U /dev/ada1p1</userinput></screen>

    <para>Ein leeres Verzeichnis wird als Mountpunkt erstellt, also
      ein Speicherort für die Montage der neuen Festplatte im
      originalen Dateisystem:</para>

    <screen>&prompt.root; <userinput>mkdir /newdisk</userinput></screen>

    <para>Abschließend wird ein Eintrag in
      <filename>/etc/fstab</filename> hinzugefügt, damit die neue
      Festplatte automatisch beim Start eingehängt wird:</para>

    <programlisting>/dev/ada1p1	/newdisk      ufs   rw	    2	  2</programlisting>

    <para>Die neue Festplatte kann manuell montiert werden, ohne das
      System neu zu starten:</para>

    <screen>&prompt.root; <userinput>mount /newdisk</userinput></screen>
  </sect1>

  <sect1 xml:id="disks-growing">
    <info>
      <title>Partitionen vergrößern</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Allan</firstname>
	    <surname>Jude</surname>
	  </personname>
	  <contrib>Beigetragen von </contrib>
	</author>
      </authorgroup>
      <authorgroup>
	<author>
	  <personname>
	    <firstname>Björn</firstname>
	    <surname>Heidotting</surname>
	  </personname>
	  <contrib>Übersetzt von </contrib>
	</author>
      </authorgroup>
    </info>

    <indexterm>
      <primary>Partitionen</primary>
      <secondary>vergrößern</secondary>
    </indexterm>

    <para>Die Kapazität einer Festplatte kann sich ohne Änderungen
      an bereits vorhandenen Daten erhöhen.  Dies geschieht
      üblicherweise mit virtuellen Maschinen, wenn sich herausstellt,
      dass die virtuelle Festplatte zu klein ist und vergrößert werden
      soll.  Zuweilen wird auch ein Abbild einer Platte auf einen
      <acronym>USB</acronym>-Stick geschrieben, ohne dabei die volle
      Kapazität zu nutzen.  Dieser Abschnitt beschreibt, wie man
      Platten vergrößert, bzw. <emphasis>erweitert</emphasis>, um die
      Vorteile der erhöhten Kapazität zu nutzen.</para>

    <para>Überprüfen Sie <filename>/var/run/dmesg.boot</filename>, um
      den Gerätenamen der Festplatte zu bestimmen, die vergrößert
      werden soll.  In diesem Beispiel gibt es nur eine
      <acronym>SATA</acronym>-Festplatte im System, so dass die Platte
      als <filename>ada0</filename> angezeigt wird.</para>

    <indexterm><primary>Partitionen</primary></indexterm>
    <indexterm>
      <primary><command>gpart</command></primary>
    </indexterm>

    <para>Um die aktuelle Konfiguration der Partitionen auf der
      Festplatte anzuzeigen:</para>

    <screen>&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>      34  83886013  ada0  GPT  (48G) [CORRUPT]
        34       128     1  freebsd-boot  (64k)
       162  79691648     2  freebsd-ufs  (38G)
  79691810   4194236     3  freebsd-swap  (2G)
  83886046         1        - free -  (512B)</screen>

    <note>
      <para>Wenn die Festplatte mit dem <link
	  xlink:href="http://en.wikipedia.org/wiki/GUID_Partition_Table">
	  <acronym>GPT</acronym></link>-Partitionsschema formatiert
	wurde kann es vorkommen, dass sie als
	<quote>corrupted</quote> angezeigt wird, weil sich die
	Sicherung der <acronym>GPT</acronym>-Partitionstabellen nicht
	mehr am Ende des Laufwerks befinden.  Reparieren Sie in so
	einem Fall die Partitionstabelle mit
	<command>gpart</command>:</para>

      <screen>&prompt.root; <userinput>gpart recover <replaceable>ada0</replaceable></userinput>
ada0 recovered</screen>
    </note>

    <para>Nun steht der zusätzliche Speicherplatz zur Verfügung und
      kann verwendet werden, um eine neue Partition anzulegen oder
      eine bestehende Partition zu erweitern:</para>

     <screen>&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   79691648     2  freebsd-ufs  (38G)
   79691810    4194236     3  freebsd-swap  (2G)
   83886046   18513921        - free -  (8.8G)</screen>

    <para>Partitionen können nur auf zusammenhängenden, freien
      Speicherplatz vergrößert werden.  In diesem Beispiel wird die
      letzte Partition der Platte als Swap-Speicher genutzt, aber die
      zweite Partition ist die, dessen Größe verändert werden soll.
      Weil der Swap-Speicher nur temporäre Daten enthält, kann er
      gefahrlos ausgehangen, gelöscht und nachdem die Partition
      vergrößert wurde, neu erstellt werden.</para>

    <screen>&prompt.root; <userinput>swapoff <replaceable>/dev/ada0p3</replaceable></userinput>
&prompt.root; <userinput>gpart delete -i <replaceable>3</replaceable> <replaceable>ada0</replaceable></userinput>
ada0p3 deleted
&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   79691648     2  freebsd-ufs  (38G)
	79691810   22708157        - free -  (10G)</screen>

    <warning>
      <para>Es besteht die Gefahr von Datenverlust, wenn die
	Partitionstabelle eines eingehangenen Dateisystems verändert
	wird.  Es empfiehlt sich daher, die folgenden Schritte auf
	einem ausgehangenen Dateisystem durchzuführen, während die
	Umsetzung über eine Live-<acronym>CD-ROM</acronym> oder
	von einem <acronym>USB</acronym>-Gerät erfolgt.  Wenn es
	jedoch absolut notwendig ist, kann ein eingehangenes
	Dateisystem auch vergrößert werden, nachdem die
	Sicherheitsfunktionen von GEOM deaktiviert wurden:</para>

      <screen>&prompt.root; <userinput>sysctl kern.geom.debugflags=16</userinput></screen>
    </warning>

    <para>Vergrößern Sie die Partition und lassen Sie Platz, um die
      Swap-Partition in der gewünschten Größe neu erstellen zu können.
      Dies ändert nur die Größe der Partition.  Das Dateisystem
      innerhalb der Partition wird in einem separaten Schritt
      erweitert.</para>

<screen>&prompt.root; <userinput>gpart resize -i <replaceable>2</replaceable> -a 4k -s <replaceable>47G</replaceable> <replaceable>ada0</replaceable></userinput>
ada0p2 resized
&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   98566144     2  freebsd-ufs  (47G)
   98566306    3833661        - free -  (1.8G)</screen>

    <para>Erstellen Sie die Swap-Partition neu:</para>

<screen>&prompt.root; <userinput>gpart add -t freebsd-swap -a 4k <replaceable>ada0</replaceable></userinput>
ada0p3 added
&prompt.root; <userinput>gpart show <replaceable>ada0</replaceable></userinput>
=>       34  102399933  ada0  GPT  (48G)
         34        128     1  freebsd-boot  (64k)
        162   98566144     2  freebsd-ufs  (47G)
   98566306    3833661     3  freebsd-swap  (1.8G)
&prompt.root; <userinput>swapon <replaceable>/dev/ada0p3</replaceable></userinput></screen>

    <para>Erweitern Sie das <acronym>UFS</acronym>-Dateisystem, um die
      Kapazität der vergrößerten Partition zu nutzen:</para>

    <note>
      <para>Ab &os; 10.0-RELEASE ist es möglich, ein eingehangenes
	Dateisystem zu erweitern.  Bei älteren Versionen muss das
	Dateisystem zuvor ausgehangen werden.</para>
    </note>

    <screen>&prompt.root; <userinput>growfs <replaceable>/dev/ada0p2</replaceable></userinput>
Device is mounted read-write; resizing will result in temporary write suspension for /.
It's strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] <userinput>Yes</userinput>
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432</screen>

    <para>Sowohl die Partition als auch das Dateisystem wurden jetzt
      vergrößert, um den neu zur Verfügung stehenden Speicherplatz zu
      nutzen.</para>
  </sect1>

  <sect1 xml:id="usb-disks">
    <info><title><acronym>USB</acronym> Speichermedien</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>USB</primary>
      <secondary>Speichermedien</secondary>
    </indexterm>

    <para>Der Universal Serial Bus (<acronym>USB</acronym>) wird
      heutzutage von vielen externen Speichern benutzt:  Festplatten,
      <acronym>USB</acronym>-Thumbdrives oder
      <acronym>CD</acronym>-Brennern.  &os; bietet Unterstützung für
      diese Geräte.</para>

    <sect2>
      <title>Konfiguration</title>

      <para>Der Treiber für <acronym>USB</acronym>-Massenspeicher,
	&man.umass.4;, ist im <filename>GENERIC</filename>-Kernel
	enthalten und bietet Unterstützung für
	<acronym>USB</acronym>-Speichermedien.  Für einen angepassten
	Kernel müssen die nachstehenden Zeilen in der
	Kernelkonfigurationsdatei enthalten sein:</para>

      <programlisting>device scbus
device da
device pass
device uhci
device ohci
device ehci
device usb
device umass</programlisting>

      <para>Da der &man.umass.4;-Treiber das
	<acronym>SCSI</acronym>-Subsystem benutzt um auf 
	<acronym>USB</acronym>-Geräte zuzugreifen, werden alle
	<acronym>USB</acronym>-Geräte vom System als
	<acronym>SCSI</acronym>-Geräte erkannt.  Abhängig vom Chipsatz
	der Systemplatine wird <literal>device uhci</literal> oder
	<literal>device ohci</literal> für die Unterstützung von
	<acronym>USB</acronym> 1.X benutzt.  Unterstützung für
	<acronym>USB</acronym> 2.0 Controller wird durch
	<literal>device ehci</literal> bereitgestellt.</para>

      <note>
	<para>Wenn es sich bei dem <acronym>USB</acronym>-Gerät um
	  einen <acronym>CD</acronym>- oder
	  <acronym>DVD</acronym>-Brenner handelt, muss &man.cd.4; in
	  den Kernel aufgenommen werden:</para>

	<programlisting>device cd</programlisting>

	<para>Da der Brenner als <acronym>SCSI</acronym>-Laufwerk
	  erkannt wird, sollte der Treiber &man.atapicam.4; nicht
	  benutzt werden.</para>
      </note>
    </sect2>

    <sect2>
      <title>Die Konfiguration testen</title>

      <para>Um die <acronym>USB</acronym>-Konfiguration zu testen,
	schließen Sie das <acronym>USB</acronym>-Gerät an.  In den
	Systemmeldungen, &man.dmesg.8;, sollte das Gerät wie folgt
	angezeigt werden:</para>

      <screen>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)</screen>

      <para>Fabrikat, Gerätedatei (<filename>da0</filename>) und
	andere Details werden je nach Gerät unterschiedlich
	sein.</para>

      <para>Da ein <acronym>USB</acronym>-Gerät als
	<acronym>SCSI</acronym>-Gerät erkannt wird, kann
	<command>camcontrol</command> benutzt werden, um die mit dem
	System verbundenen <acronym>USB</acronym>-Massenspeicher
	anzuzeigen:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 (da0,pass0)</screen>

      <para>Wenn auf dem Laufwerk ein Dateisystem eingerichtet
	ist, kann es gemountet werden.
	<xref linkend="disks-adding"/> beschreibt, wie Sie
	<acronym>USB</acronym>-Laufwerke formatieren und Partitionen
	einrichten.</para>

      <warning>
        <para>Aus Sicherheitsgründen sollten Sie Benutzern, denen Sie
          nicht vertrauen, das Einhängen (z.B. durch die unten
          beschriebene Aktivierung von <literal>vfs.usermount</literal>)
          beliebiger Medien  verbieten.  Die meisten Dateisysteme in &os;
          wurden nicht entwickelt, um sich vor böswilligen Geräten
          zu schützen.</para>
      </warning>

      <para>Um auch normalen Anwendern das Einhängen des Laufwerks zu
	gestatten, könnten Sie beispielsweise mit &man.pw.8; alle
	potentiellen Benutzer dieser Gerätedateien in die Gruppe
	<systemitem class="groupname">operator</systemitem> aufnehmen.
	Außerdem muss sichergestellt werden, dass Mitglieder der
	Gruppe <systemitem class="groupname">operator</systemitem>
	Schreib- und Lesezugriff auf diese Gerätedateien haben.
	Hierfür werden die folgenden Zeilen in
	<filename>/etc/devfs.rules</filename> hinzugefügt:</para>

      <programlisting>[localrules=5]
add path 'da*' mode 0660 group operator</programlisting>

      <note>
	<para>Verfügt das System über
	  <acronym>SCSI</acronym>-Laufwerke, so verändern Sie die
	  zweite Zeile wie folgt:</para>

	<programlisting>add path 'da[3-9]*' mode 0660 group operator</programlisting>

	<para>Dies wird die ersten drei
	  <acronym>SCSI-Laufwerke</acronym> (<filename>da0</filename> bis
	  <filename>da2</filename>) davon ausschließen, in die
	  Gruppe <systemitem class="groupname">operator</systemitem>
	  aufgenommen zu werden.</para>
      </note>

      <para>Aktivieren Sie nun die &man.devfs.rules.5;-Regeln
	in <filename>/etc/rc.conf</filename>:</para>

      <programlisting>devfs_system_ruleset="localrules"</programlisting>

      <para>Als nächstes müssen Sie Ihren Kernel anweisen, auch
	normalen Benutzern das mounten von Dateisystemen zu erlauben.
	Am einfachsten geht dies, indem die folgende Zeile in
	<filename>/etc/sysctl.conf</filename> hinzugefügt wird:</para>

      <programlisting>vfs.usermount=1</programlisting>

      <para>Da diese Einstellung erst nach einem Neustart wirksam
	wird, können Sie diese Variable mit &man.sysctl.8; auch direkt
	setzen.</para>

      <para>Zuletzt müssen Sie noch ein Verzeichnis anlegen, in
	das das <acronym>USB</acronym>-Laufwerk eingehängt werden
	soll. Dieses Verzeichnis muss dem Benutzer gehören, der das
	<acronym>USB</acronym>-Laufwerk in den Verzeichnisbaum
	einhängen will.  Dazu legen Sie als <systemitem
	  class="username">root</systemitem> ein
	Unterverzeichnis
	<filename
	  class="directory">/mnt/<replaceable>username</replaceable></filename>
	an, wobei Sie <replaceable>username</replaceable>
	durch den Login des jeweiligen Benutzers sowie
	<replaceable>usergroup</replaceable> durch die primäre
	Gruppe des Benutzers ersetzen:</para>

      <screen>&prompt.root; <userinput>mkdir /mnt/<replaceable>username</replaceable></userinput>
&prompt.root; <userinput>chown <replaceable>username</replaceable>:<replaceable>usergroup</replaceable> /mnt/<replaceable>username</replaceable></userinput></screen>

      <para>Wenn Sie nun beispielsweise einen
	<acronym>USB</acronym>-Stick
	anschließen, wird automatisch die Gerätedatei
	<filename>/dev/da0s1</filename> erzeugt.  Ist das Gerät mit
	einem FAT-Dateisystem formatiert, können Sie es mit dem
	folgenden Befehl in den Verzeichnisbaum einhängen:</para>

      <screen>&prompt.user; <userinput>mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/<replaceable>username</replaceable></userinput></screen>

      <para>Bevor das Gerät entfernt werden kann,
	<emphasis>muss</emphasis> es abgehängt werden.  Nach
	Entfernen des Geräts zeigen sich in den Systemmeldungen
	Einträge, ähnlich der folgenden:</para>

      <screen>umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached</screen>
    </sect2>

    <sect2>
      <title>Weiteres zu USB</title>

      <para>Neben den Abschnitten
	<link linkend="disks-adding">Hinzufügen von Laufwerken</link>
	und <link linkend="mount-unmount">Anhängen und
	Abhängen von Dateisystemen</link> lesen Sie bitte
	die Hilfeseiten &man.umass.4;, &man.camcontrol.8; für
	&os;&nbsp;8.X oder &man.usbdevs.8; bei vorherigen Versionen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-cds">
    <info>
      <title>Erstellen und Verwenden
	von <acronym>CD</acronym>s</title>

      <authorgroup>
	<author>
	  <personname>
	    <firstname>Mike</firstname>
	    <surname>Meyer</surname>
	</personname>
	<contrib>Beigesteuert von </contrib></author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>CD-ROM</acronym>s</primary>
      <secondary>brennen</secondary>
    </indexterm>

      <para><acronym>CD</acronym>s besitzen einige Eigenschaften, die sie von
	konventionellen Laufwerken unterscheiden.  Zuerst konnten
	sie nicht beschrieben werden.  Sie wurden so entworfen, dass
	sie ununterbrochen, ohne Verzögerungen durch Kopfbewegungen
	zwischen den Spuren, gelesen werden können.  Sie können auch
	leichter zwischen Systemen bewegt werden.</para>

      <para><acronym>CD</acronym>s besitzen Spuren, aber damit ist der Teil Daten
	gemeint, der ununterbrochen gelesen wird, und nicht eine
	physikalische Eigenschaft der <acronym>CD</acronym>.  Um
	beispielsweise eine <acronym>CD</acronym> mit &os; zu
	erstellen,  werden die Daten jeder Spur der
	<acronym>CD</acronym> in Dateien vorbereitet und dann die
	Spuren auf die <acronym>CD</acronym> geschrieben.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>

      <para>Das ISO 9660-Dateisystem wurde entworfen, um mit diesen
	Unterschieden umzugehen.  Um die ursprünglichen
	Dateisystemgrenzen zu überwinden existiert ein
	Erweiterungsmechanismus, der es korrekt geschriebenen
	<acronym>CD</acronym>s erlaubt, diese Grenzen zu überschreiten
	und dennoch auf Systemen zu funktionieren, die diese
	Erweiterungen nicht unterstützen.</para>

      <indexterm>
	<primary><package>sysutils/cdrtools</package></primary>
      </indexterm>

      <para>Der Port <package>sysutils/cdrtools</package>
	enthält das Programm &man.mkisofs.8;, das eine Datei
	erstellt, die ein ISO 9660-Dateisystem enthält.
	Das Programm hat Optionen, um verschiedene Erweiterungen
	zu unterstützen, und wird unten beschrieben.</para>

      <indexterm>
	<primary><acronym>CD</acronym>-Brenner</primary>
	<secondary><acronym>ATAPI</acronym></secondary>
      </indexterm>

      <para>Welches Werkzeug zum Brennen von <acronym>CD</acronym>s
	benutzt wird, hängt davon ab, ob der
	<acronym>CD</acronym>-Brenner ein
	<acronym>ATAPI</acronym>-Gerät ist oder nicht.  Mit
	<acronym>ATAPI</acronym>-<acronym>CD</acronym>-Brennern wird
	<command>burncd</command> benutzt, das Teil des Basissystems
	ist.  <acronym>SCSI</acronym>- und
	<acronym>USB</acronym>-<acronym>CD</acronym>-Brenner werden
	mit <command>cdrecord</command> aus dem Port
	<package>sysutils/cdrtools</package> benutzt.  Zusätzlich ist
	es möglich, über das Modul
	<link linkend="atapicam">ATAPI/CAM</link>
	<acronym>SCSI</acronym>-Werkzeuge wie
	<command>cdrecord</command> auch für
	<acronym>ATAPI</acronym>-Geräte einzusetzen.</para>

      <para>Für eine Brennsoftware mit grafischer
	Benutzeroberfläche benötigen, sollten Sie sich
	<application>X-CD-Roast</application> oder
	<application>K3b</application> näher ansehen.  Diese
	Werkzeuge können als Paket oder aus den
	Ports <package>sysutils/xcdroast</package>
	und <package>sysutils/k3b</package>
	installiert werden.  Mit <acronym>ATAPI</acronym>-Hardware
	benötigt <application>K3b</application> das
	<link linkend="atapicam">ATAPI/CAM-Modul</link>.</para>

    <sect2 xml:id="mkisofs">
      <title><application>mkisofs</application></title>

      <para>Der Port <package>sysutils/cdrtools</package> installiert
	auch &man.mkisofs.8;, welches ein ISO 9660-Abbild erstellt,
	das ein Abbild eines Verzeichnisbaumes ist.  Die einfachste
	Anwendung ist:</para>

      <screen>&prompt.root; <userinput>mkisofs -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/tree</replaceable></userinput></screen>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>
      <para>Dieses Kommando erstellt
	<replaceable>imagefile.iso</replaceable>, die ein ISO
	9660-Dateisystem enthält, das eine Kopie des Baumes unter
	<replaceable>/path/to/tree</replaceable> ist.  Dabei werden
	die Dateinamen auf Namen abgebildet, die den Restriktionen des
	ISO 9660-Dateisystems entsprechen.  Dateien mit Namen, die im
	ISO 9660-Dateisystem nicht gültig sind, bleiben
	unberücksichtigt.</para>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>HFS</secondary>
      </indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>Joliet</secondary>
      </indexterm>
      <para>Es einige Optionen, um diese Beschränkungen zu überwinden.
	Die unter &unix; Systemen üblichen Rock-Ridge-Erweiterungen
	werden durch <option>-R</option> aktiviert,
	<option>-J</option> aktiviert die von Microsoft Systemen
	benutzten Joliet-Erweiterungen und <option>-hfs</option> dient
	dazu, um das von &macos; benutzte HFS zu erstellen.</para>

      <para>Für <acronym>CD</acronym>s, die nur auf &os;-Systemen verwendet werden
	sollen, kann <option>-U</option> genutzt werden, um alle
	Beschränkungen für Dateinamen aufzuheben.  Zusammen mit
	<option>-R</option> wird ein Abbild des Dateisystems,
	identisch zu angegebenen &os;-Dateibaum, erstellt, obwohl dies
	den ISO 9660 Standard verletzen kann.</para>

      <indexterm>
	<primary><acronym>CD-ROM</acronym></primary>
	<secondary>bootbare erstellen</secondary>
      </indexterm>
      <para>Die letzte übliche Option ist <option>-b</option>.
	Sie wird benutzt, um den Ort eines Bootimages einer
	<quote>El Torito</quote> bootbaren <acronym>CD</acronym> anzugeben.  Das Argument
	zu dieser Option ist der Pfad zu einem Bootimage ausgehend
	von der Wurzel des Baumes, der auf die <acronym>CD</acronym> geschrieben werden
	soll.  In der Voreinstellung erzeugt &man.mkisofs.8; ein
	ISO-Image im <quote>Diskettenemulations</quote>-Modus.  Dabei
	muss das Image genau 1200, 1440 oder 2880&nbsp;KB groß
	sein.  Einige Bootloader, darunter der auf den &os;-Disks
	verwendete, kennen keinen Emulationsmodus.  Daher sollten Sie
	in diesen Fällen <option>-no-emul-boot</option> verwenden.
	Wenn <filename>/tmp/myboot</filename> ein bootbares
	&os;-System enthält, dessen Bootimage sich in
	<filename>/tmp/myboot/boot/cdboot</filename> befindet, können
	Sie ein Abbild eines ISO 9660-Dateisystems in
	<filename>/tmp/bootable.iso</filename> erstellen:</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>Wenn <filename>md</filename> im Kernel konfiguriert ist,
	kann das Dateisystem als speicherbasiertes Laufwerk
	eingehängt werden:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>Jetzt können Sie überprüfen, dass
	<filename>/mnt</filename> und <filename>/tmp/myboot</filename>
	identisch sind.</para>

      <para>Sie können das Verhalten von &man.mkisofs.8;
	mit einer Vielzahl von Optionen beeinflussen.  Details dazu
	entnehmen Sie bitte &man.mkisofs.8;.</para>
    </sect2>

    <sect2 xml:id="burncd">
      <title><application>burncd</application></title>

      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>brennen</secondary>
      </indexterm>
      <para>Für <acronym>ATAPI</acronym>-<acronym>CD</acronym>-Brenner
	kann <command>burncd</command> benutzt werden, um ein
	ISO-Image auf <acronym>CD</acronym> zu brennen.
	<command>burncd</command> ist Teil des Basissystems und unter
	<filename>/usr/sbin/burncd</filename> installiert.  Da es
	nicht viele Optionen hat, ist es leicht zu benutzen:</para>

      <screen>&prompt.root; <userinput>burncd -f <replaceable>cddevice</replaceable> data <replaceable>imagefile.iso</replaceable> fixate</userinput></screen>

      <para>Dieses Kommando brennt eine Kopie von
	<replaceable>imagefile.iso</replaceable> auf das Gerät
	<replaceable>cddevice</replaceable>.  In der Grundeinstellung
	wird das Gerät <filename>/dev/acd0</filename> benutzt.
	&man.burncd.8; beschreibt, wie die Schreibgeschwindigkeit
	gesetzt wird, die <acronym>CD</acronym> ausgeworfen wird und
	Audiodaten geschrieben werden.</para>
    </sect2>

    <sect2 xml:id="cdrecord">
      <title><application>cdrecord</application></title>

      <para>Für Systeme ohne
	<acronym>ATAPI</acronym>-<acronym>CD</acronym>-Brenner kann
	<command>cdrecord</command> benutzt werden, um
	<acronym>CD</acronym>s zu brennen.  <command>cdrecord</command>
	ist nicht Bestandteil des Basissystems und muss entweder als Paket
	<package>sysutils/cdrtools</package> oder Port installiert
	werden.  Änderungen im Basissystem können Fehler im binären
	Programm verursachen und führen möglicherweise dazu, dass Sie
	einen <quote>Untersetzer</quote> brennen.  Es wird daher
	empfohlen den Port aktualisieren, wenn das System
	aktualisiert wird, oder für Benutzer die
	<link linkend="stable">STABLE verfolgen</link>,
	den Port zu aktualisieren, wenn es eine neue Version
	gibt.</para>

      <para>Obwohl <command>cdrecord</command> viele Optionen besitzt,
	ist die grundlegende Anwendung einfach.  Ein ISO 9660-Image
	wird wie folgt erstellt:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=<replaceable>device</replaceable> <replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>Der Knackpunkt in der Benutzung von
	<command>cdrecord</command> besteht darin, das richtige
	Argument zu <option>dev</option> zu finden.  Benutzen Sie
	<option>-scanbus</option>, der eine ähnliche Ausgabe
	wie die folgende produziert:</para>

      <indexterm>
	<primary><acronym>CD-ROM</acronym></primary>
	<secondary>brennen</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord 1.9 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 Jörg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>Für die aufgeführten Geräte in der Liste
	wird das passende Argument zu <option>dev</option> gegeben.
	Benutzen Sie die drei durch Kommas separierten Zahlen, die zum
	<acronym>CD</acronym>-Brenner angegeben sind, als Argument für
	<option>dev</option>.  Im Beispiel ist das CDRW-Gerät
	1,5,0, so dass die passende Eingabe
	<userinput>dev=1,5,0</userinput> ist.  Einfachere Wege das
	Argument anzugeben, sowie Informationen über Audiospuren und
	das Einstellen der Geschwindigkeit, sind in &man.cdrecord.1;
	beschrieben.</para>
    </sect2>

    <sect2 xml:id="duplicating-audiocds">
      <title>Kopieren von Audio-<acronym>CD</acronym>s</title>

      <para>Um eine Kopie einer Audio-<acronym>CD</acronym> zu
	erstellen, kopieren Sie die Stücke der <acronym>CD</acronym>
	in einzelne Dateien und brennen diese Dateien dann auf eine
	leere <acronym>CD</acronym>.  Das genaue Verfahren hängt
	davon ab, ob Sie <acronym>ATAPI</acronym>- oder
	<acronym>SCSI</acronym>-Laufwerke verwenden.</para>

      <procedure>
	<title><acronym>SCSI</acronym>-Laufwerke</title>

	<step>
	  <para>Kopieren Sie die Audiodaten mit
	    <command>cdda2wav</command>:</para>

	  <screen>&prompt.user; <userinput>cdda2wav -vall -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>Die erzeugten <filename>.wav</filename> Dateien
	    schreiben Sie mit <command>cdrecord</command> auf eine
	    leere <acronym>CD</acronym>:</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=<replaceable>2,0</replaceable> -dao -useinfo  *.wav</userinput></screen>

	  <para>Das Argument von <option>dev</option> gibt das
	    verwendete Gerät an, das wie in <xref linkend="cdrecord"/>
	    ermittelt werden kann.</para>
	</step>
      </procedure>

      <procedure>
	<title><acronym>ATAPI</acronym>-Laufwerke</title>

	<note>
	  <para>Über das Modul
	    <link linkend="atapicam">ATAPI/CAM</link> kann
	    <command>cdda2wav</command> auch mit
	    <acronym>ATAPI</acronym>-Laufwerken
	    verwendet werden.  Diese Methode ist für die meisten
	    Anwender besser geeignet als die im folgenden
	    beschriebenen Methoden (Jitter-Korrektur,
	    Big-/Little-Endian-Probleme und anderes mehr spielen
	    hierbei eine Rolle).</para>
        </note>

	<step>
	  <para>Der
	    <acronym>ATAPI</acronym>-<acronym>CD</acronym>-Treiber
	    stellt die einzelnen Stücke der <acronym>CD</acronym>
	    über die Dateien
	    <filename>/dev/acd<replaceable>d</replaceable>t<replaceable>nn</replaceable></filename>,
	    zur Verfügung.  <replaceable>d</replaceable> bezeichnet
	    die Laufwerksnummer und <replaceable>nn</replaceable> ist
	    die Nummer des Stücks.  Die Nummer ist immer zweistellig,
	    das heißt es wird, wenn nötig, eine führende Null
	    ausgegeben.  Die Datei <filename>/dev/acd0t01</filename>
	    ist also das erste Stück des ersten
	    <acronym>CD</acronym>-Laufwerks.
	    <filename>/dev/acd0t02</filename> ist das zweite Stück
	    und <filename>/dev/acd0t03</filename> das dritte.</para>

	  <para>Überprüfen Sie stets, ob die entsprechenden
	    Dateien im Verzeichnis <filename>/dev</filename> auch
	    angelegt werden.  Sind die Einträge nicht vorhanden,
	    weisen Sie Ihr System an, das Medium erneut zu testen:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=/dev/null count=1</userinput></screen>

	  <note>
	    <para>Unter &os;&nbsp;4.X werden diese Einträge nicht
	      mit dem Wert Null vordefiniert.  Falls die entsprechenden
	      Einträge unter <filename>/dev</filename> nicht
	      vorhanden sind, müssen Sie diese hier von
	      <command>MAKEDEV</command> anlegen lassen:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV acd0t99</userinput></screen>

	  </note>
	</step>

	<step>
	  <para>Die einzelnen Stücke werden mit &man.dd.1; kopiert.
	    Achten Sie darauf, eine Blockgröße anzugeben:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=track2.cdr bs=2352</userinput>
...</screen>
	</step>

	<step>
	  <para>Die kopierten Dateien können Sie dann mit
	    <command>burncd</command> brennen.  Geben Sie an, dass es
	    sich um Audio-Daten handelt und dass <command>burncd</command>
	    das Medium am Ende fixieren soll:</para>

	  <screen>&prompt.root; <userinput>burncd -f <replaceable>/dev/acd0</replaceable> audio track1.cdr track2.cdr <replaceable>...</replaceable> fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="imaging-cd">
      <title>Kopieren von Daten-<acronym>CD</acronym>s</title>

      <para>Es ist möglich eine Daten-<acronym>CD</acronym> in eine
	Datei zu kopieren, die einem Image entspricht, das mit
	&man.mkisofs.8; erstellt wurde.  Mit Hilfe dieses Images
	können Sie jede Daten-<acronym>CD</acronym> kopieren.  Das
	folgende Beispiel verwendet <filename>acd0</filename> für das
	<acronym>CD-ROM</acronym>-Gerät.  Wird ein anderes Laufwerk
	benutzt, muss der Name entsprechend ersetzt werden.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=file.iso bs=2048</userinput></screen>

      <para>Danach existiert ein Image, das wie oben beschrieben, auf
	<acronym>CD</acronym> gebrannt werden kann.</para>
    </sect2>

    <sect2 xml:id="mounting-cd">
      <title>Einhängen von Daten-<acronym>CD</acronym>s</title>

      <para>Es ist möglich, eine Daten-<acronym>CD</acronym> zu
	mounten und die Daten zu lesen.  Standardmäßig erwartet
	&man.mount.8; ein Dateisystem vom Typ <literal>ufs</literal>.
	Wenn Sie das folgende Kommando ausführen:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0 /mnt</userinput></screen>

      <para>erhalten Sie die Fehlermeldung
	<errorname>Incorrect super block</errorname>, und die
	<acronym>CD</acronym> konnte nicht eingehängt werden.  Die
	<acronym>CD</acronym> benutzt nicht das
	<literal>UFS</literal>-Dateisystem, deshalb schlägt der
	Versuch fehl, sie als solches einzuhängen.  Sie müssen
	&man.mount.8; durch die Angabe von <option>-t cd9660</option>
	sagen, dass es sich um ein Dateisystem vom Typ
	<literal>ISO9660</literal> handelt.  Wenn Sie also die
	<acronym>CD-ROM</acronym> <filename>/dev/cd0</filename> in
	<filename>/mnt</filename> einhängen wollen, führen Sie
	folgenden Befehl aus:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 <replaceable>/dev/cd0</replaceable> /mnt</userinput></screen>

      <para>Ersetzen Sie <filename>/dev/cd0</filename> durch den
	Gerätenamen des <acronym>CD</acronym>-Gerätes.  Die Angabe von
	<option>-t cd9660</option> führt &man.mount.cd9660.8; aus,
	was äquivalent zu folgendem Befehl ist:</para>

      <screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Auf diese Weise können Sie Daten-<acronym>CD</acronym>s
	von jedem Hersteller verwenden.  Es kann allerdings zu
	Problemen mit <acronym>CD</acronym>s kommen, die verschiedene
	ISO9660-Erweiterungen benutzen.  So speichern
	Joliet-<acronym>CD</acronym>s alle Dateinamen unter
	Verwendung von zwei Byte langen Unicode-Zeichen.  Zwar
	unterstützt der &os;-Kernel derzeit noch kein Unicode, der
	CD9660-Treiber erlaubt es aber, zur Laufzeit eine
	Konvertierungstabelle zu laden.  Tauchen
	also statt bestimmter Zeichen nur Fragezeichen auf, so
	müssen Sie über die Option <option>-C</option> den
	benötigten Zeichensatz angeben.  Weitere Informationen zu
	diesem Problem finden Sie in der Manualpage
	&man.mount.cd9660.8;.</para>

      <note>
	<para>Damit der Kernel diese Zeichenkonvertierung (festgelegt
	  durch die Option <option>-C</option>) erkennt, müssen Sie
	  das Kernelmodul <filename>cd9660_iconv.ko</filename> laden.
	  Dazu fügen Sie folgende Zeile in
	  <filename>loader.conf</filename> ein:</para>

	<programlisting>cd9660_iconv_load="YES"</programlisting>

	<para>Danach müssen Sie allerdings Ihr System neu starten.
	  Alternativ können Sie das Kernelmodul auch direkt
	  über &man.kldload.8; laden.</para>
      </note>

      <para>Manchmal werden Sie die Meldung
	<errorname>Device not configured</errorname> erhalten, wenn
	Sie versuchen,  eine <acronym>CD-ROM</acronym> einzuhängen.
	Für gewöhnlich liegt das daran, dass das Laufwerk meint es sei
	keine <acronym>CD</acronym> eingelegt, oder dass das Laufwerk
	auf dem Bus nicht erkannt wird.  Es kann einige Sekunden
	dauern, bevor das Laufwerk merkt, dass eine
	<acronym>CD</acronym> eingelegt wurde.  Seien Sie also
	geduldig.</para>

      <para>Manchmal wird ein
	<acronym>SCSI</acronym>-<acronym>CD-ROM</acronym> nicht
	erkannt, weil es keine Zeit hatte, auf das Zurücksetzen des
	Busses zu antworten. Wenn Sie ein
	<acronym>SCSI</acronym>-<acronym>CD-ROM</acronym> besitzen,
	sollten Sie die folgende Zeile in die Kernelkonfiguration
	aufnehmen und einen neuen <link
	  linkend="kernelconfig-building">Kernel bauen</link>:</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Die Zeile bewirkt, dass nach dem Zurücksetzen des
	<acronym>SCSI</acronym>-Busses beim Booten 15 Sekunden
	gewartet wird, um dem
	<acronym>CD-ROM</acronym>-Laufwerk genügend Zeit zu geben,
	darauf zu antworten.</para>
    </sect2>

    <sect2 xml:id="rawdata-cd">
      <title>Brennen von rohen CDs</title>

      <para>Es ist möglich eine Datei auch direkt auf eine
	<acronym>CD</acronym> zu brennen, ohne vorher auf ihr ein ISO
	9660-Dateisystem einzurichten.  Einige Leute nutzen dies, um
	Datensicherungen durchzuführen.  Diese Vorgehensweise hat den
	Vorteil, dass sie schneller als das Brennen einer normalen
	<acronym>CD</acronym> ist.</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>Um die Daten einer solchen <acronym>CD</acronym>
	abzurufen, müssen die Daten direkt von dem rohen Gerät gelesen
	werden:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1</userinput></screen>

      <para>Eine auf diese Weise gefertigte <acronym>CD</acronym> kann
	nicht in das Dateisystem eingehangen werden.  Sie kann auch
	nicht auf einem anderen Betriebssystem gelesen werden.  Wenn
	Sie die erstellten <acronym>CD</acronym>s in das Dateisystem
	einhängen oder mit anderen Betriebssystemen austauschen
	wollen, müssen Sie &man.mkisofs.8; wie oben beschrieben
	benutzen.</para>
    </sect2>

    <sect2 xml:id="atapicam">
      <info>
	<title>Der ATAPI/CAM Treiber</title>
	
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      <indexterm>
	<primary><acronym>CD</acronym>-Brenner</primary>
	<secondary>ATAPI/CAM Treiber</secondary>
      </indexterm>

      <para>Mit diesem Treiber kann auf
	<acronym>ATAPI</acronym>-Geräte,
	wie <acronym>CD-ROM</acronym>-, <acronym>CD-RW</acronym>- oder
	<acronym>DVD</acronym>-Laufwerke, mithilfe des
	<acronym>SCSI</acronym>-Subsystems zugegriffen werden.  Damit
	können Sie <acronym>SCSI</acronym>-Werkzeuge, wie
	<package>sysutils/cdrdao</package> oder &man.cdrecord.1;,
	zusammen mit einem ATAPI-Gerät benutzen.</para>

      <para>Um den Treiber zu benutzen, fügen Sie die folgende Zeile
	in <filename>/boot/loader.conf</filename> ein:</para>

      <programlisting>atapicam_load="YES"</programlisting>

      <para>Um den Treiber zu aktivieren, muss das System neu
	gestartet werden.</para>

      <note>
	<para>Benutzer, die es vorziehen
	  &man.atapicam.4;-Unterstützung statisch in den Kernel
	  zu komplillieren, sollten diese Zeile in die
	  Kernelkonfigurationsdatei hinzufügen:</para>

        <programlisting>device atapicam</programlisting>

        <para>Die folgenden Zeilen werden ebenfalls benötigt,
	  sollten aber schon Teil der Kernelkonfiguration sein:</para>

        <programlisting>device ata
device scbus
device cd
device pass</programlisting>

      <para>Übersetzen und installieren Sie den neuen
	Kernel.  Starten Sie anschließend das System neu.</para>
      </note>

      <para>Während des Bootvorgangs sollte der
	<acronym>CD</acronym>-Brenner ungefähr so angezeigt
	werden:</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>Über den Gerätenamen <filename>/dev/cd0</filename>
	kann nun auf das Laufwerk zugegriffen werden.  Um
	beispielsweise eine <acronym>CD-ROM</acronym> in
	<filename>/mnt</filename> einzuhängen, geben Sie folgendes
	ein:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 <replaceable>/dev/cd0</replaceable> /mnt</userinput></screen>

      <para>Die <acronym>SCSI</acronym>-Adresse des Brenners können
	Sie als <systemitem class="username">root</systemitem> wie
	folgt ermitteln:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>Die <acronym>SCSI</acronym>-Adresse
	<literal>1,0,0</literal> können Sie mit den
	<acronym>SCSI</acronym>-Werkzeugen, zum Beispiel
	&man.cdrecord.1;, verwenden.</para>

      <para>Weitere Informationen über das ATAPI/CAM- und
	das <acronym>SCSI</acronym>-System finden Sie in
	&man.atapicam.4; und &man.cam.4;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-dvds">
    <info>
      <title><acronym>DVD</acronym>s benutzen</title>

      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Andy</firstname><surname>Polyakov</surname></personname><contrib>Mit Beiträgen von </contrib></author>
      </authorgroup>
    </info>

    <indexterm>
      <primary><acronym>DVD</acronym></primary>
      <secondary>brennen</secondary>
    </indexterm>

      <para>Nach der <acronym>CD</acronym> ist die
	<acronym>DVD</acronym> die nächste Generation optischer
	Speichermedien.  Auf einer <acronym>DVD</acronym> können
	mehr Daten als auf einer <acronym>CD</acronym> gespeichert
	werden.  <acronym>DVD</acronym>s werden als Standardmedium für
	Videos verwendet.</para>

      <para>Für beschreibbare <acronym>DVD</acronym>s existieren fünf
	Medienformate:</para>

      <itemizedlist>
	<listitem>
	  <para>DVD-R:  Dies war das erste verfügbare Format.
	    Das Format wurde vom <link xlink:href="http://www.dvdforum.com/forum.shtml">DVD-Forum</link>
	    festgelegt.  Die Medien sind nur einmal beschreibbar.</para>
	</listitem>

	<listitem>
	  <para><acronym>DVD-RW</acronym>:  Dies ist die 
	    wiederbeschreibbare Version des DVD-R Standards.  Eine
	    <acronym>DVD-RW</acronym> kann ungefähr
	    1000&nbsp;Mal beschrieben werden.</para>
	</listitem>

	<listitem>
	  <para><acronym>DVD-RAM</acronym>:  Dies ist ein
	    wiederbeschreibbares Format, das wie ein Wechsellaufwerk
	    betrachtet werden kann.  Allerdings sind die Medien nicht
	    kompatibel zu den meisten
	    <acronym>DVD-ROM</acronym>-Laufwerken und
	    DVD-Video-Spielern, da das
	    <acronym>DVD-RAM-Format</acronym> nur von wenigen Brennern
	    unterstützt wird.  Informationen zur Nutzung von
	    <acronym>DVD-RAM</acronym> finden Sie in
	    <xref linkend="creating-dvd-ram"/>.</para>
	</listitem>

	<listitem>
	  <para><acronym>DVD+RW</acronym>:  Ist ein
	    wiederbeschreibbares Format, das von der <link
	      xlink:href="http://www.dvdrw.com/"><acronym>DVD+RW</acronym>
	      Alliance</link> festgelegt wurde.  Eine
	    <acronym>DVD+RW</acronym> kann ungefähr 1000&nbsp;Mal
	    beschrieben werden.</para>
	</listitem>

	<listitem>
	  <para>DVD+R:  Dieses Format ist die nur einmal beschreibbare
	    Variante des <acronym>DVD+RW</acronym> Formats.</para>
	</listitem>
      </itemizedlist>

      <para>Auf einer einfach beschichteten <acronym>DVD</acronym>
	können 4.700.000.000&nbsp;Bytes gespeichert werden.  Das
	sind 4,38&nbsp;GB oder 4485&nbsp;MB (1&nbsp;Kilobyte
	sind 1024&nbsp;Bytes).</para>

      <note>
	<para>Die physischen Medien sind unabhängig von
	  der Anwendung.  Ein DVD-Video ist eine spezielle
	  Anordnung von Dateien, die auf irgendein Medium,
	  beispielsweise DVD-R, DVD+R oder <acronym>DVD-RW</acronym>
	  geschrieben werden kann.  Bevor Sie ein Medium auswählen,
	  müssen Sie sicherstellen, dass der Brenner und der
	  DVD-Spieler mit dem Medium umgehen können.</para>
      </note>

    <sect2>
      <title>Konfiguration</title>

      <para>Benutzen Sie &man.growisofs.1;, um <acronym>DVD</acronym>s
	zu beschreiben.  Das Kommando ist Bestandteil von
	<package>sysutils/dvd+rw-tools</package>, und kann mit allen
	<acronym>DVD</acronym>-Medien umgehen.</para>

      <para>Diese Werkzeuge verwenden das
	<acronym>SCSI</acronym>-Subsystem, um auf die Geräte
	zuzugreifen.  Daher muss <link
	  linkend="atapicam">ATAPI/CAM-Unterstützung</link>
	geladen, oder statisch in den Kernel kompiliert werden.
	Sollte der Brenner jedoch die
	<acronym>USB</acronym>-Schnittstelle nutzen, wird diese
	Unterstützung nicht benötigt.  Weitere Informationen zur
	Konfiguration von <acronym>USB</acronym>-Geräten finden Sie in
	<xref linkend="usb-disks"/>.</para>

      <para>Für <acronym>ATAPI</acronym>-Geräte müssen ebenfalls
	DMA-Zugriffe aktiviert werden.  Dazu wird die folgende Zeile
	in <filename>/boot/loader.conf</filename> eingefügt:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>Bevor Sie <application>dvd+rw-tools</application>
	benutzen, lesen Sie bitte die
	Hardware-Informationen auf der Seite <link
	  xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">Hardware
	  Compatibility Notes</link>.</para>

      <note>
	<para>Für eine grafische Oberfläche sollten Sie sich
	  <package>sysutils/k3b</package> ansehen, das eine
	  benutzerfreundliche Schnittstelle zu &man.growisofs.1; und
	  vielen anderen Werkzeugen bietet.</para>
      </note>
    </sect2>

    <sect2>
      <title>Daten-<acronym>DVD</acronym>s brennen</title>

      <para>&man.growisofs.1; erstellt mit dem Programm
	<link linkend="mkisofs">mkisofs</link> das Dateisystem
	und brennt anschließend die <acronym>DVD</acronym>.  Vor dem
	Brennen braucht daher kein Abbild der Daten erstellt zu
	werden.</para>

      <para>Wenn Sie von den Daten im Verzeichnis
	<filename>/path/to/data</filename> eine
	DVD+R oder eine DVD-R brennen wollen, benutzen Sie
	das nachstehende Kommando:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>In diesem Beispiel wird <option>-J -R</option> an
	&man.mkisofs.8; durchgereicht und dient zum Erstellen
	des Dateisystems (hier:  ein ISO-9660-Dateisystem mit
	Joliet- und Rock-Ridge-Erweiterungen).  Weiteres
	entnehmen Sie bitte der Hilfeseite &man.mkisofs.8;.</para>

      <para>Die Option <option>-Z</option> wird für die erste
	Aufnahme einer Single- oder Multisession benötigt.  Ersetzen
	Sie <replaceable>/dev/cd0</replaceable> mit dem Gerätenamen
	des <acronym>DVD</acronym>-Gerätes.  Die Nutzung von
	<option>-dvd-compat</option> schließt das Medium, weitere
	Daten können danach nicht mehr angehängt werden.  Dies sollte
	auch eine eine bessere Kompatibilität mit anderen
	<acronym>DVD-ROM</acronym>-Laufwerken bieten.</para>

      <para>Um ein vorher erstelltes Abbild der Daten zu brennen,
	beispielsweise <replaceable>imagefile.iso</replaceable>,
	verwenden Sie:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>Die Schreibgeschwindigkeit hängt von den
	verwendeten Medium sowie dem verwendeten Gerät ab
	und sollte automatisch gesetzt werden.  Um die
	Schreibgeschwindigkeit vorzugeben, verwenden Sie
	<option>-speed=</option>.  Beispiele finden Sie in
	&man.growisofs.1;.</para>

      <note>
        <para>Um größere Dateien als 4.38GB zu unterstützen, ist es
	  notwendig ein UDF/ISO-9660 Hybrid-Dateisystem zu erstellen.
	  Dieses Dateisystem muss mit zusätzlichen Parametern
	  <option>-udf -iso-level 3</option> bei &man.mkisofs.8; und
	  allen relevanten Programmen, wie beispielsweise
	  &man.growisofs.1;) erzeugt werden.  Dies ist nur notwendig,
	  wenn Sie ein ISO-Image erstellen oder direkt auf eine DVD
	  schreiben wollen.  DVDs, die in dieser Weise hergestellt
	  worden sind, müssen als UDF-Dateisystem mit
	  &man.mount.udf.8; eingehangen werden. Sie sind nur auf
	  Betriebssystemen, die UDF unterstützen brauchbar, ansonsten
	  sieht es so aus, als ob sie kaputte Dateien enthalten
	  würden.</para>

	<para>Um diese Art von ISO-Datei zu erstellen:</para>

	<screen>&prompt.user; <userinput>mkisofs -R -J -udf -iso-level 3 -o <replaceable>imagefile.iso</replaceable> <replaceable>/path/to/data</replaceable>
</userinput></screen>

 	<para>Um Daten direkt auf eine DVD zu brennen, geben Sie den
 	  folgenden Befehl ein:</para>

	<screen>&prompt.root; <userinput>growisofs -dvd-compat -udf -iso-level 3 -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable>
</userinput></screen>

	<para>Wenn ein ISO-Abbild bereits große Dateien enthält, sind
	  keine weiteren Optionen für &man.growisofs.1; notwendig, um
	  das Abbild auf die DVD zu brennen.</para>

	<para>Achten Sie darauf, eine aktuelle Version von
	  <package>sysutils/cdrtools</package> zu verwenden, welche
	  &man.mkisofs.8; enthält, da ältere Versionen keinen Support
	  für große Dateien enthalten.  Falls die neueste Version
	  nicht funktioniert, installieren Sie
	  <package>sysutils/cdrtools-devel</package> und lesen Sie
	  &man.mkisofs.8;.</para>
      </note>
    </sect2>

    <sect2>
      <title><acronym>DVD</acronym>-Videos brennen</title>

      <indexterm>
	<primary><acronym>DVD</acronym></primary>
	<secondary>DVD-Video</secondary>
      </indexterm>

      <para>Ein DVD-Video ist eine spezielle Anordnung von Dateien,
	die auf den ISO-9660 und den micro-UDF (M-UDF) Spezifikationen
	beruht.  Da DVD-Video auf eine bestimmte Datei-Hierarchie
	angewiesen ist, müssen <acronym>DVD</acronym>s mit speziellen
	Programmen wie <package>multimedia/dvdauthor</package>
	erstellt werden.</para>

      <para>Ist bereits ein Abbild des Dateisystems eines
	DVD-Videos vorhanden, kann es auf die gleiche Weise wie jedes
	andere Abbild gebrannt werden.  Wenn
	<command>dvdauthor</command> verwendet wurde, um die
	<acronym>DVD</acronym> zu erstellen und die Resultate in
	<filename>/path/to/video</filename> liegen, kann das folgende
	Kommando verwendet werden, um ein DVD-Video zu brennen:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -dvd-video <replaceable>/path/to/video</replaceable></userinput></screen>

      <para><option>-dvd-video</option> wird an &man.mkisofs.8;
	weitergereicht, um die Datei-Hierarchie für ein DVD-Video zu
	erstellen.  Weiterhin bewirkt diese Option, dass
	&man.growisofs.1; mit <option>-dvd-compat</option> aufgerufen
	wird.</para>
    </sect2>

    <sect2>
      <title><acronym>DVD+RW</acronym>-Medien benutzen</title>

      <indexterm>
	<primary><acronym>DVD</acronym></primary>
	<secondary><acronym>DVD+RW</acronym></secondary>
      </indexterm>

      <para>Im Gegensatz zu CD-RW-Medien müssen
	<acronym>DVD+RW</acronym>-Medien
	erst formatiert werden, bevor sie benutzt werden können.
	Es wird <emphasis>empfohlen</emphasis> &man.growisofs.1;
	einzusetzen, da das Programm Medien automatisch formatiert,
	wenn es erforderlich ist.  Es ist jedoch möglich, auch
	<command>dvd+rw-format</command> zu nutzen, um die
	<acronym>DVD+RW</acronym> zu formatieren:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev/cd0</replaceable></userinput></screen>

      <para>Dieser Vorgang muss nur einmal durchgeführt werden. Denken
	Sie daran, dass nur neue DVD+RWs formatiert werden müssen.
	Anschließend können <acronym>DVD+RW</acronym>s, wie gewohnt
	gebrannt werden.</para>

      <para>Wenn Sie auf einer <acronym>DVD+RW</acronym> ein neues
	Dateisystem erstellen wollen, brauchen Sie die
	<acronym>DVD+RW</acronym> vorher nicht zu
	löschen.  Überschreiben Sie einfach das vorige Dateisystem
	indem Sie eine neue Session anlegen:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/newdata</replaceable></userinput></screen>

      <para>Das <acronym>DVD+RW</acronym>-Format erlaubt es, Daten an
	eine vorherige Aufnahme anzuhängen.  Dazu wird eine neue
	Session mit der schon bestehenden zusammengeführt.
	Es wird keine Multi-Session geschrieben, sondern
	&man.growisofs.1; <emphasis>vergrößert</emphasis>
	das ISO-9660-Dateisystem auf dem Medium.</para>

      <para>Das folgende Kommando fügt weitere Daten zu
	einer vorher erstellten <acronym>DVD+RW</acronym>
	hinzu:</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>Wenn Sie eine <acronym>DVD+RW</acronym> erweitern,
	verwenden Sie dieselben &man.mkisofs.8;-Optionen wie beim
	Erstellen der <acronym>DVD+RW</acronym>.</para>

      <note>
	<para>Verwenden Sie <option>-dvd-compat</option>, um bessere
	  Kompatibilität mit <acronym>DVD-ROM</acronym>-Laufwerken zu
	  gewährleisten.  Zu einem <acronym>DVD+RW</acronym>-Medium
	  können Sie mit dieser Option auch weiterhin Daten
	  hinzufügen.</para>
      </note>

      <para>Um das Medium zu löschen, verwenden Sie:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable>=<replaceable>/dev/zero</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title><acronym>DVD-RW</acronym>-Medien benutzen</title>

      <indexterm>
	<primary><acronym>DVD</acronym></primary>
	<secondary><acronym>DVD-RW</acronym></secondary>
      </indexterm>

      <para>Eine <acronym>DVD-RW</acronym> kann mit zwei Methoden
	beschrieben werden:
	<firstterm>Sequential-Recording</firstterm> oder
	<firstterm>Restricted-Overwrite</firstterm>.  Voreingestellt
	ist Sequential-Recording.</para>

      <para>Eine neue <acronym>DVD-RW</acronym> kann direkt
	beschrieben werden; sie muss nicht vorher formatiert werden.
	Allerdings muss eine <acronym>DVD-RW</acronym>, die mit
	Sequential-Recording aufgenommen wurde, zuerst gelöscht
	werden, bevor eine neue Session aufgenommen werden
	kann.</para>

      <para>Der folgende Befehl löscht eine <acronym>DVD-RW</acronym>
	im Sequential-Recording-Modus:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/cd0</replaceable></userinput></screen>

      <note>
	<para>Das vollständige Löschen mit
	  <option>-blank=full</option> dauert mit einem
	  1x&nbsp;Medium ungefähr eine Stunde.  Wenn die
	  <acronym>DVD-RW</acronym> im Disk-At-Once-Modus (DAO)
	  aufgenommen wurde, kann sie mit <option>-blank</option>
	  schneller gelöscht werden.  Um eine
	  <acronym>DVD-RW</acronym> im DAO-Modus zu brennen, benutzen
	  Sie das folgende Kommando:</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z <replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable>
</userinput></screen>

	<para>Die Option <option>-use-the-force-luke=dao</option>
	  sollte nicht erforderlich sein, da &man.growisofs.1;
	  den DAO-Modus automatisch erkennt.</para>

	<para>Der Restricted-Overwrite-Modus sollte mit jeder
	  <acronym>DVD-RW</acronym> verwendet werden, da er flexibler
	  als der voreingestellte Sequential-Recording-Modus
	  ist.</para>
      </note>

      <para>Um Daten auf eine <acronym>DVD-RW</acronym> im
	Sequential-Recording-Modus zu schreiben, benutzen Sie dasselbe
	Kommando wiefür die anderen
	<acronym>DVD</acronym>-Formate:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>Um weitere Daten zu einer Aufnahme hinzuzufügen, benutzen
	Sie <option>-M</option> mit &man.growisofs.1;.  Werden die
	Daten im Sequential-Recording-Modus hinzugefügt, wird eine
	neue Session erstellt.  Das Ergebnis ist ein
	Multi-Session-Medium.</para>

      <para>Eine <acronym>DVD-RW</acronym> im
	Restricted-Overwrite-Modus muss nicht gelöscht werden, um eine
	neue Session aufzunehmen.  Das Medium kann einfach mit
	<option>-Z</option> überschrieben werden.  Mit
	<option>-M</option> kann das ISO-9660-Dateisystem, wie mit
	einer <acronym>DVD+RW</acronym>, vergrößert werden.
	Die <acronym>DVD</acronym> enthält danach eine Session.</para>

      <para>Benutzen sie das nachstehende Kommando, um den
	Restricted-Overwrite-Modus einzustellen:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev/cd0</replaceable></userinput></screen>

      <para>Das folgende Kommando stellt den Modus wieder auf
	Sequential-Recording zurück:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/cd0</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>Multi-Session</title>

      <para>Nur wenige <acronym>DVD-ROM</acronym>-Laufwerke
	unterstützen Multi-Session-DVDs und lesen meist nur die erste
	Session.  Mehrere Sessions werden von DVD+R, DVD-R und
	<acronym>DVD-RW</acronym> im Sequential-Recording-Modus
	unterstützt.  Im Modus Restricted-Overwrite gibt nur eine
	Session.</para>

      <para>Wenn das Medium noch nicht geschlossen ist, erstellt
        das nachstehende Kommando eine neue Session auf einer
	DVD+R, DVD-R oder <acronym>DVD-RW</acronym> im
	Sequential-Recording-Modus:</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>Wird dieses Kommando mit <acronym>DVD+RW</acronym>- oder
	<acronym>DVD-RW</acronym>-Medien im Restricted-Overwrite-Modus
	benutzt, werden die neuen Daten mit
	den Daten der bestehenden Session zusammengeführt.  Das Medium
	enthält danach eine Session.  Nutzen Sie diese Methode, um
	neue Daten zu einer bestehenden Session hinzuzufügen.</para>

      <note>
	<para>Für den Anfang und das Ende einer Session wird auf dem
	  Medium zusätzlicher Platz verbraucht.  Um den Speicherplatz
	  auf dem Medium optimal auszunutzen, sollten Sie daher
	  Sessions mit vielen Daten hinzufügen.  Auf ein DVD+R-Medium
	  passen maximal 154&nbsp;Sessions, 2000&nbsp;Sessions auf ein
	  DVD-R-Medium und 127&nbsp;Sessions auf eine DVD+R Double
	  Layer.</para>
      </note>
    </sect2>

    <sect2>
      <title>Weiterführendes</title>

      <para><command>dvd+rw-mediainfo
	  <replaceable>/dev/cd0</replaceable></command> zeigt
	Informationen über eine im Laufwerk liegende
	<acronym>DVD</acronym> an.</para>

      <para>Weiteres zu <application>dvd+rw-tools</application>
	finden Sie in &man.growisofs.1;, auf der <link 
	  xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/">dvd+rw-tools
	  Web-Seite</link> und in den Archiven der <link
	  xlink:href="http://lists.debian.org/cdwrite/">cdwrite-Mailingliste</link>.</para>

      <note>
	<para>Wenn Sie einen Problembericht zur Nutzung der
	  <application>dvd+rw-tools</application> erstellen, fügen Sie
	  immer die Ausgabe von <command>dvd+rw-mediainfo</command>
	  hinzu.</para>
      </note>
    </sect2>

    <sect2 xml:id="creating-dvd-ram">
      <title><acronym>DVD-RAM</acronym></title>

      <indexterm>
	<primary><acronym>DVD</acronym></primary>
	<secondary><acronym>DVD-RAM</acronym></secondary>
      </indexterm>

	<para><acronym>DVD-RAM</acronym>-fähige Brenner nutzten die
	  <acronym>SCSI</acronym>- oder
	  <acronym>ATAPI</acronym>-Schnittstelle.  Für
	  <acronym>ATAPI</acronym>-Geräte muss der DMA-Modus
	  aktiviert werden, indem die folgende Zeile in
	  <filename>/boot/loader.conf</filename> hinzugefügt
	  wird:</para>

	 <programlisting>hw.ata.atapi_dma="1"</programlisting>

	<para>Eine <acronym>DVD-RAM</acronym> kann mit einer
	  Wechselplatte verglichen werden.  Wie diese, muss auch eine
	  <acronym>DVD-RAM</acronym> vor dem ersten
	  Einsatz formatiert werden.  In diesem Beispiel wird das
	  gesamte Medium mit dem Standard-UFS2-Dateisystem
	  formatiert:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/dev/acd0</replaceable> bs=2k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw <replaceable>acd0</replaceable></userinput>
&prompt.root; <userinput>newfs <replaceable>/dev/acd0</replaceable></userinput></screen>

	<para>Denken Sie dabei daran, dass Sie gegebenenfalls die
	  Gerätedatei (hier <filename>acd0</filename>) an
	  Ihre Konfiguration anpassen müssen.</para>

	<para>Nachdem die <acronym>DVD-RAM</acronym> formatiert ist,
	  kann sie wie eine normale Festplatte gemountet
	  werden:</para>

	<screen>&prompt.root; <userinput>mount <replaceable>/dev/acd0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>

	<para>Danach kann schreibend und lesend auf das
	  <acronym>DVD-RAM</acronym> Medium zugegriffen werden.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="floppies">
    <title>Disketten benutzen</title>
<!--
      <authorgroup>
	<author><personname><firstname>Julio</firstname><surname>Merino</surname></personname><contrib>Original von </contrib></author>
      </authorgroup>
      
      <authorgroup>
	<author><personname><firstname>Martin</firstname><surname>Karlsson</surname></personname><contrib>Umgeschrieben von </contrib></author>
      </authorgroup>
-->

    <para>Dieser Abschnitt beschreibt die Formatierung von
      3,5&nbsp;Zoll Disketten in &os;.</para>

    <procedure>
      <title>Disketten formatieren</title>

	<para>Bevor eine Diskette benutzt werden kann, muss sie
	  (low-level) formatiert werden, was normalerweise der
	  Hersteller schon gemacht hat.  Sie können die Diskette
	  allerdings noch einmal formatieren, um das Medium zu
	  überprüfen.  Benutzen Sie &man.fdformat.1;, um Disketten
	  unter &os; zu formatieren. Achten Sie dabei auf
	  Fehlermeldungen, die schlechte Speichermedien
	  anzeigen.</para>

	<step>
	  <para>Um eine Diskette zu formatieren, legen Sie eine
	    3,5&nbsp;Zoll Diskette in das erste Diskettenlaufwerk ein
	    und führen das folgende Kommando aus:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>
	</step>

	<step>
	  <para>Nach dem Formatieren muss auf der Diskette ein
	    Disklabel erstellt werden, um die Größe und Geometrie der
	    Diskette zu erkennen.  Eine Liste der unterstützten
	    Geometrien finden Sie in
	    <filename>/etc/disktab</filename>.</para>

	  <para>Erstellen Sie nun das Label mit &man.bsdlabel.8;:</para>

	  <screen>&prompt.root; <userinput>/sbin/bsdlabel -B -w /dev/fd0 fd1440</userinput></screen>
	</step>

	<step>
	  <para>Auf der Diskette kann nun ein Dateisystem erstellt
	    werden (high-level Formatierung).  Das Dateisystem der
	    Diskette kann entweder UFS oder FAT sein, wobei FAT für
	    Disketten in der Regel die bessere Wahl ist.</para>

	  <para>Um die Diskette mit FAT zu formatieren, geben Sie
	    folgendes Kommando ein:</para>

	  <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>
	</step>
      </procedure>

      <para>Die Diskette kann nun benutzt werden.  Um die Diskette
	zu verwenden, kann sie mit &man.mount.msdosfs.8; eingehängt
	werden.  Man kann auch <package>emulators/mtools</package> aus
	der Ports-Sammlung installieren, um mit der Diskette zu
	arbeiten.</para>
  </sect1>

  <sect1 xml:id="backups-tapebackups">
    <title>Bandmedien benutzen</title>

    <indexterm><primary>Bandmedien</primary></indexterm>

    <para>Bandmedien haben sich mit der Zeit weiterentwickelt, werden
      jedoch in heutigen Systemen immer weniger verwendet.  Moderne
      Backup-Systeme verwenden
      <foreignphrase>Offsite-Backups</foreignphrase> in Verbindung mit
      lokalen Wechseldatenträgern.  Weiterhin unterstützt &os;
      <acronym>SCSI</acronym>-Bandlaufwerke, wie etwa LTO und die
      älteren DAT-Laufwerke.  Zusätzlich gibt es begrenzte
      Unterstützung für SATA- und
      <acronym>USB</acronym>-Bandlaufwerke.</para>

    <sect2 xml:id="tapes-sa0">
      <title>Serieller Zugriff mit &man.sa.4;</title>

      <indexterm>
	<primary>Bandlaufwerke</primary>
      </indexterm>

      <para>&os; nutzt den &man.sa.4; Treiber, der die Schnittstellen
	<filename>/dev/sa0</filename>,
	<filename>/dev/nsa0</filename> und
	<filename>/dev/esa0</filename> bereitstellt.  Im üblichen
	Gebrauch wird jedoch meist nur
	<filename>/dev/sa0</filename> benötigt.
	<filename>/dev/nsa0</filename> bezeichnet das selbe
	pysikalische Laufwerk wie <filename>/dev/sa0</filename>,
	aber nach dem Schreiben einer Datei wird das Band nicht
	zurückgespult, was es erlaubt, mehr als eine Datei auf ein
	Band zu schreiben.  Die Verwendung von
	<filename>/dev/esa0</filename> wirft das Band aus,
	nachdem das Gerät geschlossen wurde.</para>
    </sect2>

    <sect2>
      <title>Steuerung des Bandlaufwerks mit &man.mt.1;</title>

      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>mt</secondary>
      </indexterm>

      <para>&man.mt.1; ist das &os; Dienstprogramm für die Steuerung
	weiterer Optionen des Bandlaufwerks, wie zum Beispiel die
	Suche nach Dateien auf dem Band, oder um Kontrollmarkierungen
	auf das Band zu schreiben.</para>

      <para>Beispielsweise können die ersten drei Dateien auf einem
	Band erhalten bleiben, indem diese übersprungen werden,
	bevor eine neue Datei geschrieben wird:</para>

      <screen>&prompt.root; <userinput>mt -f /dev/nsa0 fsf 3</userinput></screen>
    </sect2>

    <sect2>
      <title xml:id="tapes-tar">Benutzung von &man.tar.1; zum Lesen
	und Schreiben von Bandsicherungen</title>

      <para>Hier ein Beispiel, wie eine einzelne Datei mittels
	&man.tar.1; auf ein Band geschrieben wird:</para>

      <screen>&prompt.root; <userinput>tar cvf /dev/sa0 <replaceable>file</replaceable></userinput></screen>

      <para>Wiederherstellung von Dateien aus dem &man.tar.1;-Archiv
	von Band in das aktuelle Verzeichnis:</para>

      <screen>&prompt.root; <userinput>tar xvf /dev/sa0</userinput></screen>
    </sect2>

    <sect2>
      <title xml:id="tapes-dumprestore">Die Benutzung von &man.dump.8;
	und &man.restore.8; zum Erstellen und Wiederherstellen von
	Sicherungen.</title>

      <para>Ein einfache Sicherung von
	<filename class="directory">/usr</filename> mit
	&man.dump.8;:</para>

      <screen>&prompt.root; <userinput>dump -0aL -b64 -f /dev/nsa0 /usr</userinput></screen>

      <para>Interaktive Wiederherstellung von Dateien aus einer
	&man.dump.8;-Datei von Band in das aktuelle
	Verzeichnis:</para>

      <screen>&prompt.root; <userinput>restore -i -f /dev/nsa0</userinput></screen>
    </sect2>

    <sect2>
      <title xml:id="tapes-othersoftware">Weitere Software zur
	Bandsicherung</title>

      <para>Es stehen weitere Programme zur Vereinfachung von
	Bandsicherungen zur Verfügung.  Zu den bekanntesten gehören
	<application>Amanda</application> und
	<application>Bacula</application>.  Diese Programme zielen
	darauf ab, Sicherungen einfacher und bequemer zu machen, oder
	um komplexe Sicherungen mehrerer Maschinen zu automatisieren.
	Die Ports-Sammlung enthält sowohl diese, als auch weitere
	Programme für die Bandsicherung.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="backup-basics">
    <title>Datensicherung</title>

    <!--
      <authorgroup>
	<author><personname><firstname>Lowell</firstname><surname>Gilbert</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      -->

    <para>Die Planung und Umsetzung einer Backup-Strategie ist
      unerlässlich, um Daten in bestimmten Situationen
      wiederherstellen zu können, zum Beispiel bei Plattendefekten,
      versehentlichem Löschen von Dateien, willkürlicher Korrumpierung
      von Dateien oder der vollständigen Zerstörung des Systems und
      der Backups, die am gleichen Ort aufbewahrt werden.</para>

    <para>Die Art und der Zeitplan des Backups kann variieren,
      abhängig von der Wichtigkeit der Daten, der benötigten
      Granularität zur Wiederherstellung von Dateien und der
      Dauer einer akzeptablen Ausfallzeit.  Zu den möglichen
      Backup-Strategien gehören unter anderem:</para>

    <itemizedlist>
      <listitem>
	<para>Die Archivierung des kompletten Systems auf externen
	  Datenträgern.  Dieser Ansatz schützt zwar vor allen oben
	  aufgeführten Problemen, ist aber zeitaufwändig und unbequem
	  bei der Wiederherstellung, insbesondere für nicht
	  privilegierte Benutzer.</para>
      </listitem>

      <listitem>
	<para>Dateisystem-Snapshots sind nützlich bei der
	  Wiederherstellung von gelöschten Dateien, bzw. früheren
	  Versionen von Dateien.</para>
      </listitem>

      <listitem>
	<para>Kopien ganzer Dateisysteme oder Festplatten, die mit
	  einem anderen System im Netzwerk mittels
	  <package>net/rsync</package> synchronisiert werden.</para>
      </listitem>

      <listitem>
	<para>Hardware oder Software <acronym>RAID</acronym>, was im
	  Falle von Plattendefekten die Ausfallzeit minimiert oder
	  vermeidet.</para>
      </listitem>
    </itemizedlist>

    <para>Üblicherweise wird eine Mischung aus verschiedenen
      Strategien verwendet.  Es kann zum Beispiel ein Sicherungsplan
      erstellt und automatisiert werden,  um eine wöchentliche,
      vollständige Systemsicherung, ergänzt mit stündlichen
      ZFS-Snapshots, zu erstellen.  Darüber hinaus könnte man
      eine manuelle Sicherung einzelner Verzeichnisse oder Dateien
      machen, bevor diese bearbeitet oder gelöscht werden.</para>

    <para>Dieser Abschnitt beschreibt einige Programme, die zur
      Erstellung und Verwaltung von Sicherungen unter &os; verwendet
      werden können.</para>

    <sect2>
      <title>Sicherung von Dateisystemen</title>

      <indexterm>
	<primary>Backup-Software</primary>
	<secondary>dump / restore</secondary>
      </indexterm>
      <indexterm>
	<primary><command>dump</command></primary>
      </indexterm>
      <indexterm>
	<primary><command>restore</command></primary>
      </indexterm>

      <para>Die traditionellen &unix;-Programme zum Sichern und
	Wiederherstellen von Dateisystemen sind &man.dump.8; und
	&man.restore.8;.  Diese Programme arbeiten auf der Block-Ebene
	der Festplatte, also unterhalb des Abstraktionslevels von
	Dateien, Links und Verzeichnissen, die die Grundlage des
	Dateisystemkonzepts bilden.  Im Gegensatz zu anderen
	Backup-Programmen sichert <command>dump</command> ein ganzes
	Dateisystem und nicht nur einen Teil des Dateisystems, oder
	einen Verzeichnisbaum, der mehr als ein Dateisystem umfasst.
	Anstatt Dateien oder Verzeichnisse zu schreiben, schreibt
	<command>dump</command> die Blöcke, aus denen die Dateien und
	Verzeichnisse bestehen.</para>

      <note>
	<para>Wird <command>dump</command> benutzt, um das
	  Root-Verzeichnis zu sichern, werden
	  <filename>/home</filename>, <filename>/usr</filename> und
	  viele andere Verzeichnisse nicht gesichert, da dies
	  normalerweise Mountpunkte für andere Dateisysteme oder
	  symbolische Links zu diesen Dateisystemen sind.</para>
      </note>

      <para>Wenn <command>restore</command> zum Extrahieren von Daten
	verwendet wird, werden temporäre Dateien standardmäßig in
	<filename>/tmp</filename> abgelegt.  Wenn Sie von einer Platte
	mit einem kleinen <filename>/tmp</filename>-Verzeichnis
	zurücksichern, setzen Sie die Umgebungsvariable
	<envar>TMPDIR</envar> auf ein Verzeichnis mit mehr freiem
	Speicherplatz, damit die Wiederherstellung gelingt.</para>

      <para>Beachten Sie bei der Verwendung von
	<command>dump</command>, dass es einige Eigenarten aus den
	frühen Tagen der Version 6 von AT&amp;T &unix; (ca. 1975)
	beibehalten hat.  Die Standardparameter gehen davon aus, dass
	auf einem 9-Spur-Band gesichert wird, und nicht auf ein
	anderes Medium oder auf Sicherungsbänder mit hoher Dichte.
	Diese Standardwerte müssen auf der Kommandozeile überschrieben
	werden.</para>

      <indexterm>
	<primary><filename>.rhosts</filename></primary>
      </indexterm>

      <para>Es ist möglich, das Dateisystem über das Netzwerk auf
	einem anderen Rechner zu sichern, oder auf einem Bandlaufwerk
	eines anderen Rechners.  Obwohl die Programme &man.rdump.8;
	und &man.rrestore.8; für diese Zwecke benutzt werden können,
	gelten sie als nicht sicher.</para>

      <para>Verwenden Sie stattdessen <command>dump</command> und
	<command>restore</command> in einer sichereren Weise über eine
	<acronym>SSH</acronym>-Verbindung.  In diesem Beispiel wird
	eine vollständige, komprimierte Sicherung des
	<filename>/usr</filename> Dateisystems erstellt, das
	anschließend an einen bestimmten Host über eine
	<acronym>SSH</acronym>-Verbindung gesendet wird.</para>

      <example>
	<title><command>dump</command> mit <application>ssh</application>
	  benutzen</title>
	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
	  targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>
      </example>

      <para>In diesem Beispiel wird <envar>RSH</envar> gesetzt, um
	über eine <acronym>SSH</acronym>-Verbindung eine Sicherung auf
	ein Bandlaufwerk eines entfernten Systems zu schreiben:</para>

      <example>
	<title><command>dump</command> über <application>ssh</application>
	  mit gesetzter <envar>RSH</envar> benutzen</title>

	<screen>&prompt.root; <userinput>env RSH=/usr/bin/ssh /sbin/dump -0uan -f tatargetuser@targetmachine.example.com:/dev/sa0 /usr</userinput></screen>
      </example>
    </sect2>

    <sect2>
      <title>Sicherung von Verzeichnissen</title>

      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>tar</command></secondary>
      </indexterm>

      <para>Einige integrierte Werkzeuge stehen zur Sicherung
	und Wiederherstellung von bestimmten Dateien und
	Verzeichnissen bei Bedarf zur Verfügung.</para>

      <para>Wenn es um die Sicherung von Dateien in einem Verzeichnis
	geht, ist &man.tar.1; eine gute Wahl.  Dieses Werkzeug stammt
	aus Version 6 von AT&amp;T &unix; und erwartet standardmäßig
	eine rekursive Sicherung auf ein lokales Band.  Es können
	jedoch Optionen angegeben werden, um den Namen einer
	Sicherungsdatei zu bestimmen.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>

      <para>In diesem Beispiel wird eine komprimierte Sicherung des
	aktuellen Verzeichnisses nach
	<filename>/tmp/mybackup.tgz</filename> gespeichert.  Achten
	Sie bei der Sicherungsdatei darauf, dass sie nicht in dem
	Verzeichnis gepeichert wird, welches gesichert werden
	soll.</para>

      <example>
	<title>Das aktuelle Verzeichnis mit <command>tar</command>
	  sichern</title>

	<screen>&prompt.root; <userinput>tar czvf <replaceable>/tmp/mybackup.tgz</replaceable> .</userinput></screen>
      </example>

      <para>Um eine komplette Sicherung wiederherzustellen, wechseln
	Sie mit <command>cd</command> in das Verzeichnis, in dem Sie
	die Daten wiederherstellen möchten und geben Sie den Namen der
	Sicherungsdatei an.  Beachten Sie, dass dabei alle Dateien in
	dem Verzeichnis überschrieben werden.  Im Zweifel sichern Sie
	besser in einem temporären Verzeichnis, oder geben Sie den
	Verzeichnisnamen bei der Wiederherstellung an.</para>

      <example>
	<title>Wiederherstellung mit <command>tar</command> in das
	  aktuelle Verzeichnis</title>

	<screen>&prompt.root; <userinput>tar xzvf <replaceable>/tmp/mybackup.tgz</replaceable></userinput></screen>
      </example>

      <para>Es gibt dutzende Optionen, die in &man.tar.1; beschrieben
	werden.  Das Programm unterstützt auch die Verwendung von
	Ausschlußmustern, um bestimmte Dateien von der Sicherung oder
	Wiederherstellung von Verzeichnissen auszuschließen.</para>

      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>cpio</command></secondary>
      </indexterm>

      <para>Um bestimmte, aufgelistete Dateien und Verzeichnisse zu
	sichern, ist &man.cpio.1; eine gute Wahl.  Im Gegensatz zu
	<command>tar</command> weiß <command>cpio</command> nicht
	wie ein Verzeichnisbaum durchlaufen wird.  Daher ist es auf
	eine Liste von zu sichernden Dateien angewiesen.</para>

      <para>So kann beispielsweise eine Liste von Dateien mit
	<command>ls</command> oder <command>find</command> erzeugt
	werden.  Dieses Beispiel erstellt eine rekursive Liste des
	aktuellen Verzeichnisses, die dann über eine Pipe an
	<command>cpio</command> übergeben wird, um eine Sicherung
	namens <filename>/tmp/mybackup.cpio</filename> zu
	erstellen.</para>

      <example>
	<title>Rekursive Sicherung des aktuellen Verzeichnisses mit
	  <command>ls</command> und <command>cpio</command></title>

	<screen>&prompt.root; <userinput>ls -R | cpio -ovF /tmp/mybackup.cpio</userinput></screen>
      </example>

      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; ist ein Programm, welches versucht die
	Funktionen von <command>tar</command> und
	<command>cpio</command> zu kombinieren.  Über die Jahre
	hinweg sind die verschiedenen Versionen von
	<command>tar</command> und <command>cpio</command> leicht
	inkompatibel geworden.  Daher hat &posix;
	<command>pax</command> geschaffen, welches versucht viele
	der unterschiedlichen <command>cpio</command>- und
	<command>tar</command>-Formate zu lesen und zu schreiben,
	außerdem einige neue, eigene Formate.</para>

      <para>Für die vorangegangenen Beispiele wäre ein äquivalenter
	Aufruf von <command>pax</command>:</para>

      <example>
	<title>Das aktuelle Verzeichnis mit <command>pax</command>
	  sichern</title>

	<screen>&prompt.root; <userinput>pax -wf <replaceable>/tmp/mybackup.pax</replaceable> .</userinput></screen>
      </example>
    </sect2>

    <sect2 xml:id="backups-programs-amanda">
      <title>Backup-Software von Drittanbietern</title>

      <indexterm>
	<primary>Backup-Software</primary>
      </indexterm>

      <para>Die &os; Ports-Sammlung enthält viele Programme von
	Drittanbietern, die verwendet werden können um zeitlich
	festgelegte Sicherungen zu erstellen.  Viele dieser Programme
	basieren auf dem Client-Server-Modell und können benutzt
	werden, um die Sicherung von einzelnen Systemen oder allen
	Rechnern in einem Netzwerk zu automatisieren.</para>

      <para>Zu den bekannten Programmen gehören
	<application>Amanda</application>,
	<application>Bacula</application>,
	<application>rsync</application> und
	<application>duplicity</application>.</para>
    </sect2>

    <sect2>
      <title>Die Wiederherstellung in einem Notfall</title>

      <para>Zusätzlich zu den regelmäßigen Sicherungen empfiehlt es
	sich, die folgenden Schritte im Rahmen eines Notfallplans
	durchzuführen.</para>

	<indexterm>
	  <primary><command>bsdlabel</command></primary>
	</indexterm>

	<para>Erstellen Sie einen Ausdruck der Ausgabe
	  der folgenden Kommandos:</para>

	<itemizedlist>
	  <listitem>
	    <para><command>gpart show</command></para>
	  </listitem>

	  <listitem>
	    <para><command>more /etc/fstab</command></para>
	  </listitem>

	  <listitem>
	    <para><command>dmesg</command></para>
	  </listitem>
	</itemizedlist>

	<indexterm><primary>Live-CD</primary></indexterm>

	<para>Bewahren Sie diesen Ausdruck und eine Kopie des
	  Installationsmediums an einem sicheren Ort auf.  Im Falle
	  einer Wiederherstellung im Notfall, starten Sie von dem
	  Installationsmedium und wählen Sie
	  <literal>Live CD</literal>, um eine Rettungs-Shell zu
	  starten.  Dieser Rettungmodus kann verwendet werden, um den
	  aktuellen Stand des Systems anzuzeigen, und wenn nötig,
	  Festplatten zu formatieren und Daten aus den Sicherungen
	  wiederherzustellen.</para>

	<note>
	  <para>Das Installationsmedium für
	    &os;/&arch.i386;&nbsp;&rel2.current;-RELEASE enthält
	    keine Rettungs-Shell.  Laden Sie für diese Version ein
	    Abbild der Livefs <acronym>CD</acronym> von <uri
	      xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-
IMAGES/&rel2.current;/&os;-&rel2.current;-RELEASE-&arch.i386;-
livefs.iso">ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO
IMAGES/&rel2.current;/&os;-&rel2.current;-RELEASE-&arch.i386;-livefs.iso</uri>.</para>
	</note>

	<para>Als nächstes testen Sie die Rettungs-Shell und die
	  Sicherungen. Dokumentieren Sie diesen Ablauf.  Bewahren
	  Sie diese Notizen zusammen mit den Medien, den Ausdrucken
	  und den Sicherungen auf.  Diese Notizen können Ihnen im
	  Notfall helfen eine versehentliche Zerstörung der
	  Sicherungen zu verhindern, während Sie unter Stress eine
	  Wiederherstellung durchführen.</para>

	<para>Als zusätzliche Sicherheitsvorkehrung kann jeweils
	  die letzte Sicherung an einem entfernten Standort
	  aufbewahrt werden.  Dieser Standort sollte räumlich von
	  den Computern und Festplatten durch eine erhebliche
	  Entfernung getrennt sein.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-virtual">
    <info><title>Netzwerk-, speicher- und dateibasierte Dateisysteme</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Verbessert und neu strukturiert von </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>virtuelle</secondary>
    </indexterm>

    <para>Neben physikalischen Laufwerken, wie Disketten,
      <acronym>CD</acronym>s und Festplatten, unterstützt &os;
      auch <firstterm>virtuelle Laufwerke</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>speicherbasierte</secondary>
    </indexterm>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>RAM-Disks</secondary>
    </indexterm>

    <para>Dazu zählen Netzwerkdateisysteme wie
      <link linkend="network-nfs">Network Filesystem</link> und Coda,
      speicher- und dateibasierte Dateisysteme.</para>

    <para>Abhängig von der verwendeten &os; Version werden
      speicher- und dateibasierte Dateisysteme mit unterschiedlichen
      Werkzeugen angelegt.</para>

    <note>
      <para>Gerätedateien werden unter &os; automatisch
	von &man.devfs.5; angelegt.</para>
    </note>

    <sect2 xml:id="disks-mdconfig">
      <title>Dateibasierte Laufwerke unter FreeBSD</title>
      <indexterm>
        <primary>Laufwerke</primary>
        <secondary>dateibasierte</secondary>
      </indexterm>

      <para>Unter &os; werden virtuelle Laufwerke, &man.md.4;,
	mit &man.mdconfig.8; erzeugt.  Dazu muss das Modul
	&man.md.4; geladen sein.  Bei der Verwendung einer eigenen
	Kernelkonfiguration, muss diese Zeile enthalten sein:</para>

      <programlisting>device md</programlisting>

      <para>&man.mdconfig.8; unterstützt verschiedene Arten von
	speicherbasierten virtuellen Laufwerken: speicherbasierte
	Laufwerke, deren Speicher von &man.malloc.9; zur Verfügung
	gestellt wird, und dateibasierte Laufwerke, deren Speicher von
	einer Datei oder dem Swap-Bereich zur Verfügung gestellt wird.
	Eine mögliche Anwendung ist das Einhängen von
	<acronym>CD</acronym>s.</para>

      <para>Das Abbild eines Dateisystems wird wie folgt
        eingehangen:</para>

      <example>
	<title>Einhängen eines existierenden Abbildes unter
	  &os;</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>diskimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>
      </example>

      <para>Ein neues Dateisystem-Abbild erstellen Sie mit
        &man.mdconfig.8; wie folgt:</para>

      <example>
	<title>Erstellen eines dateibasierten Laufwerks mit
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f <replaceable>newimage</replaceable> -u <replaceable>0</replaceable></userinput>
&prompt.root; <userinput>bsdlabel -w md<replaceable>0</replaceable> auto</userinput>
&prompt.root; <userinput>newfs md<replaceable>0</replaceable>a</userinput>
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
&prompt.root; <userinput>mount /dev/md<replaceable>0</replaceable>a <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</screen>
      </example>

      <para>Wenn keine Gerätenummer mit <option>-u</option> angegeben
	ist, wird von &man.md.4; automatisch eine
	ungenutzte Gerätenummer zugewiesen.  Das zugewiesene Gerät
	wird auf der Standardausgabe ausgegeben (zum Beispiel
	<filename>md4</filename>).  Weitere Informationen finden Sie
	in &man.mdconfig.8;.</para>

      <para>Obwohl &man.mdconfig.8; sehr nützlich ist, benötigt es
	einige Kommandos, um ein dateibasiertes Dateisystem zu
	erstellen.  &os; enthält auch &man.mdmfs.8;, das die
	notwendigen Schritte in einem Befehl zusammenfasst.  Es
	konfiguriert mit &man.mdconfig.8; ein &man.md.4;-Laufwerk,
	erstellt darauf mit &man.newfs.8; ein UFS-Dateisystem und
	hängt es anschließend mit &man.mount.8; ein.  Das virtuelle
	Laufwerk aus dem obigen Beispiel kann mit den nachstehenden
	Befehlen erstellt werden:</para>

      <example>
	<title>Mit <command>mdmfs</command> ein dateibasiertes
	  Dateisystem erstellen</title>
	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>newimage</replaceable> bs=1k count=<replaceable>5</replaceable>k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F <replaceable>newimage</replaceable> -s <replaceable>5</replaceable>m md<replaceable>0</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt</screen>
      </example>

      <para>Wenn <option>md</option> ohne Gerätenummer verwendet wird,
	wählt &man.md.4; automatisch ein ungenutztes
	Gerät aus.  Weitere Einzelheiten entnehmen Sie bitte der
	Hilfeseite &man.mdmfs.8;.</para>
    </sect2>

    <sect2 xml:id="disks-md-freebsd5">
      <title>Speicherbasierte Laufwerke unter FreeBSD</title>

      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>speicherbasierte</secondary>
      </indexterm>

      <para>Bei einem speicherbasierten Dateisystem sollte
	<quote>swap backing</quote> aktiviert werden.  Das heißt
	allerdings nicht, dass das speicherbasierte Laufwerk
	automatisch auf die Festplatte ausgelagert wird, vielmehr
	wird der Speicherplatz danach aus einem Speicherpool
	angefordert, der bei Bedarf auf die Platte ausgelagert werden
	kann.  Zusätzlich ist es möglich, &man.malloc.9;-gestützte
	speicherbasierte Laufwerke zu erstellen.  Das Anlegen solcher
	Laufwerke kann allerdings zu einer System-Panic führen, wenn
	der Kernel danach über zu wenig Speicher verfügt.</para>

      <example>
	<title>Erstellen eines speicherbasierten Laufwerks mit
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>mdconfig -a -t swap -s <replaceable>5</replaceable>m -u <replaceable>1</replaceable></userinput>
&prompt.root; <userinput>newfs -U md1</userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
&prompt.root; <userinput>mount /dev/md<replaceable>1</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</screen>
      </example>

      <example>
	<title>Erstellen eines speicherbasierten Laufwerks mit
	  <command>mdmfs</command></title>

	<screen>&prompt.root; <userinput>mdmfs -s <replaceable>5</replaceable>m md<replaceable>2</replaceable> <replaceable>/mnt</replaceable></userinput>
&prompt.root; <userinput>df <replaceable>/mnt</replaceable></userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2>
      <title>Virtuelle Laufwerke freigeben</title>
      <indexterm>
        <primary>Laufwerke</primary>
        <secondary>Freigabe von virtuellen Laufwerken</secondary>
      </indexterm>

      <para>Wenn ein virtuelles Laufwerk nicht mehr in Gebrauch ist,
	sollten seine belegten Ressourcen an das System zurückgegeben
	werden.  Zuerst wird das Dateisystem abgehängt und dann die
	benutzten Ressourcen mit &man.mdconfig.8; freigegeben.</para>

      <para>Alle von <filename>/dev/md4</filename> belegten Ressourcen
        werden mit dem nachstehenden Kommando freigegeben:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u <replaceable>4</replaceable></userinput></screen>

      <para>Informationen zu eingerichteten &man.md.4;-Geräten werden
	mit <command>mdconfig -l</command> angezeigt.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="snapshots">
    <info><title>Schnappschüsse von Dateisystemen</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    <indexterm>
      <primary>Schnappschüsse</primary>
      <secondary>von Dateisystemen</secondary>
    </indexterm>

    <para>Zusammen mit
      <link linkend="soft-updates">Soft Updates</link> bietet &os;
      eine weitere Funktion: Schnappschüsse von Dateisystemen.</para>

    <para>UFS-Schnappschüsse sind Dateien, die ein Abbild eines
      Dateisystems enthalten und müssen auf dem jeweiligen Dateisystem
      erstellt werden.  Pro Dateisystem darf es maximal
      20&nbsp;Schnappschüsse, die im Superblock vermerkt werden,
      geben.  Schnappschüsse bleiben erhalten, wenn das Dateisystem
      abgehangen, neu eingehangen oder das System neu gestartet wird.
      Wenn ein Schnappschuss nicht mehr benötigt wird, kann er
      mit &man.rm.1; gelöscht werden.  Es ist egal, in welcher
      Reihenfolge Schnappschüsse gelöscht werden.  Es kann allerdings
      vorkommen, dass nicht der gesamte Speicherplatz wieder
      freigegeben wird, da ein anderer Schnappschuss einen Teil der
      entfernten Blöcke für sich beanspruchen kann.</para>

    <para>Das unveränderliche <option>Snapshot</option>-Dateiflag
      wird nach der Erstellung des Snaphshots von &man.mksnap.ffs.8;
      gesetzt.  Durch die Verwendung von &man.unlink.1; ist es
      allerdings möglich, einen Schnappschuss zu löschen.</para>

    <para>Schnappschüsse werden mit &man.mount.8; erstellt.  Das
      folgende Kommando legt einen Schnappschuss von
      <filename>/var</filename> in <filename>/var/snapshot/snap</filename>
      ab:</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

    <para>Alternativ kann der Schnappschuss auch mit
      &man.mksnap.ffs.8; erstellt werden.</para>

    <screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

    <para>Um Schnappschüsse auf einem Dateisystem, beispielsweise
      <filename>/var</filename> zu finden, kann man &man.find.1;
      verwenden:</para>

    <screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

    <para>Nachdem ein Schnappschuss erstellt wurde, können Sie
      ihn für verschiedene Zwecke benutzen:</para>

    <itemizedlist>
      <listitem>
	<para>Sie können den Schnappschuss für die
	  Datensicherung benutzen und ihn auf eine
	  <acronym>CD</acronym> oder ein Band schreiben.</para>
      </listitem>

      <listitem>
	<para>Die Intigrität des Schnappschusses kann mit &man.fsck.8;
	  geprüft werden.  Wenn das Dateisystem zum Zeitpunkt der
	  Erstellung des Schnappschusses in Ordnung war, sollte
	  &man.fsck.8; immer erfolgreich durchlaufen.</para>
      </listitem>

      <listitem>
	<para>Sie können den Schnappschuss mit &man.dump.8;
	  sichern.  Sie erhalten dann eine konsistente Sicherung des
	  Dateisystems zu dem Zeitpunkt, der durch den Zeitstempel des
	  Schnappschusses gegeben ist.  Der Schalter
	  <option>-L</option> von &man.dump.8; erstellt für die
	  Sicherung einen Schnappschuss und entfernt diesen am Ende
	  der Sicherung wieder.</para>
      </listitem>

      <listitem>
	<para>Sie können einen Schnappschuss in den
	  Verzeichnisbaum einhängen und sich dann den Zustand des
	  Dateisystems zu dem Zeitpunkt ansehen, an dem der
	  Schnappschuss erstellt wurde.  Der folgende Befehl
	  hängt den Schnappschuss
	  <filename>/var/snapshot/snap</filename> ein:</para>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

      </listitem>
    </itemizedlist>

    <para>Der eingefrorene Stand des
      <filename>/var</filename>-Dateisystems ist nun unterhalb von
      <filename>/mnt</filename> verfügbar.  Mit Ausnahme der früheren
      Schnappschüsse, die als leere Dateien auftauchen, wird zu
      Beginn alles so aussehen, wie zum Zeitpunkt der Erstellung des
      Schnappschusses.  Der Schnappschuss kann wie folgt abgehängt
      werden:</para>

    <screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

    <para>Weitere Informationen über Soft Updates und
      Schnappschüsse von Dateisystemen sowie technische Artikel finden
      Sie auf der <link xlink:href="http://www.mckusick.com/">Webseite
        von Marshall Kirk McKusick</link>.</para>
  </sect1>

  <sect1 xml:id="quotas">
    <title>Dateisystem-Quotas</title>
    <indexterm>
      <primary>Accounting</primary>
      <secondary>Plattenplatz</secondary>
    </indexterm>
    <indexterm><primary>Disk Quotas</primary></indexterm>

    <para>Quotas sind eine optionale Funktion des Betriebssystems,
      die es erlauben, den Plattenplatz und/oder die Anzahl
      der Dateien eines Benutzers oder der Mitglieder einer Gruppe,
      auf Dateisystemebene zu beschränken.  Oft wird dies
      auf Timesharing-Systemen (Mehrbenutzersystemen) genutzt, da
      es dort erwünscht ist, die Ressourcen, die ein Benutzer oder
      eine Gruppe von Benutzern belegen können, zu limitieren.  Das
      verhindert, dass ein Benutzer oder eine Gruppe von Benutzern
      den ganzen verfügbaren Plattenplatz belegt.</para>

    <sect2>
      <title>Konfiguration des Systems, um Quotas zu
	aktivieren</title>

      <para>Bevor Quotas benutzt werden können, müssen
	sie im Kernel konfiguriert werden, wozu die folgende Zeile
	der Kernelkonfiguration hinzugefügt wird:</para>

      <programlisting>options QUOTA</programlisting>

      <para>Vor &os;&nbsp;9.2 ist diese Option in der Regel nicht im
	<filename>GENERIC</filename>-Kernel enthalten.
	<command>sysctl kern.features.ufs_quota</command> kann benutzt
	werden um zu testen, ob der aktuelle Kernel Quotas
	unterstützt.  Wenn die Option nicht vorhanden ist, muss ein
	angepasster Kernel erstellt werden.  Weitere
	Informationen zur Kernelkonfiguration finden Sie in
	<xref linkend="kernelconfig"/>.</para>

      <para>Durch Hinzufügen der folgenden Zeile in
	<filename>/etc/rc.conf</filename> wird das Quota-System
	aktiviert:</para>

      <programlisting>quota_enable="YES"</programlisting>

      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>überprüfen</secondary>
      </indexterm>

      <para>Um den Start des Quota-Systems zu beeinflussen, steht
	eine weitere Variable zur Verfügung.  Normalerweise
	wird beim Booten die Integrität der Quotas auf
	allen Dateisystemen mit &man.quotacheck.8;
	überprüft.  Dieses Programm stellt sicher, dass die
	Quota-Datenbank mit den Daten auf einem Dateisystem
	übereinstimmt.  Dies ist allerdings ein zeitraubender Prozess,
	der die Zeit, die das System zum Booten braucht, signifikant
	beeinflusst.  Eine Variable in
	<filename>/etc/rc.config</filename> erlaubt es, diesen Schritt
	zu überspringen:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Zuletzt muss noch <filename>/etc/fstab</filename>
	bearbeitet werden, um die Plattenquotas auf Dateisystemebene
	zu aktivieren.  Dort können für die Dateisysteme Quotas für
	Benutzer oder Gruppen aktiviert werden.</para>

      <para>Um Quotas pro Benutzer für ein Dateisystem zu aktivieren,
	geben Sie für dieses Dateisystem <option>userquota</option> im
	Feld Optionen von <filename>/etc/fstab</filename> an.
	Beispiel:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Um Quotas für Gruppen einzurichten, verwenden
	Sie <option>groupquota</option>.  Um Quotas für Benutzer
	und Gruppen einzurichten, ändern Sie den Eintrag
	wie folgt ab:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>Die Quota-Dateien werden standardmäßig im Rootverzeichnis
	des Dateisystems unter <filename>quota.user</filename> und
	<filename>quota.group</filename> abgelegt.  Weitere
	Informationen finden Sie in &man.fstab.5;.  Obwohl die
	Quota-Dateien an anderer Stelle gespeichert werden können,
	wird das nicht empfohlen, da es den Anschein hat, dass die
	verschiedenen Quota-Utilities dies nicht richtig
	unterstüzten.</para>

      <para>Sobald die Konfiguration abgeschlossen ist, booten Sie das
	System mit dem neuen Kernel.
	<filename>/etc/rc</filename> wird dann automatisch die
	richtigen Kommandos aufrufen, die die Quota-Dateien für
	alle Quotas, die Sie in <filename>/etc/fstab</filename>
	definiert haben, anlegen.  Es besteht keine Notwendigkeit,
	leere Quota-Dateien manuell zu erstellen .</para>

      <para>Normalerweise brauchen die Kommandos
	&man.quotacheck.8;, &man.quotaon.8; oder
	&man.quotaoff.8; nicht händisch aufgerufen werden,
	obwohl man die entsprechenden Seiten im
	Manual lesen sollte, um sich mit ihnen vertraut
	zu machen.</para>
    </sect2>

    <sect2>
      <title>Setzen von Quota-Limits</title>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>Limits</secondary>
      </indexterm>

      <para>Sobald das System konfiguriert wurde, Quotas zu
	aktivieren, stellen Sie sicher, dass diese auch tatsächlich
	aktiviert sind:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>Für jedes Dateisystem, auf dem Quotas aktiviert sind,
	sollte eine Zeile mit der Plattenauslastung und den
	aktuellen Quota-Limits zu sehen sein.</para>

      <para>Mit &man.edquota.8; können nun
	Quota-Limits zugewiesen werden.</para>

      <para>Mehrere Möglichkeiten stehen zur Verfügung, um Limits für
	den Plattenplatz, den ein Benutzer oder eine Gruppe verbrauchen
	kann, oder die Anzahl der Dateien, die angelegt werden dürfen,
	festzulegen.  Die Limits können auf dem Plattenplatz
	(Block-Quotas), der Anzahl der Dateien (Inode-Quotas) oder
	einer Kombination von beiden basieren.
	Jedes Limit wird weiterhin in zwei Kategorien geteilt:
	Hardlimits und Softlimits.</para>

      <indexterm><primary>Hardlimit</primary></indexterm>
      <para>Ein Hardlimit kann nicht überschritten werden.
	Hat der Benutzer einmal ein Hardlimit erreicht, so kann er
	auf dem betreffenden Dateisystem keinen weiteren Platz mehr
	beanspruchen.  Hat ein Benutzer beispielsweise ein Hardlimit
	von 500 Kilobytes auf einem Dateisystem und benutzt davon
	490 Kilobyte, so kann er nur noch 10 weitere Kilobytes
	beanspruchen.  Der Versuch, weitere 11 Kilobytes zu beanspruchen,
	wird fehlschlagen.</para>

      <indexterm><primary>Softlimit</primary></indexterm>
      <para>Softlimits können für eine
	befristete Zeit überschritten werden.  Diese Frist
	beträgt in der Grundeinstellung
	eine Woche.  Hat der Benutzer das Softlimit über die
	Frist hinaus überschritten, so wird das Softlimit in
	ein Hardlimit umgewandelt und der Benutzer kann
	keinen weiteren Platz mehr beanspruchen.  Wenn er einmal
	das Softlimit unterschreitet, wird die Frist wieder
	zurückgesetzt.</para>

      <para>Das folgende Beispiel zeigt die Benutzung von
	&man.edquota.8;.  Wenn &man.edquota.8; aufgerufen wird,
	wird der Editor gestartet, der durch <envar>EDITOR</envar>
	gegeben ist oder <application>vi</application> falls
	<envar>EDITOR</envar> nicht gesetzt ist.  In dem Editor
	können Sie die Limits eingeben.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>Für jedes Dateisystem, auf dem Quotas aktiv sind,
	sind zwei Zeilen zu sehen.  Eine repräsentiert die
	Block-Quotas und die andere die Inode-Quotas.  Um ein Limit zu
	modifizieren, ändern Sie einfach den angezeigten Wert.  Um
	beispielsweise das Blocklimit dieses Benutzers von einem
	Softlimit von 50 und einem Hardlimit von 75 auf ein Softlimit
	von 500 und ein Hardlimit von 600 zu erhöhen, ändern Sie
	die Zeile:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>zu:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>Die neuen Limits sind wirksam, sobald der Editor verlassen
	wird.</para>

      <para>Manchmal ist es erwünscht, die Limits für einen
	Bereich von UIDs zu setzen.  Dies kann mit der <option>-p</option>
	Option von &man.edquota.8; bewerkstelligt werden.
	Weisen Sie dazu die Limits einem Benutzer zu und rufen danach
	<command>edquota -p protouser startuid-enduid</command> auf.
	Besitzt beispielsweise der Benutzer <systemitem class="username">test</systemitem>
	die gewünschten Limits, können diese mit
	dem folgenden Kommando für die UIDs 10.000 bis 19.999
	dupliziert werden:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>

      <para>Weitere Informationen finden Sie in
	&man.edquota.8;.</para>
    </sect2>

    <sect2>
      <title>Überprüfen von Quota-Limits und Plattennutzung</title>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>überprüfen</secondary>
      </indexterm>

      <para>&man.quota.1; oder &man.repquota.8; können benutzt werden,
	um Quota-Limits und Plattennutzung zu überprüfen.  Um die
	Limits oder die Plattennutzung individueller Benutzer und
	Gruppen zu überprüfen, kann &man.quota.1; benutzt werden.  Ein
	Benutzer kann nur die eigenen Quotas und die Quotas der
	Gruppe, der er angehört untersuchen.  Nur der Superuser darf
	sich alle Limits ansehen.  Mit &man.repquota.8; erhalten Sie
	eine Zusammenfassung von allen Limits und der
	Plattenausnutzung für alle Dateisysteme, auf denen Quotas
	aktiv sind.</para>

      <para>Das folgende Beispiel zeigt die Ausgabe von
	<command>quota -v</command> für einen Benutzer, der
	Quota-Limits auf zwei Dateisystemen besitzt:</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

     <indexterm><primary>grace period</primary></indexterm>
     <para>Im Dateisystem <filename>/usr</filename> liegt der Benutzer
	momentan 15 Kilobytes über dem Softlimit von
	50 Kilobytes und hat noch 5 Tage seiner Frist übrig.
	Der Stern <literal>*</literal> zeigt an, dass der
	Benutzer sein Limit überschritten hat.</para>

      <para>In der Ausgabe von &man.quota.1; werden Dateisysteme,
	auf denen ein Benutzer keinen Platz verbraucht, nicht angezeigt,
	auch wenn diesem Quotas zugewiesen wurden.  Mit <option>-v</option>
	werden diese Dateisysteme, wie <filename>/usr/var</filename>
	im obigen Beispiel, angezeigt.</para>
    </sect2>

    <sect2>
      <title>Quotas über NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas werden von dem Quota-Subsystem auf dem NFS Server
	erzwungen.  Der &man.rpc.rquotad.8; Daemon stellt
	&man.quota.1; die Quota Informationen auf dem NFS Client
	zur Verfügung, so dass Benutzer auf diesen
	Systemen ihre Quotas abfragen können.</para>

      <para>Aktivieren Sie <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> wie folgt:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Anschließend starten Sie <command>inetd</command>
	neu:</para>

      <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-encrypting">
    <info><title>Partitionen verschlüsseln</title>
      <authorgroup>
	<author><personname><firstname>Lucky</firstname><surname>Green</surname></personname><contrib>Beigetragen von </contrib><affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>Partitionen</primary>
      <secondary>verschlüsseln</secondary>
    </indexterm>

    <para>&os; bietet ausgezeichnete Möglichkeiten, Daten vor
      unberechtigten Zugriffen zu schützen.  Wenn das
      Betriebssystem läuft, schützen Zugriffsrechte und
      vorgeschriebene Zugriffskontrollen (MAC) (siehe <xref linkend="mac"/>)
      die Daten.  Die Zugriffskontrollen des Betriebssystems
      schützen allerdings nicht vor einem Angreifer, der
      Zugriff auf den Rechner hat.  Der Angreifer
      kann eine Festplatte in ein anderes System einbauen
      und dort die Daten analysieren.</para>

    <para>Die für &os; verfügbaren kryptografischen Subsysteme,
      GEOM Based Disk Encryption (<command>gbde</command>)
      und <command>geli</command> sind in der Lage, Daten auf
      Dateisystemen auch vor hoch motivierten Angreifern zu
      schützen,  die über erhebliche Mittel verfügen.
      Dieser Schutz ist unabhängig von der Art und Weise, durch
      die ein Angreifer Zugang zu einer Festplatte oder zu einem
      Rechner erlangt hat.  Im Gegensatz zu schwerfälligen
      Systemen, die einzelne Dateien verschlüsseln,
      verschlüsseln <application>gbde</application> und
      <command>geli</command> transparent ganze Dateisysteme.  Auf der
      Festplatte werden dabei keine Daten im Klartext gespeichert.</para>

    <sect2>
      <title>Plattenverschlüsselung mit
        <application>gbde</application></title>

      <para>&man.gbde.8; benutzt 128-Bit <acronym>AES</acronym> im
	<acronym>CBC</acronym>-Modus, um die Daten eines Sektors zu
	verschlüsseln.  Jeder Sektor einer Festplatte wird mit einem
	anderen <acronym>AES</acronym>-Schlüssel verschlüsselt.
	Weitere Informationen zum kryptographischen Design und wie die
	Schlüssel für einen Sektor aus der gegebenen Passphrase
	ermittelt werden, finden Sie in &man.gbde.4;.</para>

      <note>
	<para>&man.sysinstall.8; kann nicht mit verschlüsselten
	  <application>gbde</application>-Geräten umgehen.  Vor
	  dem Start von &man.sysinstall.8; müssen alle
	  <filename>*.bde</filename>-Geräte deaktiviert werden, da
	  &man.sysinstall.8; sonst bei der Suche nach abstürzt.  Das
	  im Beispiel verwendete Gerät wird mit dem folgenden Befehl
	  deaktiviert:</para>

	<screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>
      </note>

      <para>&os; enthält ein Kernelmodul für
	<application>gbde</application>, das wie folgt geladen werden
	kann:</para>

      <screen>&prompt.root; <userinput>kldload geom_bde</userinput></screen>

      <para>Wenn Sie einen angepassten Kernel verwenden, stellen Sie
	sicher, dass folgende Zeile in der Kernelkonfigurationsdatei
	enthalten ist:</para>

      <para><literal>options GEOM_BDE</literal></para>

      <para>Das folgende Beispiel beschreibt, wie eine Partition
	auf einer neuen Festplatte verschlüsselt wird.  Die
	Partition wird in <filename>/private</filename> eingehangen.
	Mit <application>gbde</application> könnten auch
	<filename>/home</filename> und <filename>/var/mail</filename>
	verschlüsselt werden.  Die dazu nötigen Schritte
	können allerdings in dieser Einführung
	nicht behandelt werden.</para>

      <procedure>
	<step>
	  <title>Installieren der Festplatte</title>

	  <para>Installieren Sie die Festplatte wie in
	    <xref linkend="disks-adding"/> beschrieben.  Im Beispiel
	    verwenden wir die Partition <filename>/dev/ad4s1c</filename>.
	    Die Gerätedateien
	    <filename>/dev/ad0s1<replaceable>*</replaceable></filename>
	    sind Standard-Partitionen des &os;-Systems.</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
	  <title>Verzeichnis für gbde-Lock-Dateien anlegen</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	  <para>Die Lock-Dateien sind für den Zugriff von
	    <application>gbde</application> auf verschlüsselte
	    Partitionen notwendig.  Ohne die Lock-Dateien können
	    die Daten nur mit erheblichem manuellen Aufwand wieder
	    entschlüsselt werden (dies wird auch von der Software
	    nicht unterstützt).  Jede verschlüsselte
	    Partition benötigt eine gesonderte Lock-Datei.</para>
	</step>

	<step>
	  <title>Vorbereiten der gbde-Partition</title>

	  <para>Eine von <application>gbde</application> benutzte
	    Partition muss einmalig vorbereitet werden:</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>&man.gbde.8; öffnet eine Vorlage im Standard-Editor,
	    um verschiedene Optionen einstellen zu können.
	    Setzen Sie <varname>sector_size</varname> auf
	    <literal>2048</literal>, wenn Sie
	    UFS1 oder UFS2 benutzen.</para>

	  <programlisting># &dollar;FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]</programlisting>

	  <para>&man.gbde.8; fragt zweimal die Passphrase zum Schutz
	    der Daten ab.  Die Passphrase muss beide Mal gleich
	    eingegeben werden.  Die Sicherheit der Daten hängt allein
	    von der Qualität der gewählten Passphrase ab.  Die Auswahl
	    einer sicheren und leicht zu merkenden Passphrase wird auf
	    der Webseite <link xlink:href="http://world.std.com/~reinhold/diceware.html">Diceware
	      Passphrase</link> beschrieben.</para>

	  <para>Mit <command>gbde init</command> wurde im Beispiel
	    auch die Lock-Datei <filename>/etc/gbde/ad4s1c.lock</filename>
	    angelegt.  <application>gbde</application>-Lockdateien
	    müssen die Dateiendung <quote>.lock</quote> aufweisen,
	    damit sie von <filename>/etc/rc.d/gbde</filename>, dem
	    Startskript von <application>gbde</application>, erkannt
	    werden.</para>

	  <caution>
	    <para>Sichern Sie die Lock-Dateien von
	      <application>gbde</application> immer zusammen mit den
	      verschlüsselten Dateisystemen.  Ein entschlossener
	      Angreifer kann die Daten vielleicht auch ohne die
	      Lock-Datei entschlüsseln.  Ohne die Lock-Datei
	      können Sie allerdings nicht auf die
	      verschlüsselten Daten zugreifen.  Dies ist nur noch
	      mit erheblichem manuellen Aufwand möglich, der nicht
	      &man.gbde.8; wird.</para>
	  </caution>
	</step>

	<step>
	  <title>Einbinden der verschlüsselten Partition
	    in den Kernel</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>Dieses Kommando fragt die Passphrase ab, die bei der
	    Initialisierung der verschlüsselten Partition eingegeben
	    wurde.  Das neue verschlüsselte Gerät erscheint danach in
	    <filename>/dev</filename> als
	    <filename>/dev/device_name.bde</filename>:</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
	  <title>Dateisystem auf dem verschlüsselten Gerät
	    anlegen</title>

	  <para>Nachdem die verschlüsselte Partition im Kernel
	    eingebunden ist, kann mit &man.newfs.8; ein Dateisystem
	    erstellt werden.  Dieses Beispiel erstellt ein
	    UFS2-Dateisystem mit aktivierten Soft Updates.</para>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>

	  <note>
	    <para>&man.newfs.8; muss auf einer eingebundenen
	      <application>gbde</application>-Partition ausgeführt
	      werden, welche durch das Suffix
	      <filename><replaceable>*</replaceable>.bde</filename>
	      identifiziert wird.</para>
	  </note>
	</step>

	<step>
	  <title>Einhängen der verschlüsselten Partition</title>

	  <para>Legen Sie einen Mountpunkt für das
	    verschlüsselte Dateisystem an:</para>

	  <screen>&prompt.root; <userinput>mkdir /private</userinput></screen>

	  <para>Hängen Sie das verschlüsselte Dateisystem
	    ein:</para>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	</step>

	<step>
	  <title>Überprüfen des verschlüsselten
	    Dateisystems</title>

	  <para>Das verschlüsselte Dateisystem sollte jetzt
	    von &man.df.1; erkannt werden und benutzt werden
	    können.</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>

    <sect3>
      <title>Einhängen eines existierenden verschlüsselten
	Dateisystems</title>

      <para>Nach jedem Neustart müssen verschlüsselte
	Dateisysteme dem Kernel wieder bekannt gemacht werden,
	auf Fehler überprüft werden und eingehangen
	werden.  Die dazu nötigen Befehle müssen als
	<systemitem class="username">root</systemitem> durchgeführt werden.</para>

      <procedure>
	<step>
	  <title>gbde-Partition im Kernel bekannt geben</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>Dieses Kommando fragt nach der Passphrase, die
	    während der Initialisierung der verschlüsselten
	    <application>gbde</application>-Partition festgelegt
	    wurde.</para>
	</step>

	<step>
	  <title>Prüfen des Dateisystems</title>

	  <para>Das verschlüsselte Dateisystem kann noch nicht
	    automatisch über <filename>/etc/fstab</filename>
	    eingehangen werden.  Daher muss es vor dem Einhängen
	    mit &man.fsck.8; geprüft werden:</para>

	  <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
	  <title>Einhängen des verschlüsselten
	    Dateisystems</title>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>

	  <para>Das verschlüsselte Dateisystem steht danach
	    zur Verfügung.</para>
	</step>
      </procedure>

	<para>Mit einem Skript können verschlüsselte
	  Dateisysteme automatisch bekannt gegeben, geprüft
	  und eingehangen werden.  Wir raten Ihnen allerdings
	  aus Sicherheitsgründen davon ab.  Starten Sie das
	  Skript manuell an der Konsole oder in einer
	  &man.ssh.1;-Sitzung.</para>

	<para>Alternativ existiert ein
	  <filename>rc.d</filename>-Skript, an das über
	  Einträge in &man.rc.conf.5; Argumente übergeben werden
	  können:</para>

	<programlisting>gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"</programlisting>

	<para>Durch diese Argumente muss beim Systemstart die
	  <application>gbde</application>-Passphrase eingegeben werden.
	  Erst nach Eingabe der korrekten Passphrase wird die
	  <application>gbde</application>-verschlüsselte
	  Partition automatisch in den Verzeichnisbaum
	  eingehängt.  Dieses Vorgehen ist
	  nützlich, wenn <application>gbde</application> auf
	  einem Laptop eingesetzt wird.</para>
      </sect3>
    </sect2>

    <sect2>
      <info><title>Plattenverschlüsselung mit <command>geli</command></title>
	<authorgroup>
	  <author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      

      <para>Mit <command>geli</command> ist eine alternative
	kryptografische GEOM-Klasse verfügbar.
	<command>geli</command> unterscheidet sich von
	<command>gbde</command> durch unterschiedliche Fähigkeiten und
	einen unterschiedlichen Ansatz für die Verschlüsselung.</para>

      <para>Die wichtigsten Merkmale von &man.geli.8; sind:</para>

      <itemizedlist>
	<listitem>
	  <para>Die Nutzung des &man.crypto.9;-Frameworks.  Wenn das
	    System über kryptografische Hardware verfügt, wird diese
	    von <command>geli</command> automatisch verwendet.</para>
	</listitem>

	<listitem>
	  <para>Die Unterstützung verschiedener kryptografischer
	    Algorithmen, wie beispielsweise AES, Blowfish, und
	    3DES.</para>
	</listitem>

	<listitem>
	  <para>Die Möglichkeit, die root-Partition zu
	    verschlüsseln.  Um auf die verschlüsselte
	    root-Partition zugreifen zu können, muss beim
	    Systemstart die Passphrase eingegeben werden.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> erlaubt den Einsatz von zwei
	    voneinander unabhängigen Schlüsseln, etwa einem
	    privaten <quote>Schlüssel</quote> und einem
	    <quote>Unternehmens-Schlüssel</quote>.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> ist durch einfache
	    Sektor-zu-Sektor-Verschlüsselung sehr schnell.</para>
	</listitem>

	<listitem>
	  <para>Die Möglichkeit, Master-Keys zu sichern und
	    wiederherzustellen.  Wenn ein Benutzer seinen Schlüssel
	    zerstört, kann er über seinen zuvor gesicherten
	    Schlüssel wieder auf seine Daten zugreifen.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> erlaubt es, Platten mit
	    einem zufälligen Einmal-Schlüssel einzusetzen,
	    was für Swap-Partitionen und
	    temporäre Dateisysteme interessant ist.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Merkmale von
	<command>geli</command> finden Sie in &man.geli.8;.</para>

      <para>Dieser Abschnitt beschreibt, wie <command>geli</command>
	im &os;-Kernel aktiviert wird und wie ein
	<command>geli</command>-Verschlüsselungs-Provider
	angelegt wird.</para>

      <para>Da der Kernel angepasst werden muss, werden
	<systemitem class="username">root</systemitem>-Privilegien
	benötigt.</para>

      <procedure>
	<step>
	  <title>Aufnahme der <command>geli</command>-Unterstützung
	    in Ihre Kernelkonfigurationsdatei</title>

	  <para>Stellen Sie bei einer angepassten
	    Kernelkonfigurationsdatei sicher, dass diese Zeile
	    enthalten ist:</para>

	  <programlisting>options GEOM_ELI
device crypto</programlisting>

	  <para>Alternativ kann auch das
	    <command>geli</command>-Kernelmodul beim Systemstart
	    geladen werden, indem folgende Zeile in
	    <filename>/boot/loader.conf</filename> eingefügt
	    wird:</para>

	  <programlisting>geom_eli_load="YES"</programlisting>

	  <para>Ab sofort wird &man.geli.8; vom Kernel
	    unterstützt.</para>
	</step>

	<step>
	  <title>Erzeugen des Master-Keys</title>

	  <para>Das folgende Beispiel beschreibt, wie eine
	    Schlüsseldatei erzeugt wird, die als Teil des
	    Master-Keys für den Verschlüsselungs-Provider
	    verwendet wird, der unter <filename>/private</filename>
	    in den Verzeichnisbaum eingehängt wird.  Die
	    Schlüsseldatei liefert zufällige Daten, die für die
	    Verschlüsselung des Master-Keys benutzt werden.
	    Zusätzlich wird  der Master-Key durch eine Passphrase
	    geschützt.  Die Sektorgröße des Providers beträgt
	    4&nbsp;KB.  Das Beispiel beschreibt, wie Sie einen
	    <command>geli</command>-Provider aktivieren, ein vom ihm
	    verwaltetes Dateisystem erzeugen, es mounten, mit ihm
	    arbeiten und wie Sie es schließlich wieder unmounten
	    und den Provider deaktivieren.</para>

	  <para>Um eine bessere Leistung zu erzielen, wird eine
	    größere Sektorgröße, beispielsweise 4&nbsp;KB,
	    empfohlen.</para>

	  <para>Der Master-Key wird durch eine Passphrase sowie, den
	    Daten der Schlüsseldatei aus
	    <filename>/dev/random</filename> geschützt.
	    Die Sektorgröße des Providers
	    <filename>/dev/<replaceable>da2</replaceable>.eli</filename>
	    beträgt 4&nbsp;KB.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/root/da2.key bs=64 count=1</userinput>
&prompt.root; <userinput>geli init -s 4096 -K /root/da2.key /dev/da2</userinput>
Enter new passphrase:
Reenter new passphrase:</screen>

	  <para>Es ist nicht zwingend nötig, sowohl eine Passphrase
	    als auch eine Schlüsseldatei zu verwenden.  Die
	    einzelnen Methoden können auch unabhängig
	    voneinander eingesetzt werden.</para>

	  <para>Wird für die Schlüsseldatei
	    <quote>-</quote> angegeben, wird dafür die
	    Standardeingabe verwendet.  Das folgende Beispiel zeigt,
	    dass auch mehr als eine Schlüsseldatei verwendet werden
	    kann:</para>

	  <screen>&prompt.root; <userinput>cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</userinput></screen>
	</step>

	<step>
	  <title>Aktivieren des Providers mit dem erzeugten
	    Schlüssel</title>

	  <screen>&prompt.root; <userinput>geli attach -k /root/da2.key /dev/da2</userinput>
Enter passphrase:</screen>

	  <para>Dadurch wird die (Normaltext-)Gerätedatei
	    <filename>/dev/da2.eli</filename>
	    angelegt.</para>

	  <screen>&prompt.root; <userinput>ls /dev/da2*</userinput>
/dev/da2  /dev/da2.eli</screen>
	</step>

	<step>
	  <title>Das neue Dateisystem erzeugen</title>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/da2.eli bs=1m</userinput>
&prompt.root; <userinput>newfs /dev/da2.eli</userinput>
&prompt.root; <userinput>mount /dev/da2.eli /private</userinput></screen>

	<para>Das verschlüsselte Dateisystem wird nun von
	  &man.df.1; angezeigt und kann ab sofort eingesetzt werden.</para>

	  <screen>&prompt.root; <userinput>df -H</userinput>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</screen>

	</step>

	<step>
	  <title>Das Dateisystem unmounten und den Provider deaktivieren</title>

	  <para>Wenn Sie nicht mehr mit dem verschlüsselten
	    Dateisystem arbeiten und die unter <filename>/private</filename> eingehängte
	    Partition daher nicht mehr benötigen,  sollten
	    Sie diese unmounten und den
	    <command>geli</command>-Verschlüsselungs-Provider
	    wieder deaktivieren:</para>

	  <screen>&prompt.root; <userinput>umount /private</userinput>
&prompt.root; <userinput>geli detach da2.eli</userinput></screen>
	</step>
      </procedure>

      <para>Weitere Informationen zum Einsatz von
	<command>geli</command> finden Sie in &man.geli.8;.</para>

      <sect3>
	<title>Der Einsatz des <filename>geli</filename>-
	  <filename>rc.d</filename>-Skripts</title>

	<para><command>geli</command> verfügt über ein
	  <filename>rc.d</filename>-Skript,
	  das den Einsatz von <command>geli</command>
	  deutlich vereinfacht.  Es folgt nun ein Beispiel, in dem
	  <command>geli</command> über die Datei
	  &man.rc.conf.5; konfiguriert wird:</para>

	<programlisting>geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"</programlisting>

	<para>Durch diese Einträge wird
	  <filename>/dev/da2</filename> als
	  <command>geli</command>-Provider festgelegt.  Der Master-Key
	  befindet sich in <filename>/root/da2.key</filename>.  Beim
	  Aktivieren des <command>geli</command>-Providers wird keine
	  Passphrase abgefragt.  Beachten Sie, dass dies nur dann
	  möglich ist, wenn <command>geli</command> mit dem
	  Parameter <option>-P</option> initialisiert wurde.  Wird das
	  System heruntergefahren, wird der
	  <literal>geli</literal>-Provider zuvor deaktiviert.</para>

	<para>Weitere Informationen zur Konfiguration der
	  <filename>rc.d</filename>-Skripten
	  finden Sie im Abschnitt <link linkend="configtuning-rcd">rc.d</link> des Handbuchs.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="swap-encrypting">
    <info><title>Den Auslagerungsspeicher verschlüsseln</title>
      <authorgroup>
	<author><personname><firstname>Christian</firstname><surname>Brüffer</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Auslagerungsspeicher</primary>
      <secondary>verschlüsseln</secondary>
    </indexterm>

    <para>Wie die Verschlüsselung von Partitionen, wird auch der
      Auslagerungsspeicher verschlüsselt, um sensible Informationen
      zu schützen.  Stellen Sie sich eine Anwendung vor, die mit
      Passwörtern umgeht.  Solange sich diese Passwörter im
      Arbeitsspeicher befinden, werden sie nicht auf die Festplatte
      geschrieben und nach einem Neustart gelöscht.  Falls &os; jedoch
      damit beginnt Speicher auszulagern, um Platz für andere
      Anwendungen zu schaffen, können die Passwörter unverschlüsselt
      auf die Festplatte geschrieben werden.  Die Verschlüsselung des
      Auslagerungsspeichers kann in solchen Situationen Abhilfe
      schaffen.</para>

    <para>Das
      &man.gbde.8;- oder das &man.geli.8;-Verschlüsselungs-Subsystem
      kann für die Verschlüsselung des Auslagerungsspeichers
      eingesetzt werden.  Beide Subsysteme nutzen das
      <filename>encswap</filename>
      <link linkend="configtuning-rcd">rc.d</link>-Skript.</para>

    <note>
      <para>Für den Rest dieses Abschnitts wird
	<filename>ad0s1b</filename> die Swap-Partition
	darstellen.</para>
    </note>

    <para>Swap-Partitionen werden standardmäßig nicht verschlüsselt.
      Sie sollten daher alle sensiblen Daten im Auslagerungsspeicher
      löschen, bevor Sie fortfahren.  Führen Sie folgenden Befehl aus,
      um die Swap-Partition mit Zufallsdaten zu überschreiben:</para>

    <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/<replaceable>ad0s1b</replaceable> bs=1m</userinput></screen>

    <sect2>
      <title>Den Auslagerungsspeicher mit &man.gbde.8;
	verschlüsseln</title>

      <para>In der Datei <filename>/etc/fstab</filename> sollte
	das Suffix <literal>.bde</literal> an den Gerätenamen
	der Swap-Partition anhängt werden:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.bde         none            swap    sw              0       0</programlisting>
    </sect2>

    <sect2>
      <title>Den Auslagerungsspeicher mit &man.geli.8;
	verschlüsseln</title>

      <para>Die Vorgehensweise für die Verschlüsselung des
	Auslagerungsspeichers mit &man.geli.8; ist der von
	&man.gbde.8; sehr ähnlich.  Bei der Verwendung
	von &man.geli.8; in <filename>/etc/fstab</filename> wird das
	Suffix <literal>.eli</literal> an den Gerätenamen der
	Swap-Partition angehangen:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.eli         none            swap    sw              0       0</programlisting>

      <para>In der Voreinstellung verschlüsselt &man.geli.8; den
	Auslagerungsspeicher mit dem <acronym>AES</acronym>-Algorithmus
	und einer Schlüssellänge von 128 Bit.  Diese Voreinstellungen
	können mittels <literal>geli_swap_flags</literal> in
	<filename>/etc/rc.conf</filename> angepasst werden.  Die
	folgende Zeile weist das rc.d-Skript
	<filename>encswap</filename> an, &man.geli.8;-Swap-Partitionen
	mit dem Blowfish-Algorithmus und einer Schlüssellänge von
	128&nbsp;Bit zu verschlüsseln.  Zusätzlich wird die
	Sektorgröße auf 4&nbsp;Kilobyte gesetzt und
	<quote>detach on last close</quote> aktiviert:</para>

      <programlisting>geli_swap_flags="-e blowfish -l 128 -s 4096 -d"</programlisting>

      <para>Eine Auflistung möglicher Optionen für
	<command>onetime</command> finden Sie in der Manualpage von
	&man.geli.8;.</para>
    </sect2>

    <sect2>
      <title>Überprüfung des verschlüsselten
	Auslagerungsspeichers</title>

      <para>Nachdem das System neu gestartet wurde, kann die korrekte
	Funktion des verschlüsselten Auslagerungsspeichers mit
	<command>swapinfo</command> geprüft werden.</para>

      <para>Wenn Sie &man.gbde.8; einsetzen, erhalten Sie eine
	Meldung ähnlich der folgenden:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%</screen>

      <para>Wenn Sie &man.geli.8; einsetzen, erhalten Sie hingegen
	eine Ausgabe ähnlich der folgenden:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-hast">
    <info><title>Highly Available Storage (HAST)</title>
      <authorgroup>
	<author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Freddie</firstname><surname>Cash</surname></personname><contrib>Mit Beiträgen von </contrib></author>
	<author><personname><firstname>Pawel Jakub</firstname><surname>Dawidek</surname></personname></author>
	<author><personname><firstname>Michael W.</firstname><surname>Lucas</surname></personname></author>
	<author><personname><firstname>Viktor</firstname><surname>Petersson</surname></personname></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>HAST</primary>
      <secondary>high availability</secondary>
    </indexterm>

      <para>Hochverfügbarkeit ist eine der Hauptanforderungen von
        ernsthaften Geschäftsanwendungen und hochverfügbarer Speicher
        ist eine Schlüsselkomponente in solchen Umgebungen.  Highly
        Available STorage, oder <acronym>HAST<remark role="acronym">Highly Available STorage</remark></acronym>, wurde von
        &a.pjd.email; als ein Framework entwickelt, welches die transparente
        Speicherung der gleichen Daten über mehrere physikalisch getrennte
        Maschinen ermöglicht, die über ein TCP/IP-Netzwerk verbunden
        sind.  <acronym>HAST</acronym> kann als ein netzbasiertes RAID1
        (Spiegel) verstanden werden und ist dem DRBD&reg;-Speichersystem der
        GNU/&linux;-Plattform ähnlich.  In Kombination mit anderen
        Hochverfügbarkeitseigenschaften von &os;
        wie <acronym>CARP</acronym>, ermöglicht es
        <acronym>HAST</acronym>, hochverfügbare Speichercluster zu bauen,
        die in der Lage sind, Hardwareausfällen zu widerstehen.</para>

      <para>Nachdem Sie diesen Abschnitt gelesen haben, werden Sie folgendes
        wissen:</para>

      <itemizedlist>
	<listitem>
	  <para>Was <acronym>HAST</acronym> ist, wie es funktioniert und
	    welche Eigenschaften es besitzt.</para>
	</listitem>
	<listitem>
	  <para>Wie man <acronym>HAST</acronym> auf &os; aufsetzt und
	    verwendet.</para>
	</listitem>
	<listitem>
	  <para>Wie man <acronym>CARP</acronym> und &man.devd.8; kombiniert, um
	    ein robustes Speichersystem zu bauen.</para>
 	</listitem>
      </itemizedlist>

      <para>Bevor Sie diesen Abschnitt lesen, sollten Sie:</para>

      <itemizedlist>
	<listitem>
	  <para>die Grundlagen von &unix; und &os; verstanden haben
	    (<xref linkend="basics"/>).</para>
	</listitem>
	<listitem>
	  <para>wissen, wie man Netzwerkschnittstellen und andere Kernsysteme
	    von &os; konfiguriert (<xref linkend="config-tuning"/>).</para>
	</listitem>
	<listitem>
	  <para>ein gutes Verständnis der &os;-Netzwerkfunktionalität
	    besitzen (<xref linkend="network-communication"/>).</para>
	</listitem>
      </itemizedlist>

      <para>Das <acronym>HAST</acronym>-Projekt wurde von der &os; Foundation
        mit Unterstützung der <link xlink:href="http://www.omc.net/">OMCnet Internet Service GmbH</link> und
        <link xlink:href="http://www.transip.nl/">TransIP BV</link>
        gesponsert.</para>

    <sect2>
      <title>HAST-Merkmale</title>

      <para>Die Hauptmerkmale des <acronym>HAST</acronym>-Systems sind:</para>

      <itemizedlist>
        <listitem>
	  <para>Es kann zur Maskierung von I/O-Fehlern auf lokalen Festplatten
	    eingesetzt werden.</para>
	</listitem>
	<listitem>
	  <para>Dateisystem-unabhängig, was es erlaubt, jedes von &os;
	    unterstützte Dateisystem zu verwenden.</para>
	</listitem>
	<listitem>
	  <para>Effiziente und schnelle Resynchronisation: es werden nur die
	    Blöcke synchronisiert, die während der Ausfallzeit eines
	    Knotens geändert wurden.</para>
	</listitem>
	<!--
        <listitem>
	  <para>Besitzt mehrere Synchronisationsmodi, um eine schnelle
	    Übergabe an einen anderen Knoten (sog. failover) zu
	    ermöglichen.</para>
	</listitem>
	-->
	<listitem>
	  <para>Es kann in einer bereits bestehenden Umgebung eingesetzt
	    werden, um zusätzliche Redundanz zu erreichen.</para>
	</listitem>
	<listitem>
	  <para>Zusammen mit <acronym>CARP</acronym>,
	    <application>Heartbeat</application>, oder anderen Werkzeugen, ist
	    es möglich, ein robustes und dauerhaftes Speichersystem zu
	    bauen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>HAST im Einsatz</title>

      <para><acronym>HAST</acronym> stellt auf Block-Ebene eine synchrone
        Replikation eines beliebigen Speichermediums auf mehreren Maschinen zur
	Verfügung.  Daher werden mindestens zwei physikalische
	Maschinen benötigt: der <literal>primary</literal>, auch
	bekannt als <literal>master</literal> Knoten, sowie der
	<literal>secondary</literal>, oder <literal>slave</literal>
	Knoten.  Diese beiden Maschinen zusammen werden als Cluster
	bezeichnet.</para>

      <note>
	<para>HAST ist momentan auf insgesamt zwei Knoten im Cluster
	  beschränkt.</para>
      </note>

      <para>Da <acronym>HAST</acronym> in einer
        primär-sekundär-Konfiguration funktioniert, ist immer nur ein
        Knoten des Clusters zu jeder Zeit aktiv.  Der
        <literal>primäre</literal> Knoten, auch
        <literal>active</literal> genannt, ist derjenige, der alle I/O-Anfragen
	verarbeitet, die an die <acronym>HAST</acronym>-Schnittstelle gesendet
	werden.  Der <literal>secondary</literal>-Knoten wird automatisch vom
	<literal>primary</literal>-Knoten aus synchronisiert.</para>

      <para>Die physischen Komponenten des <acronym>HAST</acronym>-Systems
        sind:</para>

      <itemizedlist>
	<listitem>
	  <para>lokale Platte am Primärknoten</para>
	</listitem>
	<listitem>
	  <para>entfernte Platte am Sekundärknoten</para>
	</listitem>
      </itemizedlist>

      <para><acronym>HAST</acronym> arbeitet synchron auf Blockebene,
	was es für Dateisysteme und Anwendungen transparent macht.
        <acronym>HAST</acronym> stellt gewöhnliche GEOM-Provider in
	<filename>/dev/hast/</filename> für die Verwendung durch
	andere Werkzeuge oder Anwendungen zur Verfügung.  Somit gibt
	es keinen Unterschied zwischen dem Einsatz von
	<acronym>HAST</acronym> bereitgestellten Geräten und
        herkömmlichen Platten, Partitionen, etc.</para>

      <para>Jede Schreib-, Lösch- oder Entleerungsoperation wird an die
        lokale und über TCP/IP zu der entfernt liegenden
        Platte gesendet.  Jede Leseoperation wird von der lokalen Platte
        durchgeführt, es sei denn, die lokale Platte ist nicht aktuell
        oder es tritt ein I/O-Fehler auf.  In solchen Fällen wird die
        Leseoperation an den Sekundärknoten geschickt.</para>

	<para><acronym>HAST</acronym> versucht, eine schnelle Fehlerbereinigung
	  zu gewährleisten.  Aus diesem Grund ist es sehr wichtig, die
	  Synchronisationszeit nach dem Ausfall eines Knotens zu reduzieren.
	  Um eine schnelle Synchronisation zu ermöglichen, verwaltet
	  <acronym>HAST</acronym> eine Bitmap von unsauberen Bereichen
	  auf der Platte und synchronisiert nur diese während einer
	  regulären Synchronisation (mit Ausnahme der initialen
	  Synchronisation).</para>

	<para>Es gibt viele Wege, diese Synchronisation zu behandeln.
	  <acronym>HAST</acronym> implementiert mehrere Replikationsarten, um
	  unterschiedliche Methoden der Synchronisation zu realisieren:</para>

	<itemizedlist>
	  <listitem>
	    <para><emphasis>memsync</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn die lokale Schreiboperation beendet ist
	      und der entfernt liegende Knoten die Ankunft der Daten
	      bestätigt hat, jedoch bevor die Daten wirklich gespeichert
	      wurden.  Die Daten werden auf dem entfernt liegenden Knoten
	      direkt nach dem Senden der Bestätigung gespeichert.  Dieser
	      Modus ist dafür gedacht, Latenzen zu verringern und
	      zusätzlich eine gute Verlässlichkeit zu bieten.</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>fullsync</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn die lokale Schreiboperation beendet ist
	      und die entfernte Schreiboperation ebenfalls abgeschlossen wurde.
	      Dies ist der sicherste und zugleich der langsamste
	      Replikationsmodus.  Er stellt den momentanen Standardmodus
	      dar.</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>async</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn lokale Schreibvorgänge abgeschlossen
	      wurden.  Dies ist der schnellste und gefährlichste
	      Replikationsmodus.  Er sollte verwendet werden, wenn die Latenz
	      zu einem entfernten Knoten bei einer Replikation zu hoch ist
	      für andere Modi.</para>
	  </listitem>
	</itemizedlist>
    </sect2>

    <sect2>
      <title>HAST-Konfiguration</title>

      <para><acronym>HAST</acronym> benötigt
	<literal>GEOM_GATE</literal>-Unterstützung, welche
	standardmäßig nicht im <literal>GENERIC</literal>-Kernel
	enthalten ist.  Jedoch ist in der Standardinstallation von
	&os; <filename>geom_gate.ko</filename> als ladbares Modul
	vorhanden.  Alternativ lässt sich die
	<literal>GEOM_GATE</literal>-Unterstützung in den Kernel
	statisch einbauen, indem folgende Zeile zur
	Kernelkonfigurationsdatei hinzugefügt wird:</para>

      <programlisting>options	GEOM_GATE</programlisting>

      <para>Das <acronym>HAST</acronym>-Framework besteht aus Sicht des
        Betriebssystems aus mehreren Bestandteilen:</para>

      <itemizedlist>
        <listitem>
	  <para>Dem &man.hastd.8;-Daemon, welcher für
	    Datensynchronisation verantwortlich ist,</para>
	</listitem>
	<listitem>
	  <para>Dem &man.hastctl.8; Management-Werkzeug,</para>
	</listitem>
	<listitem>
	  <para>Der Konfigurationsdatei &man.hast.conf.5;.</para>
	</listitem>
      </itemizedlist>

      <para>Das folgende Beispiel beschreibt, wie man zwei Knoten als
        <literal>master</literal>-<literal>slave</literal> /
        <literal>primary</literal>-<literal>secondary</literal> mittels
        <acronym>HAST</acronym> konfiguriert, um Daten zwischen diesen beiden
        auszutauschen.  Die Knoten werden als
	<literal><replaceable>hasta</replaceable></literal> mit der IP-Adresse
        <replaceable>172.16.0.1</replaceable> und
	<literal><replaceable>hastb</replaceable></literal> mit der IP-Adresse
        <replaceable>172.16.0.2</replaceable> bezeichnet.  Beide Knoten
        besitzen eine dedizierte Festplatte
	<filename>/dev/<replaceable>ad6</replaceable></filename> mit der
        gleichen Grösse für den <acronym>HAST</acronym>-Betrieb.
	Der <acronym>HAST</acronym>-Pool, manchmal auch Ressource
	genannt, oder der GEOM-Provider in
	<filename>/dev/hast/</filename> wird als
	<filename><replaceable>test</replaceable></filename> bezeichnet.</para>

      <para>Die Konfiguration von <acronym>HAST</acronym> wird in
        <filename>/etc/hast.conf</filename> vorgenommen.  Diese Datei sollte
        auf beiden Knoten gleich sein.  Die denkbar einfachste Konfiguration
        ist folgende:</para>

      <programlisting>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</programlisting>

      <para>Fortgeschrittene Konfigurationsmöglichkeiten finden Sie in
	&man.hast.conf.5;.</para>

      <tip>
	<para>Es ist ebenfalls möglich, den Hostnamen in den
	  <literal>remote</literal>-Anweisungen zu verwenden.  Stellen Sie in
	  solchen Fällen sicher, dass diese Rechner auch aufgelöst
	  werden können und in <filename>/etc/hosts</filename>, oder
	  im lokalen <acronym>DNS</acronym> definiert sind.</para>
      </tip>

      <para>Da nun die Konfiguration auf beiden Rechnern vorhanden
	ist, kann ein <acronym>HAST</acronym>-Pool erstellt werden.
	Lassen Sie diese Kommandos auf beiden Knoten ablaufen, um die
	initialen Metadaten auf die lokale Platte zu schreiben und
	starten Sie anschliessend &man.hastd.8;:</para>

      <screen>&prompt.root; <userinput>hastctl create test</userinput>
&prompt.root; <userinput>service hastd onestart</userinput></screen>

      <note>
	<para>Es ist <emphasis>nicht</emphasis> möglich, GEOM-Provider
	  mit einem bereits bestehenden Dateisystem zu verwenden, um
	  beispielsweise einen bestehenden Speicher in einen von
	  <acronym>HAST</acronym> verwalteten Pool zu konvertieren.
	  Dieses Verfahren muss einige Metadaten auf den Provider
	  schreiben und dafür würde nicht genug freier Platz zur
	  Verfügung stehen.</para>
      </note>

      <para>Die Rolle eines HAST Knotens, <literal>primary</literal>
	oder <literal>secondary</literal>, wird vom einem
	Administrator, oder einer Software wie
	<application>Heartbeat</application>, mittels
	&man.hastctl.8; festgelegt.  Auf dem primären
	Knoten <literal><replaceable>hasta</replaceable></literal>
	geben Sie diesen Befehl ein:</para>

      <screen>&prompt.root; <userinput>hastctl role primary test</userinput></screen>

      <para>Geben Sie folgendes Kommando auf dem sekundären
	Knoten <literal><replaceable>hastb</replaceable></literal>
	ein:</para>

      <screen>&prompt.root; <userinput>hastctl role secondary test</userinput></screen>

      <caution>
	<para>Es kann passieren, dass beide Knoten nicht in der Lage
	  sind, miteinander zu kommunizieren und dadurch beide als
	  primäre Knoten konfiguriert sind; die Konsequenz daraus wird
	  als <literal>split-brain</literal> bezeichnet.  Um diese
	  Situation zu bereinigen, folgen Sie den Schritten, die
	  in <xref linkend="disks-hast-sb"/> beschrieben sind.</para>
      </caution>

      <para>Überprüfen Sie das Ergebnis mit &man.hastctl.8; auf beiden
        Knoten:</para>

      <screen>&prompt.root; <userinput>hastctl status test</userinput></screen>

      <para>Der wichtigste Teil ist die
	<literal>status</literal>-Textzeile, die auf jedem Knoten
	<literal>complete</literal> lauten sollte.  Falls der Status
	als <literal>degraded</literal> zurückgemeldet wird, ist etwas
	schief gegangen.  Zu diesem Zeitpunkt hat die Synchronisation
	zwischen den beiden Knoten bereits begonnen.  Die
	Synchronisation ist beendet, wenn
	<command>hastctl status</command> meldet, dass die
	<literal>dirty</literal>-Bereiche 0 Bytes betragen.</para>

      <para>Der nächste Schritt ist, ein Dateisystem auf dem
	<filename>/dev/hast/<replaceable>test</replaceable></filename> GEOM-Provider anzulegen
	und dieses ins System einzuhängen.  Dies muss auf dem
	<literal>primary</literal>-Knoten durchgeführt werden, da
	<filename>/dev/hast/<replaceable>test</replaceable></filename> nur auf dem
	<literal>primary</literal>-Knoten erscheint.  Die Erstellung
	des Dateisystems kann ein paar Minuten dauern, abhängig von
	der Größe der Festplatte:</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/hast/test</userinput>
&prompt.root; <userinput>mkdir /hast/test</userinput>
&prompt.root; <userinput>mount /dev/hast/test /hast/test</userinput></screen>

      <para>Sobald das <acronym>HAST</acronym>-Framework richtig
	konfiguriert wurde, besteht der letzte Schritt nun darin,
	sicherzustellen, dass <acronym>HAST</acronym> während des
	Systemstarts automatisch gestartet wird.  Fügen Sie diese
	Zeile in <filename>/etc/rc.conf</filename> hinzu:</para>

      <programlisting>hastd_enable="YES"</programlisting>

      <sect3>
	<title>Failover-Konfiguration</title>

	<para>Das Ziel dieses Beispiels ist, ein robustes
	  Speichersystem zu bauen, welches Fehlern auf einem
	  beliebigen Knoten widerstehen kann.  Das Szenario besteht
	  darin, dass der <literal>primary</literal>-Knoten des
	  Clusters ausfällt.  Sollte das passieren, ist der
	  <literal>secondary</literal>-Knoten da, um nahtlos
	  einzuspringen, das Dateisystem zu prüfen, einzuhängen und
	  mit der Arbeit fortzufahren, ohne dass auch nur ein
	  einzelnes Bit an Daten verloren geht.</para>

	<para>Um diese Aufgabe zu bewerkstelligen, wird eine
	  weitere Eigenschaft von &os; benutzt,
	  <acronym>CARP</acronym>,  welches ein automatisches Failover
	  auf der IP-Schicht ermöglicht.
	  <acronym>CARP</acronym> (Common Address Redundancy Protocol)
	  erlaubt es mehreren Rechnern im gleichen Netzsegment, die
	  gleiche IP-Adresse zu verwenden.  Setzen Sie
	  <acronym>CARP</acronym> auf beiden Knoten des Clusters
	  anhand der Dokumentation in <xref linkend="carp"/> auf.
	  Nach der Konfiguration wird jeder Knoten seine eigene
	  <filename>carp0</filename>-Schnittstelle, mit der geteilten
	  IP-Adresse <replaceable>172.16.0.254</replaceable> besitzen.
	  Der primäre <acronym>HAST</acronym>-Knoten des Clusters muss
	  der <acronym>CARP</acronym>-Masterknoten sein.</para>

	<para>Der <acronym>HAST</acronym>-Pool, welcher im vorherigen Abschnitt
	  erstellt wurde, ist nun bereit für den Export über das
	  Netzwerk auf den anderen Rechner.  Dies kann durch den Export
	  über <acronym>NFS</acronym> oder <application>Samba</application>
	  erreicht werden, indem die geteilte IP-Addresse
	  <replaceable>172.16.0.254</replaceable> verwendet wird.  Das einzige
	  ungelöste Problem ist der automatische Failover, sollte der
	  primäre Knoten einmal ausfallen.</para>

	<para>Falls die <acronym>CARP</acronym>-Schnittstelle
	  aktiviert oder deaktiviert wird, generiert das
	  &os;-Betriebssystem ein &man.devd.8;-Ereignis, was es
	  ermöglicht, Zustandsänderungen auf den
	  <acronym>CARP</acronym>-Schnittstellen zu überwachen.  Eine
	  Zustandsänderung auf der
	  <acronym>CARP</acronym>-Schnittstelle ist ein Indiz dafür,
	  dass einer der Knoten gerade ausgefallen oder wieder
	  verfügbar ist.  Diese Zustandsänderungen machen es möglich,
	  ein Skript zu starten, welches automatisch den HAST-Failover
	  durchführt.</para>

	<para>Um  Zustandsänderungen auf der
	  <acronym>CARP</acronym>-Schnittstelle abzufangen, müssen
	  diese Zeilen in <filename>/etc/devd.conf</filename> auf
	  jedem Knoten hinzugefügt werden:</para>

	<programlisting>notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};</programlisting>

	<para>Starten Sie &man.devd.8; auf beiden Knoten neu, um
	  die neue Konfiguration wirksam werden zu lassen:</para>

	<screen>&prompt.root; <userinput>service devd restart</userinput></screen>

	<para>Wenn die <filename>carp0</filename>-Schnittstelle
	  aktiviert oder deaktiviert wird, erzeugt das System eine
	  Meldung, was es dem &man.devd.8;-Subsystem ermöglicht, ein
	  beliebiges Skript zu starten, in diesem Fall also
	  <filename>/usr/local/sbin/carp-hast-switch</filename>.
	  Dieses Skript führt den automatischen Failover durch.
	  Weitere Informationen zu der obigen
	  &man.devd.8;-Konfiguration, finden Sie in
	  &man.devd.conf.5;.</para>

	<para>Ein Beispiel für ein solches Skript könnte so
	  aussehen:</para>

<programlisting>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources="test"

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	master)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."


		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac</programlisting>

	<para>Im Kern führt das Skript die folgenden Aktionen durch,
	  sobald ein Knoten zum <literal>master</literal> /
	  <literal>primary</literal> wird:</para>

	<itemizedlist>
	  <listitem>
	    <para>Es ernennt den <acronym>HAST</acronym>-Pool als den
	      primären für einen gegebenen Knoten.</para>
	  </listitem>
	  <listitem>
	    <para>Es prüft das Dateisystem, dass auf dem
	      <acronym>HAST</acronym>-Pool erstellt wurde.</para>
	  </listitem>
	  <listitem>
	    <para>Es hängt die Pools an die richtige Stelle im System
	      ein.</para>
	  </listitem>
	</itemizedlist>

	<para>Wenn ein Knoten zum <literal>backup</literal> /
	  <literal>secondary</literal> ernannt wird:</para>

	<itemizedlist>
	  <listitem>
	    <para>Hängt es den <acronym>HAST</acronym>-Pool aus dem
	      Dateisystem aus.</para>
	  </listitem>
	  <listitem>
	    <para>Degradiert es den <acronym>HAST</acronym>-Pool zum
	      sekundären.</para>
	  </listitem>
	</itemizedlist>

	<caution>
	  <para>Bitte beachten Sie, dass dieses Skript nur ein Beispiel
	    für eine mögliche Lösung darstellt.  Es behandelt
	    nicht alle möglichen Szenarien, die auftreten können und
	    sollte erweitert bzw. abgeändert werden, so dass z.B.
	    benötigte Dienste gestartet oder gestoppt werden.</para>
	</caution>

	<tip>
	  <para>Für dieses Beispiel wurde ein Standard-UFS Dateisystem
	    verwendet.  Um die Zeit für die Wiederherstellung zu
	    verringern, kann ein UFS mit Journal oder ein ZFS-Dateisystem
	    benutzt werden.</para>
	</tip>

	<para>Weitere detaillierte Informationen mit zusätzlichen
	  Beispielen können auf der <link xlink:href="http://wiki.FreeBSD.org/HAST">HAST Wiki</link>-Seite
	  abgerufen werden.</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Fehlerbehebung</title>

	<para><acronym>HAST</acronym> sollte generell ohne Probleme
	  funktionieren. Jedoch kann es, wie bei jeder anderen Software auch,
	  zu gewissen Zeiten sein, dass sie sich nicht so verhält wie
	  angegeben.  Die Quelle dieser Probleme kann unterschiedlich sein,
	  jedoch sollte als Faustregel gewährleistet werden, dass die
	  Zeit für beide Knoten im Cluster synchron läuft.</para>

	<para>Für die Fehlersuche bei Problemen mit
	  <acronym>HAST</acronym> sollte die Anzahl an
	  Debugging-Meldungen von &man.hastd.8; erhöht werden.  Dies
	  kann durch das Starten des &man.hastd.8; mit
	  <literal>-d</literal> erreicht werden.  Diese Option kann 
	  mehrfach angegeben werden, um die Anzahl an Meldungen weiter
	  zu erhöhen.  Auf diese Weise erhalten Sie viele nützliche
	  Informationen.  Sie sollten ebenfalls die Verwendung von
	  <literal>-F</literal> in Erwägung ziehen, die
	  &man.hastd.8; im Vordergrund startet.</para>

      <sect3 xml:id="disks-hast-sb">
	<title>Auflösung des Split-brain-Zustands</title>

	<para><literal>split-brain</literal> bezeichnet eine
	  Situation, in der beide Knoten des Clusters nicht in der
	  Lage sind, miteinander zu kommunizieren und dadurch beide
	  als primäre Knoten fungieren.  Dies ist ein
	  gefährlicher Zustand, weil es beiden Knoten erlaubt ist,
	  Änderungen an den Daten vorzunehmen, die miteinander nicht
	  in Einklang gebracht werden können.  Diese Situation muss
	  vom Systemadministrator händisch bereinigt werden.</para>

	<para>Der Administrator muss entscheiden, welcher Knoten die
	  wichtigsten Änderungen von beiden besitzt (oder diese
	  manuell miteinander vermischen) und anschliessend den
	  <acronym>HAST</acronym>-Knoten die volle Synchronisation mit
	  jenem Knoten durchführen zu lassen, welcher die beschädigten
	  Daten besitzt.  Um dies zu tun, geben Sie folgende
	  Befehle auf dem Knoten ein, der neu synchronisiert werden
	  soll:</para>

        <screen>&prompt.root; <userinput>hastctl role init &lt;resource&gt;</userinput>
&prompt.root; <userinput>hastctl create &lt;resource&gt;</userinput>
&prompt.root; <userinput>hastctl role secondary &lt;resource&gt;</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>
