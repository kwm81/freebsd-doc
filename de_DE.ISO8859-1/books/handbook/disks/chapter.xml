<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/disks/chapter.xml,v 1.187 2012/04/26 19:32:48 bcr Exp $
     basiert auf: r43694
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="disks">
  <info><title>Speichermedien</title>
    <authorgroup>
      <author><personname><firstname>Bernd</firstname><surname>Warken</surname></personname><contrib>Übersetzt von </contrib></author>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname></author>
    </authorgroup>
  </info>

  

  <sect1 xml:id="disks-synopsis">
    <title>Übersicht</title>

    <para>Dieses Kapitel behandelt die Benutzung von Laufwerken unter
      &os;.  Laufwerke können speichergestützte Laufwerke,
      Netzwerklaufwerke oder normale SCSI/IDE-Geräte sein.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie Folgendes
      wissen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Begriffe, die &os; verwendet, um die
	  Organisation der Daten auf einem physikalischen Laufwerk
	  zu beschreiben.</para>
      </listitem>

      <listitem>
	<para>Wie Sie zusätzliche Laufwerke zu einem &os;-System
	  hinzufügen.</para>
      </listitem>

      <listitem>
	<para>Wie virtuelle Dateisysteme, zum Beispiel RAM-Disks,
	  eingerichtet werden.</para>
      </listitem>

      <listitem>
	<para>Wie Sie mit Quotas die Benutzung von Laufwerken
	  einschränken können.</para>
      </listitem>

      <listitem>
	<para>Wie Sie Partitionen verschlüsseln, um Ihre Daten
	  zu schützen.</para>
      </listitem>

      <listitem>
	<para>Wie unter &os; CDs und DVDs gebrannt werden.</para>
      </listitem>

      <listitem>
	<para>Wie Sie die unter &os; erhältlichen
	  Backup-Programme benutzen.</para></listitem>

      <listitem>
	<para>Was Dateisystem-Schnappschüsse sind und wie sie
	  eingesetzt werden.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen,</para>

    <itemizedlist>
      <listitem>
	<para>sollten Sie wissen, wie Sie einen
	  <link linkend="kernelconfig">neuen &os;-Kernel konfigurieren
	    und installieren</link> können.</para>
      </listitem>
    </itemizedlist>
  </sect1>

  <sect1 xml:id="disks-naming">
    <title>Gerätenamen</title>

    <para>Die folgende Tabelle zeigt die von &os; unterstützten
      Speichergeräte und deren Gerätenamen.</para>

    <table xml:id="disk-naming-physical-table" frame="none">
      <title>Namenskonventionen von physikalischen Laufwerken</title>

      <tgroup cols="2">
	<thead>
	  <row>
	    <entry>Laufwerkstyp</entry>
	    <entry>Gerätename</entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry>IDE-Festplatten</entry>
	    <entry><literal>ad</literal> oder
	      <literal>ada</literal></entry>
	  </row>

	  <row>
	    <entry>IDE-CD-ROM-Laufwerke</entry>
	    <entry><literal>acd</literal> oder
	      <literal>cd</literal></entry>
	  </row>

	  <row>
	    <entry>SATA-Festplatten</entry>
	    <entry><literal>ad</literal> oder
	      <literal>ada</literal></entry>
	  </row>

	  <row>
	    <entry>SATA-CD-ROM-Laufwerke</entry>
	    <entry><literal>acd</literal> oder
	      <literal>cd</literal></entry>
	  </row>

	  <row>
	    <entry>SCSI-Festplatten und USB-Speichermedien</entry>
	    <entry><literal>da</literal></entry>
	  </row>

	  <row>
	    <entry>SCSI-CD-ROM-Laufwerke</entry>
	    <entry><literal>cd</literal></entry>
	  </row>

	  <row>
	    <entry>Verschiedene proprietäre CD-ROM-Laufwerke</entry>
	    <entry><literal>mcd</literal> Mitsumi CD-ROM und
	      <literal>scd</literal> Sony CD-ROM</entry>
	  </row>

	  <row>
	    <entry>Diskettenlaufwerke</entry>
	    <entry><literal>fd</literal></entry>
	  </row>

	  <row>
	    <entry>SCSI-Bandlaufwerke</entry>
	    <entry><literal>sa</literal></entry>
          </row>

	  <row>
	    <entry>IDE-Bandlaufwerke</entry>
	    <entry><literal>ast</literal></entry>
	  </row>

	  <row>
	    <entry>Flash-Laufwerke</entry>
	    <entry><literal>fla</literal> für &diskonchip;
	      Flash-Device</entry>
	  </row>

	  <row>
	    <entry>RAID-Laufwerke</entry>
	    <entry><literal>aacd</literal> für &adaptec; AdvancedRAID,
	      <literal>mlxd</literal> und <literal>mlyd</literal>
	      für &mylex;,
	      <literal>amrd</literal> für AMI &megaraid;,
	      <literal>idad</literal> für Compaq Smart RAID,
	      <literal>twed</literal> für &tm.3ware; RAID.</entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 xml:id="disks-adding">
    <info><title>Hinzufügen von Laufwerken</title>
      <authorgroup>
	<author><personname><firstname>David</firstname><surname>O'Brian</surname></personname><contrib>Im Original von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>hinzufügen</secondary>
    </indexterm>

    <para>Dieser Abschnitt beschreibt, wie Sie ein neues
      <acronym>SATA</acronym>-Laufwerk zu einer Maschine
      hinzufügen, die momentan nur ein Laufwerk hat.  Dazu schalten
      Sie zuerst den Rechner aus und installieren das Laufwerk
      entsprechend der Anleitungen Ihres Rechners, Ihres Controllers
      und des Laufwerkherstellers.  Starten Sie das System neu und
      melden Sie sich als Benutzer
      <systemitem class="username">root</systemitem> an.</para>

    <para>Kontrollieren Sie <filename>/var/run/dmesg.boot</filename>,
      um sicherzustellen, dass das neue Laufwerk gefunden wurde.  In
      diesem Beispiel erscheint das neu hinzugefügte
      <acronym>SATA</acronym>-Laufwerk als
      <filename>ada1</filename>.</para>

    <indexterm><primary>Partitionen</primary></indexterm>
    <indexterm>
      <primary><command>gpart</command></primary>
    </indexterm>

    <para>In diesem Beispiel wird eine einzige große Partition auf der
      Festplatte erstellt.  Verwendet wird das <link
	xlink:href="https://de.wikipedia.org/wiki/GUID_Partition_Table"><acronym>GPT</acronym></link>-Partionsschema,
      welches gegenüber dem älteren und weniger vielseitigen
      <acronym>MBR</acronym>-Schema bevorzug wird.</para>

    <note>
      <para>Wenn die hinzugefügte Festplatte nicht leer ist, können
	alte Partitionsinformationen mit
	<command>gpart delete</command> entfernt werden. Details
	finden Sie in &man.gpart.8;.</para>
    </note>

    <para>Zuerst wird das Partitionsschema erstellt und dann eine
      einzelne Partition angefügt:</para>

    <screen>&prompt.root; <userinput>gpart create -s GPT ada1</userinput>
&prompt.root; <userinput>gpart add -t freebsd-ufs ada1</userinput></screen>

    <para>Je nach Anwendung kann es wünschenswert sein, mehrere
      kleinere Partitionen zu haben.  In &man.gpart.8; finden Sie
      Optionen zum Erstellen von kleineren Partitionen.</para>

    <para>Ein Dateisystem wird auf der neuen, leeren Festplatte
      erstellt:</para>

    <screen>&prompt.root; <userinput>newfs -U /dev/ada1p1</userinput></screen>

    <para>Ein leeres Verzeichnis wird als Mountpunkt erstellt, also
      ein Speicherort für die Montage der neuen Festplatte im
      originalen Dateisystem:</para>

    <screen>&prompt.root; <userinput>mkdir /newdisk</userinput></screen>

    <para>Abschließend wird ein Eintrag in
      <filename>/etc/fstab</filename> hinzugefügt, damit die neue
      Festplatte automatisch beim Start eingehängt wird:</para>

    <programlisting>/dev/ada1p1	/newdisk      ufs   rw	    2	  2</programlisting>

    <para>Die neue Festplatte kann manuell montiert werden, ohne das
      System neu zu starten:</para>

    <screen>&prompt.root; <userinput>mount /newdisk</userinput></screen>
  </sect1>

  <sect1 xml:id="usb-disks">
    <info><title>USB Speichermedien</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>USB</primary>
      <secondary>Speichermedien</secondary>
    </indexterm>

    <para>Der Universal Serial Bus (USB) wird heutzutage von
      vielen externen Speichern benutzt:  Festplatten,
      USB-Thumbdrives oder CD-Brennern, die alle von
      &os; unterstützt werden.</para>

    <sect2>
      <title>USB-Konfiguration</title>

      <para>Der Treiber für USB-Massenspeicher, &man.umass.4;, ist im
	<filename>GENERIC</filename>-Kernel enthalten und bietet
	Unterstützung für USB-Speichermedien.  Für einen angepassten
	Kernel müssen die nachstehenden Zeilen in der
	Kernelkonfigurationsdatei enthalten sein:</para>

      <programlisting>device scbus
device da
device pass
device uhci
device ohci
device ehci
device usb
device umass</programlisting>

      <para>Da der &man.umass.4;-Treiber das SCSI-Subsystem benutzt
	um auf USB-Geräte zuzugreifen, werden alle USB-Geräte vom
	System als SCSI-Geräte erkannt.  Abhängig vom Chipsatz Ihrer
	Systemplatine wird <literal>device uhci</literal> oder
	<literal>device ohci</literal> für die Unterstützung von
	USB 1.X benutzt.  Unterstützung für USB 2.0 Controller
	wird durch <literal>device ehci</literal>
	bereitgestellt.</para>

      <note>
	<para>Wenn es sich bei dem USB-Gerät um einen
	  CD- oder DVD-Brenner handelt, muss &man.cd.4; in den
	  Kernel aufgenommen werden:</para>

	<programlisting>device cd</programlisting>

	<para>Da der Brenner als SCSI-Laufwerk erkannt wird,
	  sollten Sie den Treiber &man.atapicam.4; nicht
	  benutzen.</para>
      </note>
    </sect2>

    <sect2>
      <title>Die USB-Konfiguration testen</title>

      <para>Um die USB-Konfiguration zu testen, schließen Sie das
	USB-Gerät an.  In den Systemmeldungen, &man.dmesg.8;, sollte
	das Gerät wie folgt angezeigt werden:</para>

      <screen>umass0: USB Solid state disk, rev 1.10/1.00, addr 2
GEOM: create disk da0 dp=0xc2d74850
da0 at umass-sim0 bus 0 target 0 lun 0
da0: &lt;Generic Traveling Disk 1.11&gt; Removable Direct Access SCSI-2 device
da0: 1.000MB/s transfers
da0: 126MB (258048 512 byte sectors: 64H 32S/T 126C)</screen>

      <para>Fabrikat, Gerätedatei (<filename>da0</filename>) und
	andere Details werden je nach Gerät unterschiedlich
	sein.</para>

      <para>Da ein USB-Gerät als SCSI-Gerät erkannt wird, kann
	<command>camcontrol</command> benutzt werden, um die mit dem
	System verbundenen USB-Massenspeicher anzuzeigen:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;Generic Traveling Disk 1.11&gt;      at scbus0 target 0 lun 0 (da0,pass0)</screen>

      <para>Wenn auf dem Laufwerk ein Dateisystem eingerichtet
	ist, kann es gemountet werden.
	<xref linkend="disks-adding"/> beschreibt, wie Sie
	USB-Laufwerke formatieren und Partitionen einrichten.</para>

      <warning>
        <para>Aus Sicherheitsgründen sollten Sie Benutzern, denen Sie
          nicht vertrauen, das Einhängen (z.B. durch die unten
          beschriebene Aktivierung von <literal>vfs.usermount</literal>)
          beliebiger Medien  verbieten.  Die meisten Dateisysteme in &os;
          wurden nicht entwickelt, um sich vor böswilligen Geräten
          zu schützen.</para>
      </warning>

      <para>Um auch normalen Anwendern das Einhängen des Laufwerks zu
	gestatten, könnten Sie beispielsweise mit &man.pw.8; alle
	potentiellen Benutzer dieser Gerätedateien in die Gruppe
	<systemitem class="groupname">operator</systemitem> aufnehmen.
	Außerdem muss sichergestellt werden, dass Mitglieder der
	Gruppe <systemitem class="groupname">operator</systemitem>
	Schreib- und Lesezugriff auf diese Gerätedateien haben.
	Hierfür werden die folgenden Zeilen in
	<filename>/etc/devfs.rules</filename> hinzugefügt:</para>

      <programlisting>[localrules=5]
add path 'da*' mode 0660 group operator</programlisting>

      <note>
	<para>Verfügt das System über SCSI-Laufwerke, so verändern Sie
	  die zweite Zeile wie folgt:</para>

	<programlisting>add path 'da[3-9]*' mode 0660 group operator</programlisting>

	<para>Dies wird die ersten drei SCSI-Laufwerke
	  (<filename>da0</filename> bis
	  <filename>da2</filename>) davon ausschließen, in die
	  Gruppe <systemitem class="groupname">operator</systemitem>
	  aufgenommen zu werden.</para>
      </note>

      <para>Aktivieren Sie nun die &man.devfs.rules.5;-Regeln
	in <filename>/etc/rc.conf</filename>:</para>

      <programlisting>devfs_system_ruleset="localrules"</programlisting>

      <para>Als nächstes müssen Sie Ihren Kernel anweisen, auch
	normalen Benutzern das mounten von Dateisystemen zu erlauben.
	Am einfachsten geht dies, indem die folgende Zeile in
	<filename>/etc/sysctl.conf</filename> hinzugefügt wird:</para>

      <programlisting>vfs.usermount=1</programlisting>

      <para>Da diese Einstellung erst nach einem Neustart wirksam
	wird, können Sie diese Variable mit &man.sysctl.8; auch direkt
	setzen.</para>

      <para>Zuletzt müssen Sie noch ein Verzeichnis anlegen, in
	das das USB-Laufwerk eingehängt werden soll.   Dieses
	Verzeichnis muss dem Benutzer gehören, der das
	USB-Laufwerk in den Verzeichnisbaum einhängen will.
	Dazu legen Sie als
	<systemitem class="username">root</systemitem> ein
	Unterverzeichnis
	<filename
	  class="directory">/mnt/<replaceable>username</replaceable></filename>
	an, wobei Sie <replaceable>username</replaceable>
	durch den Login des jeweiligen Benutzers sowie
	<replaceable>usergroup</replaceable> durch die primäre
	Gruppe des Benutzers ersetzen:</para>

      <screen>&prompt.root; <userinput>mkdir /mnt/username</userinput>
 &prompt.root; <userinput>chown username:usergroup /mnt/username</userinput></screen>

      <para>Wenn Sie nun beispielsweise einen USB-Stick
	anschließen, wird automatisch die Gerätedatei
	<filename>/dev/da0s1</filename> erzeugt.  Ist das Gerät mit
	einem FAT-Dateisystem formatiert, können Sie es mit dem
	folgenden Befehl in den Verzeichnisbaum einhängen:</para>

      <screen>&prompt.user; <userinput>mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username</userinput></screen>

      <para>Bevor das Gerät entfernt werden kann,
	<emphasis>muss</emphasis> es abgehängt werden.  Nach
	Entfernen des Geräts zeigen sich in den Systemmeldungen
	Einträge, ähnlich der folgenden:</para>

      <screen>umass0: at uhub0 port 1 (addr 2) disconnected
(da0:umass-sim0:0:0:0): lost device
(da0:umass-sim0:0:0:0): removing device entry
GEOM: destroy disk da0 dp=0xc2d74850
umass0: detached</screen>
    </sect2>

    <sect2>
      <title>Weiteres zu USB</title>

      <para>Neben den Abschnitten
	<link linkend="disks-adding">Hinzufügen von Laufwerken</link>
	und <link linkend="mount-unmount">Anhängen und
	Abhängen von Dateisystemen</link> lesen Sie bitte
	die Hilfeseiten &man.umass.4;, &man.camcontrol.8; für
	&os;&nbsp;8.X oder &man.usbdevs.8; bei vorherigen Versionen.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-cds">
    <info><title>Erstellen und Verwenden von CDs</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Beigesteuert von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>CD-ROM</primary>
      <secondary>brennen</secondary>
    </indexterm>

    <sect2>
      <title>Einführung</title>

      <para>CDs besitzen einige Eigenschaften, die sie von
	konventionellen Laufwerken unterscheiden.  Zuerst konnten
	sie nicht beschrieben werden.  Sie wurden so entworfen, dass
	sie ununterbrochen, ohne Verzögerungen durch Kopfbewegungen
	zwischen den Spuren, gelesen werden können.  Sie können auch
	leichter zwischen Systemen bewegt werden.</para>

      <para>CDs besitzen Spuren, aber damit ist der Teil Daten
	gemeint, der ununterbrochen gelesen wird, und nicht eine
	physikalische Eigenschaft der CD.  Um beispielsweise eine CD
	mit &os; zu erstellen,  werden die Daten jeder Spur der CD in
	Dateien vorbereitet und dann die Spuren auf die CD
	geschrieben.</para>

      <indexterm><primary>ISO 9660</primary></indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>

      <para>Das ISO 9660-Dateisystem wurde entworfen, um mit diesen
	Unterschieden umzugehen.  Um die ursprünglichen
	Dateisystemgrenzen zu überwinden existiert ein
	Erweiterungsmechanismus, der es korrekt geschriebenen CDs
	erlaubt, diese Grenzen zu überschreiten und dennoch auf
	Systemen zu funktionieren, die diese Erweiterungen nicht
	unterstützen.</para>

      <indexterm>
	<primary><package>sysutils/cdrtools</package></primary>
      </indexterm>

      <para>Der Port <package>sysutils/cdrtools</package>
	enthält das Programm &man.mkisofs.8;, das eine Datei
	erstellt, die ein ISO 9660-Dateisystem enthält.
	Das Programm hat Optionen, um verschiedene Erweiterungen
	zu unterstützen, und wird unten beschrieben.</para>

      <indexterm>
	<primary>CD-Brenner</primary>
	<secondary>ATAPI</secondary>
      </indexterm>

      <para>Welches Werkzeug zum Brennen von CDs benutzt wird, hängt
	davon ab, ob der CD-Brenner ein ATAPI-Gerät ist oder nicht.
	Mit ATAPI-CD-Brennern wird <command>burncd</command> benutzt,
	das Teil des Basissystems ist.  SCSI- und USB-CD-Brenner
	werden mit <command>cdrecord</command> aus
	<package>sysutils/cdrtools</package> benutzt.  Zusätzlich ist
	es möglich, über das Modul
	<link linkend="atapicam">ATAPI/CAM</link> SCSI-Werkzeuge wie
	<command>cdrecord</command> auch für ATAPI-Geräte
	einzusetzen.</para>

      <para>Für eine Brennsoftware mit grafischer
	Benutzeroberfläche benötigen, sollten Sie sich
	<application>X-CD-Roast</application> oder
	<application>K3b</application> näher ansehen.  Diese
	Werkzeuge können als Paket oder aus den
	Ports (<package>sysutils/xcdroast</package>
	und <package>sysutils/k3b</package>)
	installiert werden.  Mit ATAPI-Hardware benötigt
	<application>K3b</application> das
	<link linkend="atapicam">ATAPI/CAM-Modul</link>.</para>
    </sect2>

    <sect2 xml:id="mkisofs">
      <title><application>mkisofs</application></title>

      <para>Der Port <package>sysutils/cdrtools</package> installiert
	auch &man.mkisofs.8;, welches ein ISO 9660-Abbild erstellt,
	das ein Abbild eines Verzeichnisbaumes ist.  Die einfachste
	Anwendung ist:</para>

      <screen>&prompt.root; <userinput>mkisofs -o
<replaceable>imagefile.iso</replaceable> <replaceable>/path/to/tree</replaceable>
</userinput></screen>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>ISO 9660</secondary>
      </indexterm>
      <para>Dieses Kommando erstellt
	<replaceable>imagefile.iso</replaceable>, die ein ISO
	9660-Dateisystem enthält, das eine Kopie des Baumes unter
	<replaceable>/path/to/tree</replaceable> ist.  Dabei werden
	die Dateinamen auf Namen abgebildet, die den Restriktionen des
	ISO 9660-Dateisystems entsprechen.  Dateien mit Namen, die im
	ISO 9660-Dateisystem nicht gültig sind, bleiben
	unberücksichtigt.</para>

      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>HFS</secondary>
      </indexterm>
      <indexterm>
	<primary>Dateisysteme</primary>
	<secondary>Joliet</secondary>
      </indexterm>
      <para>Es einige Optionen, um diese Beschränkungen zu überwinden.
	Die unter &unix; Systemen üblichen Rock-Ridge-Erweiterungen
	werden durch <option>-R</option> aktiviert,
	<option>-J</option> aktiviert die von Microsoft Systemen
	benutzten Joliet-Erweiterungen und <option>-hfs</option> dient
	dazu, um das von &macos; benutzte HFS zu erstellen.</para>

      <para>Für CDs, die nur auf &os;-Systemen verwendet werden
	sollen, kann <option>-U</option> genutzt werden, um alle
	Beschränkungen für Dateinamen aufzuheben.  Zusammen mit
	<option>-R</option> wird ein Abbild des Dateisystems,
	identisch zu angegebenen &os;-Dateibaum, erstellt, obwohl dies
	den ISO 9660 Standard verletzen kann.</para>

      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>bootbare erstellen</secondary>
      </indexterm>
      <para>Die letzte übliche Option ist <option>-b</option>.
	Sie wird benutzt, um den Ort eines Bootimages einer
	<quote>El Torito</quote> bootbaren CD anzugeben.  Das Argument
	zu dieser Option ist der Pfad zu einem Bootimage ausgehend
	von der Wurzel des Baumes, der auf die CD geschrieben werden
	soll.  In der Voreinstellung erzeugt &man.mkisofs.8; ein
	ISO-Image im <quote>Diskettenemulations</quote>-Modus.  Dabei
	muss das Image genau 1200, 1440 oder 2880&nbsp;KB groß
	sein.  Einige Bootloader, darunter der auf den &os;-Disks
	verwendete, kennen keinen Emulationsmodus.  Daher sollten Sie
	in diesen Fällen <option>-no-emul-boot</option> verwenden.
	Wenn <filename>/tmp/myboot</filename> ein bootbares
	&os;-System enthält, dessen Bootimage sich in
	<filename>/tmp/myboot/boot/cdboot</filename> befindet, können
	Sie ein Abbild eines ISO 9660-Dateisystems in
	<filename>/tmp/bootable.iso</filename> erstellen:</para>

      <screen>&prompt.root; <userinput>mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</userinput></screen>

      <para>Wenn <filename>md</filename> im Kernel konfiguriert ist,
	kann das Dateisystem als speicherbasiertes Laufwerk
	eingehängt werden:</para>

      <screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</userinput>
&prompt.root; <userinput>mount -t cd9660 /dev/md0 /mnt</userinput></screen>

      <para>Jetzt können Sie überprüfen, dass
	<filename>/mnt</filename> und <filename>/tmp/myboot</filename>
	identisch sind.</para>

      <para>Sie können das Verhalten von &man.mkisofs.8;
	mit einer Vielzahl von Optionen beeinflussen.  Details dazu
	entnehmen Sie bitte &man.mkisofs.8;.</para>
    </sect2>

    <sect2 xml:id="burncd">
      <title><application>burncd</application></title>

      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>brennen</secondary>
      </indexterm>
      <para>Für ATAPI-CD-Brenner kann <command>burncd</command>
	benutzt werden, um ein ISO-Image auf CD zu brennen.
	<command>burncd</command> ist Teil des Basissystems und unter
	<filename>/usr/sbin/burncd</filename> installiert.  Da es
	nicht viele Optionen hat, ist es leicht zu benutzen:</para>

      <screen>&prompt.root; <userinput>burncd -f cddevice data imagefile.iso fixate</userinput></screen>

      <para>Dieses Kommando brennt eine Kopie von
	<replaceable>imagefile.iso</replaceable> auf das Gerät
	<replaceable>cddevice</replaceable>.  In der Grundeinstellung
	wird das Gerät <filename>/dev/acd0</filename> benutzt.
	&man.burncd.8; beschreibt, wie die Schreibgeschwindigkeit
	gesetzt wird, die CD ausgeworfen wird und Audiodaten
	geschrieben werden.</para>
    </sect2>

    <sect2 xml:id="cdrecord">
      <title><application>cdrecord</application></title>

      <para>Für Systeme ohne ATAPI-CD-Brenner kann
	<command>cdrecord</command> benutzt werden, um CDs zu brennen.
	<command>cdrecord</command> ist nicht Bestandteil des
	Basissystems und muss entweder als Paket
	<package>sysutils/cdrtools</package> oder Port installiert
	werden.  Änderungen im Basissystem können Fehler im binären
	Programm verursachen und führen möglicherweise dazu, dass Sie
	einen <quote>Untersetzer</quote> brennen.  Es wird daher
	empfohlen den Port aktualisieren, wenn das System
	aktualisiert wird, oder für Benutzer die
	<link linkend="stable">STABLE verfolgen</link>,
	den Port zu aktualisieren, wenn es eine neue Version
	gibt.</para>

      <para>Obwohl <command>cdrecord</command> viele Optionen besitzt,
	ist die grundlegende Anwendung einfach.  Ein ISO 9660-Image
	wird wie folgt erstellt:</para>

      <screen>&prompt.root; <userinput>cdrecord dev=device imagefile.iso</userinput></screen>

      <para>Der Knackpunkt in der Benutzung von
	<command>cdrecord</command> besteht darin, das richtige
	Argument zu <option>dev</option> zu finden.  Benutzen Sie
	<option>-scanbus</option>, der eine ähnliche Ausgabe
	wie die folgende produziert:</para>

      <indexterm>
	<primary>CD-ROM</primary>
	<secondary>brennen</secondary>
      </indexterm>
      <screen>&prompt.root; <userinput>cdrecord -scanbus</userinput>
Cdrecord 1.9 (i386-unknown-freebsd7.0) Copyright (C) 1995-2004 Jörg Schilling
Using libscg version 'schily-0.1'
scsibus0:
        0,0,0     0) 'SEAGATE ' 'ST39236LW       ' '0004' Disk
        0,1,0     1) 'SEAGATE ' 'ST39173W        ' '5958' Disk
        0,2,0     2) *
        0,3,0     3) 'iomega  ' 'jaz 1GB         ' 'J.86' Removable Disk
        0,4,0     4) 'NEC     ' 'CD-ROM DRIVE:466' '1.26' Removable CD-ROM
        0,5,0     5) *
        0,6,0     6) *
        0,7,0     7) *
scsibus1:
        1,0,0   100) *
        1,1,0   101) *
        1,2,0   102) *
        1,3,0   103) *
        1,4,0   104) *
        1,5,0   105) 'YAMAHA  ' 'CRW4260         ' '1.0q' Removable CD-ROM
        1,6,0   106) 'ARTEC   ' 'AM12S           ' '1.06' Scanner
        1,7,0   107) *</screen>

      <para>Für die aufgeführten Geräte in der Liste
	wird das passende Argument zu <option>dev</option> gegeben.
	Benutzen Sie die drei durch Kommas separierten Zahlen, die zum
	CD-Brenner angegeben sind, als Argument für
	<option>dev</option>.  Im Beispiel ist das CDRW-Gerät
	1,5,0, so dass die passende Eingabe
	<userinput>dev=1,5,0</userinput> ist.  Einfachere Wege das
	Argument anzugeben, sowie Informationen über Audiospuren und
	das Einstellen der Geschwindigkeit, sind in &man.cdrecord.1;
	beschrieben.</para>
    </sect2>

    <sect2 xml:id="duplicating-audiocds">
      <title>Kopieren von Audio-CDs</title>

      <para>Um eine Kopie einer Audio-CD zu erstellen, kopieren Sie
	die Stücke der CD in einzelne Dateien und brennen diese
	Dateien dann auf eine leere CD.  Das genaue Verfahren hängt
	davon ab, ob Sie ATAPI- oder SCSI-Laufwerke verwenden.</para>

      <procedure>
	<title>SCSI-Laufwerke</title>

	<step>
	  <para>Kopieren Sie die Audiodaten mit
	    <command>cdda2wav</command>:</para>

	  <screen>&prompt.user; <userinput>cdda2wav -vall -D2,0 -B -Owav</userinput></screen>
	</step>

	<step>
	  <para>Die erzeugten <filename>.wav</filename> Dateien
	    schreiben Sie mit <command>cdrecord</command> auf eine
	    leere CD:</para>

	  <screen>&prompt.user; <userinput>cdrecord -v dev=2,0 -dao -useinfo  *.wav</userinput></screen>

	  <para>Das Argument von <option>dev</option> gibt das
	    verwendete Gerät an, das wie in <xref linkend="cdrecord"/>
	    ermittelt werden kann.</para>
	</step>
      </procedure>

      <procedure>
	<title>ATAPI-Laufwerke</title>

	<note>
	  <para>Über das Modul
	    <link linkend="atapicam">ATAPI/CAM</link> kann
	    <command>cdda2wav</command> auch mit ATAPI-Laufwerken
	    verwendet werden.  Diese Methode ist für die meisten
	    Anwender besser geeignet als die im folgenden
	    beschriebenen Methoden (Jitter-Korrektur,
	    Big-/Little-Endian-Probleme und anderes mehr spielen
	    hierbei eine Rolle).</para>
        </note>

	<step>
	  <para>Der ATAPI-CD-Treiber stellt die einzelnen Stücke der
	    CD über die Dateien
	    <filename>/dev/acddtnn</filename>,
	    zur Verfügung.  <replaceable>d</replaceable> bezeichnet
	    die Laufwerksnummer und <replaceable>nn</replaceable> ist die
	    Nummer des Stücks.  Die Nummer ist immer zweistellig,
	    das heißt es wird, wenn nötig, eine führende
	    Null ausgegeben.  Die Datei <filename>/dev/acd0t01</filename>
	    ist also das erste Stück des ersten CD-Laufwerks.
	    <filename>/dev/acd0t02</filename> ist das zweite Stück
	    und <filename>/dev/acd0t03</filename> das dritte.</para>

	  <para>Überprüfen Sie stets, ob die entsprechenden
	    Dateien im Verzeichnis <filename>/dev</filename> auch
	    angelegt werden.  Sind die Einträge nicht vorhanden,
	    weisen Sie Ihr System an, das Medium erneut zu testen:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=/dev/null count=1</userinput></screen>

	  <note>
	    <para>Unter &os;&nbsp;4.X werden diese Einträge nicht
	      mit dem Wert Null vordefiniert.  Falls die entsprechenden
	      Einträge unter <filename>/dev</filename> nicht
	      vorhanden sind, müssen Sie diese hier von
	      <command>MAKEDEV</command> anlegen lassen:</para>

	  <screen>&prompt.root; <userinput>cd /dev</userinput>
&prompt.root; <userinput>sh MAKEDEV acd0t99</userinput></screen>

	  </note>
	</step>

	<step>
	  <para>Die einzelnen Stücke werden mit &man.dd.1; kopiert.
	    Achten Sie darauf, eine Blockgröße anzugeben:</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/acd0t01 of=track1.cdr bs=2352</userinput>
&prompt.root; <userinput>dd if=/dev/acd0t02 of=track2.cdr bs=2352</userinput>
...</screen>
	</step>

	<step>
	  <para>Die kopierten Dateien können Sie dann mit
	    <command>burncd</command> brennen.  Geben Sie an, dass es
	    sich um Audio-Daten handelt und dass <command>burncd</command>
	    das Medium am Ende fixieren soll:</para>

	  <screen>&prompt.root; <userinput>burncd -f /dev/acd0 audio track1.cdr track2.cdr ... fixate</userinput></screen>
	</step>
      </procedure>
    </sect2>

    <sect2 xml:id="imaging-cd">
      <title>Kopieren von Daten-CDs</title>

      <para>Es ist möglich eine Daten-CD in eine Datei zu kopieren,
	die einem Image entspricht, das mit &man.mkisofs.8; erstellt
	wurde.  Mit Hilfe dieses Images können Sie jede Daten-CD
	kopieren.  Das folgende Beispiel verwendet
	<filename>acd0</filename> für das CD-ROM-Gerät.  Wird ein
	anderes Laufwerk benutzt, muss der Name entsprechend ersetzt
	werden.</para>

      <screen>&prompt.root; <userinput>dd if=/dev/acd0 of=file.iso bs=2048</userinput></screen>

      <para>Danach existiert ein Image, das wie oben beschrieben, auf
        CD gebrannt werden kann.</para>
    </sect2>

    <sect2 xml:id="mounting-cd">
      <title>Einhängen von Daten-CDs</title>

      <para>Es ist möglich, eine Daten-CD zu mounten und die Daten zu
	lesen. Standardmäßig erwartet &man.mount.8; ein Dateisystem
	vom Typ <literal>ufs</literal>.  Wenn Sie das folgende
	Kommando ausführen:</para>

      <screen>&prompt.root; <userinput>mount /dev/cd0 /mnt</userinput></screen>

      <para>erhalten Sie die Fehlermeldung
	<errorname>Incorrect super block</errorname>, und die CD
	konnte nicht eingehängt werden.  Die CD benutzt nicht das
	<literal>UFS</literal>-Dateisystem, deshalb schlägt der
	Versuch fehl, sie als solches einzuhängen.  Sie müssen
	&man.mount.8; durch die Angabe von <option>-t cd9660</option>
	sagen, dass es sich um ein Dateisystem vom Typ
	<literal>ISO9660</literal> handelt.  Wenn Sie also die
	CD-ROM <filename>/dev/cd0</filename> in
	<filename>/mnt</filename> einhängen wollen, führen Sie
	folgenden Befehl aus:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Ersetzen Sie <filename>/dev/cd0</filename> durch den
	Gerätenamen des CD-Gerätes.  Die Angabe von
	<option>-t cd9660</option> führt &man.mount.cd9660.8; aus,
	was äquivalent zu folgendem Befehl ist:</para>

      <screen>&prompt.root; <userinput>mount_cd9660 /dev/cd0 /mnt</userinput></screen>

      <para>Auf diese Weise können Sie Daten-CDs von jedem Hersteller
	verwenden.  Es kann allerdings zu Problemen mit CDs kommen,
	die verschiedene ISO9660-Erweiterungen benutzen.  So speichern
	Joliet-CDs alle Dateinamen unter Verwendung von zwei Byte
	langen Unicode-Zeichen.  Zwar unterstützt der &os;-Kernel
	derzeit noch kein Unicode, der CD9660-Treiber erlaubt es aber,
	zur Laufzeit eine Konvertierungstabelle zu laden.  Tauchen
	also statt bestimmter Zeichen nur Fragezeichen auf, so
	müssen Sie über die Option <option>-C</option> den
	benötigten Zeichensatz angeben.  Weitere Informationen zu
	diesem Problem finden Sie in der Manualpage
	&man.mount.cd9660.8;.</para>

      <note>
	<para>Damit der Kernel diese Zeichenkonvertierung (festgelegt
	  durch die Option <option>-C</option>) erkennt, müssen Sie
	  das Kernelmodul <filename>cd9660_iconv.ko</filename> laden.
	  Dazu fügen Sie folgende Zeile in
	  <filename>loader.conf</filename> ein:</para>

	<programlisting>cd9660_iconv_load="YES"</programlisting>

	<para>Danach müssen Sie allerdings Ihr System neu starten.
	  Alternativ können Sie das Kernelmodul auch direkt
	  über &man.kldload.8; laden.</para>
      </note>

      <para>Manchmal werden Sie die Meldung
	<errorname>Device not configured</errorname> erhalten, wenn
	Sie versuchen,  eine CD-ROM einzuhängen.  Für gewöhnlich liegt
	das daran, dass das Laufwerk meint es sei keine CD eingelegt,
	oder dass das Laufwerk auf dem Bus nicht erkannt wird.  Es
	kann einige Sekunden dauern, bevor das Laufwerk merkt, dass
	eine CD eingelegt wurde.  Seien Sie also geduldig.</para>

      <para>Manchmal wird ein SCSI-CD-ROM nicht erkannt, weil es keine
	Zeit hatte, auf das Zurücksetzen des Busses zu antworten.
	Wenn Sie ein SCSI-CD-ROM besitzen, sollten Sie die folgende
	Zeile in Ihre Kernelkonfiguration aufnehmen und einen neuen
	<link linkend="kernelconfig-building">Kernel bauen</link>:</para>

      <programlisting>options SCSI_DELAY=15000</programlisting>

      <para>Die Zeile bewirkt, dass nach dem Zurücksetzen des
	SCSI-Busses beim Booten 15 Sekunden gewartet wird, um dem
	CD-ROM-Laufwerk genügend Zeit zu geben, darauf zu
	antworten.</para>
    </sect2>

    <sect2 xml:id="rawdata-cd">
      <title>Brennen von rohen CDs</title>

      <para>Es ist möglich eine Datei auch direkt auf eine CD zu
	brennen, ohne vorher auf ihr ein ISO 9660-Dateisystem
	einzurichten.  Einige Leute nutzen dies, um Datensicherungen
	durchzuführen.  Diese Vorgehensweise hat den Vorteil, dass sie
	schneller als das Brennen einer normalen CD ist.</para>

      <screen>&prompt.root; <userinput>burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate</userinput></screen>

      <para>Um die Daten einer solchen CD abzurufen, müssen die Daten
	direkt von dem rohen Gerät gelesen werden:</para>

      <screen>&prompt.root; <userinput>tar xzvf /dev/acd1</userinput></screen>

      <para>Eine auf diese Weise gefertigte CD kann nicht in das
	Dateisystem eingehangen werden.  Sie kann auch nicht auf
	einem anderen Betriebssystem gelesen werden.  Wenn Sie die
	erstellten CDs in das Dateisystem einhängen oder mit anderen
	Betriebssystemen austauschen wollen, müssen Sie
	&man.mkisofs.8; wie oben beschrieben benutzen.</para>
    </sect2>

    <sect2 xml:id="atapicam">
      <info><title>Der ATAPI/CAM Treiber</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      

      <indexterm>
	<primary>CD-Brenner</primary>
	<secondary>ATAPI/CAM Treiber</secondary>
      </indexterm>

      <para>Mit diesem Treiber kann auf ATAPI-Geräte, wie
	CD-ROM-, CD-RW- oder DVD-Laufwerke, mithilfe des
	SCSI-Subsystems zugegriffen werden.  Damit können
	Sie SCSI-Werkzeuge, wie <package>sysutils/cdrdao</package> oder &man.cdrecord.1;,
	zusammen mit einem ATAPI-Gerät benutzen.</para>

      <para>Um den Treiber zu benutzen, fügen Sie die folgende Zeile
	in <filename>/boot/loader.conf</filename> ein:</para>

      <programlisting>atapicam_load="YES"</programlisting>

      <para>Um den Treiber zu aktivieren, muss das System neu
	gestartet werden.</para>

      <note>
	<para>Benutzer, die es vorziehen
	  &man.atapicam.4;-Unterstützung statisch in den Kernel
	  zu komplillieren, sollten diese Zeile in die
	  Kernelkonfigurationsdatei hinzufügen:</para>

        <programlisting>device atapicam</programlisting>

        <para>Die folgenden Zeilen werden ebenfalls benötigt,
	  sollten aber schon Teil der Kernelkonfiguration sein:</para>

        <programlisting>device ata
device scbus
device cd
device pass</programlisting>

      <para>Übersetzen und installieren Sie den neuen
	Kernel.  Starten Sie anschließend das System neu.</para>
      </note>

      <para>Während des Bootvorgangs sollte der CD-Brenner ungefähr
	so angezeigt werden:</para>

      <screen>acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4
cd0 at ata1 bus 0 target 0 lun 0
cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM SCSI-0 device
cd0: 16.000MB/s transfers
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</screen>

      <para>Über den Gerätenamen <filename>/dev/cd0</filename>
	kann nun auf das Laufwerk zugegriffen werden.  Um
	beispielsweise eine CD-ROM in <filename>/mnt</filename>
	einzuhängen, geben Sie folgendes ein:</para>

      <screen>&prompt.root; <userinput>mount -t cd9660 <replaceable>/dev
/cd0</replaceable> /mnt</userinput></screen>

      <para>Die SCSI-Adresse des Brenners können Sie als
	<systemitem class="username">root</systemitem> wie folgt
	ermitteln:</para>

      <screen>&prompt.root; <userinput>camcontrol devlist</userinput>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 (pass0,cd0)</screen>

      <para>Die SCSI-Adresse <literal>1,0,0</literal> können
	Sie mit den SCSI-Werkzeugen, zum Beispiel &man.cdrecord.1;,
	verwenden.</para>

      <para>Weitere Informationen über das ATAPI/CAM- und
	das SCSI-System finden Sie in &man.atapicam.4; und
	&man.cam.4;.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="creating-dvds">
    <info><title>DVDs benutzen</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Andy</firstname><surname>Polyakov</surname></personname><contrib>Mit Beiträgen von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>DVD</primary>
      <secondary>brennen</secondary>
    </indexterm>

    <sect2>
      <title>Einführung</title>

      <para>Nach der CD ist die DVD die nächste Generation
	optischer Speichermedien.  Auf einer DVD können
	mehr Daten als auf einer CD gespeichert werden.
	DVDs werden als Standardmedium für Videos verwendet.</para>

      <para>Für beschreibbare DVDs existieren fünf
	Medienformate:</para>

      <itemizedlist>
	<listitem>
	  <para>DVD-R:  Dies war das erste verfügbare Format.
	    Das Format wurde vom <link xlink:href="http://www.dvdforum.com/forum.shtml">DVD-Forum</link>
	    festgelegt.  Die Medien sind nur einmal beschreibbar.</para>
	</listitem>

	<listitem>
	  <para>DVD-RW:  Dies ist die wiederbeschreibbare Version
	    des DVD-R Standards.  Eine DVD-RW kann ungefähr
	    1000&nbsp;Mal beschrieben werden.</para>
	</listitem>

	<listitem>
	  <para>DVD-RAM:  Dies ist ein wiederbeschreibbares
	    Format, das wie ein Wechsellaufwerk betrachtet werden
	    kann.  Allerdings sind die Medien nicht kompatibel zu den
	    meisten DVD-ROM-Laufwerken und DVD-Video-Spielern, da das
	    DVD-RAM-Format nur von wenigen Brennern unterstützt
	    wird.  Informationen zur Nutzung von DVD-RAM finden Sie in
	    <xref linkend="creating-dvd-ram"/>.</para>
	</listitem>

	<listitem>
	  <para>DVD+RW:  Ist ein wiederbeschreibbares Format, das
	    von der <link xlink:href="http://www.dvdrw.com/">DVD+RW
	      Alliance</link> festgelegt wurde.  Eine DVD+RW
	    kann ungefähr 1000&nbsp;Mal beschrieben werden.</para>
	</listitem>

	<listitem>
	  <para>DVD+R:  Dieses Format ist die nur einmal beschreibbare
	    Variante des DVD+RW Formats.</para>
	</listitem>
      </itemizedlist>

      <para>Auf einer einfach beschichteten DVD können
	4.700.000.000&nbsp;Bytes gespeichert werden.  Das
	sind 4,38&nbsp;GB oder 4485&nbsp;MB (1&nbsp;Kilobyte
	sind 1024&nbsp;Bytes).</para>

      <note>
	<para>Die physischen Medien sind unabhängig von
	  der Anwendung.  Ein DVD-Video ist eine spezielle
	  Anordnung von Dateien, die auf irgendein Medium,
	  beispielsweise DVD-R, DVD+R oder DVD-RW geschrieben werden
	  kann.  Bevor Sie ein Medium auswählen, müssen Sie
	  sicherstellen, dass der Brenner und der DVD-Spieler mit dem
	  Medium umgehen können.</para>
      </note>
    </sect2>

    <sect2>
      <title>Konfiguration</title>

      <para>Benutzen Sie &man.growisofs.1;, um DVDs zu beschreiben.
	Das Kommando ist Bestandteil von
	<package>sysutils/dvd+rw-tools</package>, und kann mit allen
	DVD-Medien umgehen.</para>

      <para>Diese Werkzeuge verwenden das SCSI-Subsystem, um auf die
	Geräte zuzugreifen.  Daher muss
	<link linkend="atapicam">ATAPI/CAM-Unterstützung</link>
	geladen, oder statisch in den Kernel kompiliert werden.
	Sollte der Brenner jedoch die USB-Schnittstelle nutzen, wird
	diese Unterstützung nicht benötigt.  Weitere Informationen
	zur Konfiguration von USB-Geräten finden Sie in
	<xref linkend="usb-disks"/>.</para>

      <para>Für ATAPI-Geräte müssen ebenfalls DMA-Zugriffe aktiviert
	werden.  Dazu wird die folgende Zeile in
	<filename>/boot/loader.conf</filename> eingefügt:</para>

      <programlisting>hw.ata.atapi_dma="1"</programlisting>

      <para>Bevor Sie <application>dvd+rw-tools</application>
	benutzen, lesen Sie bitte die
	Hardware-Informationen auf der Seite <link
	  xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/hcn.html">Hardware
	  Compatibility Notes</link>.</para>

      <note>
	<para>Für eine grafische Oberfläche sollten Sie sich
	  <package>sysutils/k3b</package> ansehen, das eine
	  benutzerfreundliche Schnittstelle zu &man.growisofs.1; und
	  vielen anderen Werkzeugen bietet.</para>
      </note>
    </sect2>

    <sect2>
      <title>Daten-DVDs brennen</title>

      <para>&man.growisofs.1; erstellt mit dem Programm
	<link linkend="mkisofs">mkisofs</link> das Dateisystem
	und brennt anschließend die DVD.  Vor dem Brennen braucht
	daher kein Abbild der Daten zu erstellt werden.</para>

      <para>Wenn Sie von den Daten im Verzeichnis
	<filename>/path/to/data</filename> eine
	DVD+R oder eine DVD-R brennen wollen, benutzen Sie
	das nachstehende Kommando:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev
/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>In diesem Beispiel wird <option>-J -R</option> an
	&man.mkisofs.8; durchgereicht und dient zum Erstellen
	des Dateisystems (hier:  ein ISO-9660-Dateisystem mit
	Joliet- und Rock-Ridge-Erweiterungen).  Weiteres
	entnehmen Sie bitte der Hilfeseite &man.mkisofs.8;.</para>

      <para>Die Option <option>-Z</option> wird für die erste
	Aufnahme einer Single- oder Multisession benötigt.  Ersetzen
	Sie <replaceable>/dev/cd0</replaceable> mit dem Gerätenamen
	des DVD-Gerätes.  Die Nutzung von <option>-dvd-compat</option>
	schließt das Medium, weitere Daten können danach nicht mehr
	angehängt werden.  Dies sollte auch eine eine bessere
	Kompatibilität mit anderen DVD-ROM-Laufwerken bieten.</para>

      <para>Um ein vorher erstelltes Abbild der Daten zu brennen,
	beispielsweise <replaceable>imagefile.iso</replaceable>,
	verwenden Sie:</para>

      <screen>&prompt.root; <userinput>growisofs -dvd-compat -Z <replaceable>/dev
/cd0</replaceable>=<replaceable>imagefile.iso</replaceable></userinput></screen>

      <para>Die Schreibgeschwindigkeit hängt von den
	verwendeten Medium sowie dem verwendeten Gerät ab
	und sollte automatisch gesetzt werden.  Um die
	Schreibgeschwindigkeit vorzugeben, verwenden Sie
	<option>-speed=</option>.  Beispiele finden Sie in
	&man.growisofs.1;.</para>

      <note>
        <para>Um grössere Dateien als 4.38GB zu unterstützen, ist es
	  notwendig ein UDF/ISO-9660 Hybrid-Dateisystem zu erstellen.
	  Dieses Dateisystem muss mit zusätzlichen Parametern
	  <option>-udf -iso-level 3</option> bei &man.mkisofs.8; und
	  allen relevanten Programmen, wie beispielsweise
	  &man.growisofs.1;) erzeugt werden.  Dies ist nur notwendig,
	  wenn Sie ein ISO-Image erstellen oder direkt auf eine DVD
	  schreiben wollen.  DVDs, die in dieser Weise hergestellt
	  worden sind, müssen als UDF-Dateisystem mit
	  &man.mount.udf.8; eingehangen werden. Sie sind nur auf
	  Betriebssystemen, die UDF unterstützen brauchbar, ansonsten
	  sieht es so aus, als ob sie kaputte Dateien enthalten
	  würden.</para>

	<para>Um diese Art von ISO-Datei zu erstellen:</para>

	<screen>&prompt.user; <userinput>mkisofs -R -J -udf -iso-level 3 -o
<replaceable>imagefile.iso</replaceable> <replaceable>/path/to/data</replaceable>
</userinput></screen>

 	<para>Um Daten direkt auf eine DVD zu brennen, geben Sie den
 	  folgenden Befehl ein:</para>

	<screen>&prompt.root; <userinput>growisofs -dvd-compat -udf -iso-level 3 -Z
<replaceable>/dev/cd0</replaceable> -J -R <replaceable>/path/to/data</replaceable>
</userinput></screen>

	<para>Wenn ein ISO-Abbild bereits große Dateien enthält, sind
	  keine weiteren Optionen für &man.growisofs.1; notwendig, um
	  das Abbild auf die DVD zu brennen.</para>

	<para>Achten Sie darauf, eine aktuelle Version von
	  <package>sysutils/cdrtools</package> zu verwenden, welche
	  &man.mkisofs.8; enthält, da ältere Versionen keinen Support
	  für große Dateien enthalten.  Falls die neueste Version
	  nicht funktioniert, installieren Sie
	  <package>sysutils/cdrtools-devel</package> und lesen Sie
	  &man.mkisofs.8;.</para>
      </note>
    </sect2>

    <sect2>
      <title>DVD-Videos brennen</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-Video</secondary>
      </indexterm>

      <para>Ein DVD-Video ist eine spezielle Anordnung von Dateien,
	die auf den ISO-9660 und den micro-UDF (M-UDF) Spezifikationen
	beruht.  Da DVD-Video auf eine bestimmte Datei-Hierarchie
	angewiesen ist, müssen DVDs mit speziellen Programmen wie
	<package>multimedia/dvdauthor</package> erstellt
	werden.</para>

      <para>Ist bereits ein Abbild des Dateisystems eines
	DVD-Videos vorhanden, kann es auf die gleiche Weise wie jedes
	andere Abbild gebrannt werden.  Wenn
	<command>dvdauthor</command> verwendet wurde, um die DVD zu
	erstellen und die Resultate in
	<filename>/path/to/video</filename> liegen, kann das folgende
	Kommando verwendet werden, um ein DVD-Video zu brennen:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable>
-dvd-video <replaceable>/path/to/video</replaceable></userinput></screen>

      <para><option>-dvd-video</option> wird an &man.mkisofs.8;
	weitergereicht, um die Datei-Hierarchie für ein DVD-Video zu
	erstellen.  Weiterhin bewirkt diese Option, dass
	&man.growisofs.1; mit <option>-dvd-compat</option> aufgerufen
	wird.</para>
    </sect2>

    <sect2>
      <title>DVD+RW-Medien benutzen</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD+RW</secondary>
      </indexterm>

      <para>Im Gegensatz zu CD-RW-Medien müssen DVD+RW-Medien
	erst formatiert werden, bevor sie benutzt werden können.
	Es wird <emphasis>empfohlen</emphasis> &man.growisofs.1;
	einzusetzen, da das Programm Medien automatisch formatiert,
	wenn es erforderlich ist.  Es ist jedoch möglich, auch
	<command>dvd+rw-format</command> zu nutzen, um die DVD+RW zu
	formatieren:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev
/cd0</replaceable></userinput></screen>

      <para>Dieser Vorgang muss nur einmal durchgeführt werden. Denken
	Sie daran, dass nur neue DVD+RWs formatiert werden müssen.
	Anschließend können DVD+RWs, wie gewohnt, gebrannt
	werden.</para>

      <para>Wenn Sie auf einer DVD+RW ein neues Dateisystem
	erstellen wollen, brauchen Sie die DVD+RW vorher nicht zu
	löschen.  Überschreiben Sie einfach das vorige Dateisystem
	indem Sie eine neue Session anlegen:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable>
-J -R <replaceable>/path/to/newdata</replaceable></userinput></screen>

      <para>Das DVD+RW-Format erlaubt es, Daten an eine
	vorherige Aufnahme anzuhängen.  Dazu wird eine neue
	Session mit der schon bestehenden zusammengeführt.
	Es wird keine Multi-Session geschrieben, sondern
	&man.growisofs.1; <emphasis>vergrößert</emphasis>
	das ISO-9660-Dateisystem auf dem Medium.</para>

      <para>Das folgende Kommando fügt weitere Daten zu
	einer vorher erstellten DVD+RW hinzu:</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable>
-J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>Wenn Sie eine DVD+RW erweitern, verwenden Sie
	dieselben &man.mkisofs.8;-Optionen wie beim Erstellen
	der DVD+RW.</para>

      <note>
	<para>Verwenden Sie <option>-dvd-compat</option>, um bessere
	  Kompatibilität mit DVD-ROM-Laufwerken zu gewährleisten.
	  Zu einem DVD+RW-Medium können Sie mit dieser Option auch
	  weiterhin Daten hinzufügen.</para>
      </note>

      <para>Um das Medium zu löschen, verwenden Sie:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/
cd0</replaceable>=<replaceable>/dev/zero</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>DVD-RW-Medien benutzen</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RW</secondary>
      </indexterm>

      <para>Eine DVD-RW kann mit zwei Methoden beschrieben werden:
	<firstterm>Sequential-Recording</firstterm> oder
	<firstterm>Restricted-Overwrite</firstterm>.  Voreingestellt
	ist Sequential-Recording.</para>

      <para>Eine neue DVD-RW kann direkt beschrieben werden; sie
	muss nicht vorher formatiert werden.  Allerdings muss
	eine DVD-RW, die mit Sequential-Recording aufgenommen
	wurde, zuerst gelöscht werden, bevor eine neue Session
	aufgenommen werden kann.</para>

      <para>Der folgende Befehl löscht eine DVD-RW im
	Sequential-Recording-Modus:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev/
cd0</replaceable></userinput></screen>

      <note>
	<para>Das vollständige Löschen mit
	  <option>-blank=full</option> dauert mit einem
	  1x&nbsp;Medium ungefähr eine Stunde.  Wenn die DVD-RW im
	  Disk-At-Once-Modus (DAO) aufgenommen wurde, kann sie mit
	  <option>-blank</option> schneller gelöscht werden.  Um eine
	  DVD-RW im DAO-Modus zu brennen, benutzen Sie das folgende
	  Kommando:</para>

	<screen>&prompt.root; <userinput>growisofs -use-the-force-luke=dao -Z
<replaceable>/dev/cd0</replaceable>=<replaceable>imagefile.iso</replaceable>
</userinput></screen>

	<para>Die Option <option>-use-the-force-luke=dao</option>
	  sollte nicht erforderlich sein, da &man.growisofs.1;
	  den DAO-Modus automatisch erkennt.</para>

	<para>Der Restricted-Overwrite-Modus sollte mit jeder
	  DVD-RW verwendet werden, da er flexibler als der
	  voreingestellte Sequential-Recording-Modus ist.</para>
      </note>

      <para>Um Daten auf eine DVD-RW im Sequential-Recording-Modus
	zu schreiben, benutzen Sie dasselbe Kommando wie
	für die anderen DVD-Formate:</para>

      <screen>&prompt.root; <userinput>growisofs -Z <replaceable>/dev/cd0</replaceable>
-J -R <replaceable>/path/to/data</replaceable></userinput></screen>

      <para>Um weitere Daten zu einer Aufnahme hinzuzufügen, benutzen
	Sie <option>-M</option> mit &man.growisofs.1;.  Werden die
	Daten im Sequential-Recording-Modus hinzugefügt, wird eine
	neue Session erstellt.  Das Ergebnis ist ein
	Multi-Session-Medium.</para>

      <para>Eine DVD-RW im Restricted-Overwrite-Modus muss nicht
	gelöscht werden, um eine neue Session aufzunehmen.
	Das Medium kann einfach mit <option>-Z</option>
	überschrieben werden.  Mit <option>-M</option> kann das
	ISO-9660-Dateisystem, wie mit einer DVD+RW, vergrößert werden.
	Die DVD enthält danach eine Session.</para>

      <para>Benutzen sie das nachstehende Kommando, um den
	Restricted-Overwrite-Modus einzustellen:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format <replaceable>/dev
/cd0</replaceable></userinput></screen>

      <para>Das folgende Kommando stellt den Modus wieder auf
	Sequential-Recording zurück:</para>

      <screen>&prompt.root; <userinput>dvd+rw-format -blank=full <replaceable>/dev
/cd0</replaceable></userinput></screen>
    </sect2>

    <sect2>
      <title>Multi-Session</title>

      <para>Nur wenige DVD-ROM-Laufwerke unterstützen
	Multi-Session-DVDs und lesen meist nur die erste Session.
	Mehrere Sessions werden von DVD+R, DVD-R und DVD-RW im
	Sequential-Recording-Modus unterstützt.  Im Modus
	Restricted-Overwrite gibt nur eine Session.</para>

      <para>Wenn das Medium noch nicht geschlossen ist, erstellt
        das nachstehende Kommando eine neue Session auf einer
	DVD+R, DVD-R oder DVD-RW im Sequential-Recording-Modus:</para>

      <screen>&prompt.root; <userinput>growisofs -M <replaceable>/dev/cd0</replaceable>
-J -R <replaceable>/path/to/nextdata</replaceable></userinput></screen>

      <para>Wird dieses Kommando mit DVD+RW- oder DVD-RW-Medien im
	Restricted-Overwrite-Modus benutzt, werden die neuen Daten mit
	den Daten der bestehenden Session zusammengeführt.  Das Medium
	enthält danach eine Session.  Nutzen Sie diese Methode, um
	neue Daten zu einer bestehenden Session hinzuzufügen.</para>

      <note>
	<para>Für den Anfang und das Ende einer Session wird auf dem
	  Medium zusätzlicher Platz verbraucht.  Um den Speicherplatz
	  auf dem Medium optimal auszunutzen, sollten Sie daher
	  Sessions mit vielen Daten hinzufügen.  Auf ein DVD+R-Medium
	  passen maximal 154&nbsp;Sessions, 2000&nbsp;Sessions auf ein
	  DVD-R-Medium und 127&nbsp;Sessions auf eine DVD+R Double
	  Layer.</para>
      </note>
    </sect2>

    <sect2>
      <title>Weiterführendes</title>

      <para><command>dvd+rw-mediainfo
	  <replaceable>/dev/cd0</replaceable></command> zeigt
	Informationen über eine im Laufwerk liegende
	DVD an.</para>

      <para>Weiteres zu <application>dvd+rw-tools</application>
	finden Sie in &man.growisofs.1;, auf der <link 
	  xlink:href="http://fy.chalmers.se/~appro/linux/DVD+RW/">dvd+rw-tools
	  Web-Seite</link> und in den Archiven der <link
	  xlink:href="http://lists.debian.org/cdwrite/">cdwrite-Mailingliste</link>.</para>

      <note>
	<para>Wenn Sie einen Problembericht zur Nutzung der
	  <application>dvd+rw-tools</application> erstellen, fügen Sie
	  immer die Ausgabe von <command>dvd+rw-mediainfo</command>
	  hinzu.</para>
      </note>
    </sect2>

    <sect2 xml:id="creating-dvd-ram">
      <title>DVD-RAM</title>

      <indexterm>
	<primary>DVD</primary>
	<secondary>DVD-RAM</secondary>
      </indexterm>

      <sect3>
	<title>Konfiguration</title>

	<para>DVD-RAM-fähige Brenner nutzten die SCSI- oder
	  ATAPI-Schnittstelle.  Für ATAPI-Geräte muss der DMA-Modus
	  aktiviert werden, indem die folgende Zeile in
	  <filename>/boot/loader.conf</filename> hinzugefügt
	  wird:</para>

	 <programlisting>hw.ata.atapi_dma="1"</programlisting>
      </sect3>

      <sect3>
	<title>Das Medium vorbereiten</title>

	<para>Eine DVD-RAM kann mit einer Wechselplatte vergleichen
	  werden.  Wie diese, muss auch eine DVD-RAM vor dem ersten
	  Einsatz formatiert werden.  In diesem Beispiel wird das
	  gesamte Medium mit dem Standard-UFS2-Dateisystem
	  formatiert:</para>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=<replaceable>/dev/acd0</replaceable> bs=2k count=1</userinput>
&prompt.root; <userinput>bsdlabel -Bw <replaceable>acd0</replaceable></userinput>
&prompt.root; <userinput>newfs <replaceable>/dev/acd0</replaceable></userinput></screen>

	<para>Denken Sie dabei daran, dass Sie gegebenenfalls die
	  Gerätedatei (hier <filename>acd0</filename>) an
	  Ihre Konfiguration anpassen müssen.</para>
      </sect3>

      <sect3>
	<title>Das Medium einsetzen</title>

        <para>Nachdem die DVD-RAM formatiert ist, kann sie wie eine
	  normale Festplatte gemountet werden:</para>

	<screen>&prompt.root; <userinput>mount <replaceable>/dev/acd0</replaceable> <replaceable>/mnt</replaceable></userinput></screen>

	<para>Danach kann schreibend und lesend auf das
	  Medium zugegriffen werden.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="floppies">
    <title>Disketten benutzen</title>
<!--
      <authorgroup>
	<author><personname><firstname>Julio</firstname><surname>Merino</surname></personname><contrib>Original von </contrib></author>
      </authorgroup>
      
      <authorgroup>
	<author><personname><firstname>Martin</firstname><surname>Karlsson</surname></personname><contrib>Umgeschrieben von </contrib></author>
      </authorgroup>
-->

    <para>Dieser Abschnitt beschreibt die Formatierung von
      3,5&nbsp;Zoll Disketten in &os;.</para>

    <procedure>
      <title>Disketten formatieren</title>

	<para>Bevor eine Diskette benutzt werden kann, muss sie
	  (low-level) formatiert werden, was normalerweise der
	  Hersteller schon gemacht hat.  Sie können die Diskette
	  allerdings noch einmal formatieren, um das Medium zu
	  überprüfen.  Benutzen Sie &man.fdformat.1;, um Disketten
	  unter &os; zu formatieren. Achten Sie dabei auf
	  Fehlermeldungen, die schlechte Speichermedien
	  anzeigen.</para>

	<step>
	  <para>Um eine Diskette zu formatieren, legen Sie eine
	    3,5&nbsp;Zoll Diskette in das erste Diskettenlaufwerk ein
	    und führen das folgende Kommando aus:</para>

	  <screen>&prompt.root; <userinput>/usr/sbin/fdformat -f 1440 /dev/fd0</userinput></screen>
	</step>

	<step>
	  <para>Nach dem Formatieren muss auf der Diskette ein
	    Disklabel erstellt werden, um die Größe und Geometrie der
	    Diskette zu erkennen.  Eine Liste der unterstützten
	    Geometrien finden Sie in
	    <filename>/etc/disktab</filename>.</para>

	  <para>Erstellen Sie nun das Label mit &man.bsdlabel.8;:</para>

	  <screen>&prompt.root; <userinput>/sbin/bsdlabel -B -w /dev/fd0 fd1440</userinput></screen>
	</step>

	<step>
	  <para>Auf der Diskette kann nun ein Dateisystem erstellt
	    werden (high-level Formatierung).  Das Dateisystem der
	    Diskette kann entweder UFS oder FAT sein, wobei FAT für
	    Disketten in der Regel die bessere Wahl ist.</para>

	  <para>Um die Diskette mit FAT zu formatieren, geben Sie
	    folgendes Kommando ein:</para>

	  <screen>&prompt.root; <userinput>/sbin/newfs_msdos /dev/fd0</userinput></screen>
	</step>
      </procedure>

      <para>Die Diskette kann nun benutzt werden.  Um die Diskette
	zu verwenden, kann sie mit &man.mount.msdosfs.8; eingehängt
	werden.  Man kann auch <package>emulators/mtools</package> aus
	der Ports-Sammlung installieren, um mit der Diskette zu
	arbeiten.</para>
  </sect1>

  <sect1 xml:id="backups-tapebackups">
    <title>Bandmedien benutzen</title>

    <indexterm><primary>Bandmedien</primary></indexterm>

    <para>Bandmedien haben sich mit der Zeit weiterentwickelt, werden
      jedoch in heutigen Systemen immer weniger verwendet.  Moderne
      Backup-Systeme verwenden
      <foreignphrase>Offsite-Backups</foreignphrase> in Verbindung mit
      lokalen Wechseldatenträgern.  Weiterhin unterstützt &os;
      SCSI-Bandlaufwerke, wie etwa LTO und die älteren DAT-Laufwerke.
      Zusätzlich gibt es begrenzte Unterstützung für SATA- und
      USB-Bandlaufwerke.</para>

    <sect2 xml:id="tapes-sa0">
      <title>Serieller Zugriff mit &man.sa.4;</title>

      <indexterm>
	<primary>Bandlaufwerke</primary>
      </indexterm>

      <para>&os; nutzt den &man.sa.4; Treiber, der die Schnittstellen
	<filename>/dev/sa0</filename>,
	<filename>/dev/nsa0</filename> und
	<filename>/dev/esa0</filename> bereitstellt.  Im üblichen
	Gebrauch wird jedoch meist nur
	<filename>/dev/sa0</filename> benötigt.
	<filename>/dev/nsa0</filename> bezeichnet das selbe
	pysikalische Laufwerk wie <filename>/dev/sa0</filename>,
	aber nach dem Schreiben einer Datei wird das Band nicht
	zurückgespult, was es erlaubt, mehr als eine Datei auf ein
	Band zu schreiben.  Die Verwendung von
	<filename>/dev/esa0</filename> wirft das Band aus,
	nachdem das Gerät geschlossen wurde.</para>
    </sect2>

    <sect2>
      <title>Steuerung des Bandlaufwerks mit &man.mt.1;</title>

      <indexterm>
	<primary>Bandmedien</primary>
	<secondary>mt</secondary>
      </indexterm>

      <para>&man.mt.1; ist das &os; Dienstprogramm für die Steuerung
	weiterer Optionen des Bandlaufwerks, wie zum Beispiel die
	Suche nach Dateien auf dem Band, oder um Kontrollmarkierungen
	auf das Band zu schreiben.</para>

      <para>Beispielsweise können die ersten drei Dateien auf einem
	Band erhalten bleiben, indem diese übersprungen werden,
	bevor eine neue Datei geschrieben wird:</para>

      <screen>&prompt.root; <userinput>mt -f /dev/nsa0 fsf 3</userinput></screen>
    </sect2>

    <sect2>
      <title xml:id="tapes-tar">Benutzung von &man.tar.1; zum Lesen
	und Schreiben von Bandsicherungen</title>

      <para>Hier ein Beispiel, wie eine einzelne Datei mittels
	&man.tar.1; auf ein Band geschrieben wird:</para>

      <screen>&prompt.root; <userinput>tar cvf /dev/sa0 <replaceable>file</replaceable></userinput></screen>

      <para>Wiederherstellung von Dateien aus dem &man.tar.1;-Archiv
	von Band in das aktuelle Verzeichnis:</para>

      <screen>&prompt.root; <userinput>tar xvf /dev/sa0</userinput></screen>
    </sect2>

    <sect2>
      <title xml:id="tapes-dumprestore">Die Benutzung von &man.dump.8;
	und &man.restore.8; zum Erstellen und Wiederherstellen von
	Sicherungen.</title>

      <para>Ein einfache Sicherung von
	<filename class="directory">/usr</filename> mit
	&man.dump.8;:</para>

      <screen>&prompt.root; <userinput>dump -0aL -b64 -f /dev/nsa0 /usr</userinput></screen>

      <para>Interaktive Wiederherstellung von Dateien aus einer
	&man.dump.8;-Datei von Band in das aktuelle
	Verzeichnis:</para>

      <screen>&prompt.root; <userinput>restore -i -f /dev/nsa0</userinput></screen>
    </sect2>

    <sect2>
      <title xml:id="tapes-othersoftware">Weitere Software zur
	Bandsicherung</title>

      <para>Es stehen weitere Programme zur Vereinfachung von
	Bandsicherungen zur Verfügung.  Zu den bekanntesten gehören
	<application>Amanda</application> und
	<application>Bacula</application>.  Diese Programme zielen
	darauf ab, Sicherungen einfacher und bequemer zu machen, oder
	um komplexe Sicherungen mehrerer Maschinen zu automatisieren.
	Die Ports-Sammlung enthält sowohl diese, als auch weitere
	Programme für die Bandsicherung.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="backup-strategies">
    <info><title>Backup-Strategien</title>
      <authorgroup>
	<author><personname><firstname>Lowell</firstname><surname>Gilbert</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    

    <para>Wenn Sie eine eigene Backup-Strategie planen, müssen Sie
      darauf achten, dass jedes der folgenden Probleme von Ihrer
      Strategie abgedeckt wird:</para>

    <itemizedlist>
      <listitem>
        <para>Plattendefekte.</para>
      </listitem>
      <listitem>
        <para>Versehentliches Löschen von Dateien.</para>
      </listitem>
      <listitem>
        <para>Eine nicht vorhersehbare Korrumpierung von Dateien.</para>
      </listitem>
      <listitem>
        <para>Die vollständige Zerstörung Ihres Systems, etwa
          durch ein Feuer.  Dazu gehört auch die Zerstörung
          von Backups, die am gleichen Ort aufbewahrt werden.</para>
      </listitem>
    </itemizedlist>

    <para>Einige Systeme werden am besten geschützt, wenn für jedes
      dieser Probleme eine eigene (oft völlig unterschiedliche)
      Strategie besteht.  Es ist vielmehr unwahrscheinlich (sieht man
      von Systemen ab, die keine wichtigen Daten enthalten),  dass
      eine Technik alle Problembereiche abdecken kann.</para>

    <para>Einige mögliche Techniken sind unter anderen:</para>

    <itemizedlist>
      <listitem>
	<para>Die Archivierung des kompletten Systems auf externen
	  Datenträgern, die an einem gesonderten Ort aufbewahrt
	  werden.  Dieser Ansatz schützt zwar vor allen oben
	  angeführten Problemen, ist aber zeitaufwändig.
	  Auch eine Wiederherstellung des Systems ist nicht ohne
	  weiteres möglich.  Zwar können Kopien Ihrer
	  Backups auch vor Ort und/oder auf online zugängigen
	  Systemen aufbewahrt werden, was aber nichts daran ändert,
	  dass eine Wiederherstellung, insbesondere für nicht
	  privilegierte Benutzer, nach wie vor nicht ohne weiteres
	  möglich ist.</para>
      </listitem>

      <listitem>
	<para>Dateisystem-Snapshots helfen zwar nur gegen das
	  versehentliche Löschen von Dateien, in einem solchen Fall
	  sind sie aber <emphasis>äußerst</emphasis> hilfreich.  Ein
	  weiterer Vorteil ist die schnelle und einfache
	  Handhabung.</para>
      </listitem>

      <listitem>
	<para>Das Erstellen von Kopien ganzer Dateisysteme oder
	  Platten (etwa durch einen periodischen
	  &man.rsync.1;-Transfer des kompletten Systems).  Diese
	  Technik ist insbesondere in Netzwerken mit besonderen
	  Anforderungen nützlich.  Der Schutz vor Plattendefekten
	  ist allerdings schlechter als beim Einsatz von
	  <acronym>RAID</acronym>.  Die Fähigkeiten zur
	  Wiederherstellung gelöschter Dateien sind mit denen von
	  <acronym>UFS</acronym>-Snapshots vergleichbar.</para>
      </listitem>

      <listitem>
	<para><acronym>RAID</acronym>.  Minimiert oder vermeidet
	  Ausfallzeiten, die durch einen Plattendefekt verursacht
	  werden könnten.  Zwar können Plattendefekte aufgrund der
	  höheren Anzahl verwendeter Platten häufiger auftreten, sie
	  stellen aber dann kein so akutes Problem dar.</para>
      </listitem>

      <listitem>
	<para>Das Überprüfen von Datei-Fingerprints durch
	  &man.mtree.8;.  Dabei handelt es sich zwar um keine
	  Backup-Technik im eigentlichen Sinne, Sie werden durch den
	  Einsatz dieses Werkzeugs aber informiert, dass Sie auf Ihre
	  Backups zurückgreifen müssen.  Dies ist insbesondere
	  beim Einsatz von Offline-Backups von großer Bedeutung.
	  Daher sollte diese Technik regelmäßig eingesetzt
	  werden.</para>
      </listitem>
    </itemizedlist>

    <para>Es gibt noch weitere Techniken, von denen aber viele nur
      Variationen der eben beschriebenen Techniken sind.  Spezielle
      Anforderungen erfordern dabei in der Regel auch spezielle
      Backup-Techniken.  So erfordert das Backup einer aktiven
      Datenbank in der Regel ein auf die eingesetzte
      Datenbank-Software abgestimmtes Verfahren.  Entscheidend ist
      daher immer, gegen welche Gefahren man sich schützen will und
      wie dieser Schutz realisiert wird.</para>
  </sect1>

  <sect1 xml:id="backup-basics">
    <title>Datensicherung</title>

    <para>Die wichtigsten Programme zur Sicherung von Daten in &os;
      sind &man.dump.8;, &man.tar.1;, &man.cpio.1; und
      &man.pax.1;.</para>

    <sect2>
      <title>Sichern und Wiederherstellen</title>
      <indexterm><primary>Datensicherung</primary></indexterm>
      <indexterm><primary>Backup</primary></indexterm>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>dump</command></secondary>
      </indexterm>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>restore</command></secondary>
      </indexterm>
      <indexterm><primary><command>dump</command></primary></indexterm>
      <indexterm><primary><command>restore</command></primary></indexterm>

      <para><command>dump</command> und <command>restore</command>
	sind die traditionellen Backup-Programme in &unix; Systemen.
	Sie betrachten das Laufwerk als eine Ansammlung von Blöcken,
	operieren also unterhalb des Abstraktionslevels von Dateien,
	Links und Verzeichnissen, die die Grundlage des
	Dateisystemkonzepts bilden.  Im Gegensatz zu anderen
	Backup-Programmen sichert <command>dump</command> ein ganzes
	Dateisystem auf einem Gerät.  Es ist nicht möglich nur einen
	Teil des Dateisystems, oder einen Verzeichnisbaum, der mehr
	als ein Dateisystem umfasst, zu sichern.
	<command>dump</command> schreibt keine Dateien oder
	Verzeichnisse, sondern die Blöcke, aus denen Dateien und
	Verzeichnisse bestehen.  Wenn <command>restore</command> für
	das Extrahieren von Daten verwendet wird, werden temporäre
	Dateien standardmäßig in <filename>/tmp/</filename> abgelegt.
	Wenn Sie von einer Platte mit einem kleinen
	<filename>/tmp</filename>-Verzeichnis zurücksichern, setzen
	Sie die Umgebungsvariable <envar>TMPDIR</envar> auf ein
	Verzeichnis mit mehr freiem Speicherplatz, damit die
	Wiederherstellung gelingt.</para>

      <note>
	<para>Wird <command>dump</command> benutzt, um das
	  Root-Verzeichnis zu sichern, werden
	  <filename>/home</filename>, <filename>/usr</filename> und
	  viele andere Verzeichnisse nicht gesichert, da dies
	  normalerweise Mountpunkte für andere Dateisysteme oder
	  symbolische Links zu diesen Dateisystemen sind.</para>
      </note>

      <para><command>dump</command> hat einige Eigenarten, die noch aus den
        frühen Tagen der Version 6 von AT&amp;T &unix; (ca. 1975)
	stammen.  Die Parameter
        sind für 9-Spur-Bänder (6250&nbsp;bpi) voreingestellt,
	nicht auf die heute üblichen Medien hoher Dichte (bis zu
	62.182&nbsp;ftpi).  Bei der Verwendung der Kapazitäten
	moderner Bandlaufwerke muss diese Voreinstellung auf der
	Kommandozeile überschrieben werden.</para>

      <indexterm><primary><filename>.rhosts</filename></primary></indexterm>

      <para><command>rdump</command> und <command>rrestore</command>
	können Daten über Netzwerk auf ein Band, das sich in einem
	Laufwerk eines anderen Computers befindet, überspielen.  Beide
	Programme benutzen die Funktionen &man.rcmd.3; und
	&man.ruserok.3; zum Zugriff auf das entfernte Bandlaufwerk.
	Daher muss der Anwender, der das Backup durchführt, auf dem
	entfernten Rechner in <filename>.rhosts</filename> eingetragen
	sein.  Die Argumente zu <command>rdump</command> und
	<command>rrestore</command> müssen zur Verwendung auf dem
	entfernten Computer geeignet sein. Wenn zum Beispiel mit
	<command>rdump</command> von einem &os;-Rechner aus auf ein
	Exabyte-Bandlaufwerk mit Namen <systemitem>komodo</systemitem>
	zugreifen werden soll, nutzen Sie:</para>

      <screen>&prompt.root; <userinput>/sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&amp;1</userinput></screen>

      <para>Die Authentifizierung über <filename>.rhosts</filename>
	  stellt ein Sicherheitsrisiko dar.  Nutzen Sie diese Funktion
	  also mit Vorsicht.</para>

      <para>Es ist auch möglich, <command>dump</command> und
	<command>restore</command> über eine gesicherte Verbindung
	mit <command>ssh</command> einzusetzen:</para>

      <example>
	<title><command>dump</command> mit <application>ssh</application>
	  benutzen</title>
	<screen>&prompt.root; <userinput>/sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
	  targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz</userinput></screen>
      </example>

      <para>Alternativ kann das integrierte <envar>RSH</envar> benutzt
	werden.</para>

      <example>
	<title><command>dump</command> über <application>ssh</application>
	  mit gesetzter <envar>RSH</envar> benutzen</title>

	<screen>&prompt.root; <userinput>env RSH=/usr/bin/ssh /sbin/dump -0uan -f tatargetuser@targetmachine.example.com:/dev/sa0 /usr</userinput></screen>
      </example>
    </sect2>

    <sect2>
      <title><command>tar</command></title>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>tar</command></secondary>
      </indexterm>

      <para>&man.tar.1; stammt ebenfalls aus Version 6 von AT&amp;T
	&unix; (ca. 1975).  <command>tar</command> arbeitet mit dem
	Dateisystem und schreibt Dateien und Verzeichnisse auf das
	Band.  <command>tar</command> unterstützt zwar nicht alle
	Optionen, die bei &man.cpio.1; zur Verfügung stehen, aber
	dafür erfordert es auch nicht die ungewöhnliche
	Kommando-Pipeline, die von <command>cpio</command> verwendet
	wird.</para>

      <indexterm><primary><command>tar</command></primary></indexterm>

      <para>Um Daten mit <command>tar</command> auf ein
	angeschlossenes Exabyte-Bandlaufwerk am Host
	<systemitem>komodo</systemitem> zu archivieren:</para>

      <screen>&prompt.root; <userinput>tar cf - . | rsh komodo dd of=<replaceable>tape-
device</replaceable> obs=20b</userinput></screen>

      <para>Bei der Sicherung über ein unsicheres Netzwerk, sollte
	stattdessen <command>ssh</command> benutzt werden.</para>
    </sect2>

    <sect2>
      <title>Cpio</title>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>cpio</command></secondary>
      </indexterm>
      <indexterm>
	<primary><command>cpio</command></primary>
      </indexterm>

      <para>&man.cpio.1; ist das ursprüngliche Programm von
	&unix; Systemen zum Dateitransfer mit magnetischen Medien.
	<command>cpio</command> hat Optionen zum Byte-Swapping, zum
	Schreiben einer Anzahl verschiedener Archivformate und zum
	Weiterleiten von Daten an andere Programme über eine Pipeline.
	Dieses letzte Leistungsmerkmal macht <command>cpio</command>
	zu einer ausgezeichneten Wahl für Installationsmedien.
	<command>cpio</command> kann jedoch keine Dateibäume
	durchlaufen, so dass eine Liste der zu bearbeitenden Dateien
	über <filename>stdin</filename> angegeben werden muss.</para>

      <indexterm>
	<primary><command>cpio</command></primary>
      </indexterm>

      <para><command>cpio</command> unterstützt keine Backups
	über das Netzwerk.  Man kann aber eine Pipeline und
	<command>ssh</command> verwenden, um Daten an ein entferntes
	Bandlaufwerk zu senden.</para>

      <screen>&prompt.root; <userinput>for f in directory_list; do</userinput>
<userinput>find $f &gt;&gt; backup.list</userinput>
<userinput>done</userinput>
&prompt.root; <userinput>cpio -v -o --format=newc &lt; backup.list | ssh user@host "cat &gt; backup_device"</userinput></screen>

      <para>Dabei steht <replaceable>directory_list</replaceable> für
	eine Aufzählung der Verzeichnisse, die gesichert werden
	sollen.  <replaceable>user</replaceable>@<replaceable>host</replaceable>
	gibt den Benutzer auf dem Zielrechner an, der die Sicherung
	laufen lässt.  Der Ort der Sicherung wird durch
	<replaceable>backup_device</replaceable> angegeben,
	beispielsweise<filename>/dev/nsa0</filename>.</para>
    </sect2>

    <sect2>
      <title><command>pax</command></title>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><command>pax</command></secondary>
      </indexterm>
      <indexterm><primary><command>pax</command></primary></indexterm>
      <indexterm><primary>POSIX</primary></indexterm>
      <indexterm><primary>IEEE</primary></indexterm>

      <para>&man.pax.1; ist IEEE/&posix; Antwort auf
	<command>tar</command> und <command>cpio</command>.  Über die
	Jahre hinweg sind die verschiedenen Versionen von
	<command>tar</command> und <command>cpio</command> leicht
	inkompatibel geworden.  Daher hat &posix;, statt eine
	Standardisierung zwischen diesen auszufechten, ein neues
	Archivprogramm geschaffen.  <command>pax</command> versucht
	viele der unterschiedlichen <command>cpio</command>- und
	<command>tar</command>-Formate zu lesen und zu schreiben,
	außerdem einige neue, eigene Formate.  Die Kommandostruktur
	ähnelt eher <command>cpio</command> als
	<command>tar</command>.</para>
    </sect2>

    <sect2 xml:id="backups-programs-amanda">
      <title><application>Amanda</application></title>
      <indexterm>
	<primary>Backup-Software</primary>
	<secondary><application>Amanda</application></secondary>
      </indexterm>
      <indexterm>
	<primary><application>Amanda</application></primary>
      </indexterm>

      <!-- Remove link until <port> tag is available -->
      <para><application>Amanda</application>
        (Advanced Maryland Network Disk Archiver) ist ein
        Client/Server-Backupsystem, nicht nur ein einzelnes Programm.
	Ein <application>Amanda</application>-Server kann auf einem
	einzigen Bandlaufwerk Datensicherungen von jeder beliebigen
	Anzahl von Computern speichern, sofern auf diesen jeweils ein
	<application>Amanda</application>-Client läuft und sie
	über Netzwerk mit dem <application>Amanda</application>-Server
	verbunden sind.</para>

      <para>Ein häufiges Problem bei Standorten mit einer Anzahl
	großer Festplatten ist, dass das Kopieren der Daten auf Band
	langsamer vor sich geht als solche Daten anfallen.
	<application>Amanda</application> löst dieses Problem durch
	Verwendung einer <quote>Holding Disk</quote>, einer Festplatte
	zum gleichzeitigen Zwischenspeichern mehrerer
	Dateisysteme.</para>

      <para>Für Datensicherungen über einen längeren
	Zeitraum erzeugt <application>Amanda</application>
	<quote>Archivsets</quote> von allen Dateisystemen, die in
	<application>Amandas</application> Konfigurationsdatei genannt
	werden.  Ein Archivset ist eine Gruppe von Bändern mit vollen
	Backups und Reihen von inkrementellen oder differentiellen
	Backups, die jeweils nur die Unterschiede zum vorigen Backup
	enthalten.  Zur Wiederherstellung von beschädigten
	Dateisystemen benötigt man Das Letzte volle Backup und alle
	darauf folgenden inkrementellen Backups.</para>

      <para>Die Konfigurationsdatei ermöglicht die Feineinstellung
	der Backups und des Netzwerkverkehrs von
	<application>Amanda</application>.
	<application>Amanda</application> kann zum Schreiben der Daten
	auf das Band jedes der oben beschriebenen Backuprogramme
	verwenden.  <application>Amanda</application> ist nicht Teil
	des Basissystems, es muss über die Ports-Sammlung oder als
	Paket installiert werden.</para>
    </sect2>

    <sect2>
      <title>Tue nichts</title>

      <para><quote>Tue nichts</quote> ist kein Computerprogramm, sondern die
        am häufigsten angewendete Backupstrategie.  Diese kostet nichts,
        man muss keinen Backup Plan befolgen, einfach nur nein sagen.  Wenn
        etwas passiert, einfach grinsen und ertragen!</para>

      <para>Wenn Ihre Zeit und Daten nicht so wichtig sind, dann ist
	die Strategie <quote>Tue nichts</quote> das geeignetste
	Backup-Programm für den Computer.  Aber &unix; ist ein
	nützliches Werkzeug, und im Laufe der Zeit kann es dazu
	verwendet werden, eine Sammlung von Dateien zu schaffen, die
	wertvoll sind.</para>

      <para><quote>Tue nichts</quote> ist die richtige Backupmethode
	für <filename>/usr/obj</filename> und andere Verzeichnisbäume,
	die vom Computer exakt wiedererzeugt werden können.  Ein
	Beispiel sind die Dateien, die diese Handbuchseiten darstellen
	&ndash; sie wurden aus Quelldateien im Format XML erzeugt.  Es
	ist nicht nötig, Sicherheitskopien der HTML- oder
	&postscript;-Dateien zu erstellen, solange die
	<acronym>XML</acronym>-Dateien in regelmäßige Backups mit
	einbezogen werden.</para>
    </sect2>

    <sect2>
      <title>Welches Backup-Programm ist am Besten?</title>
      <indexterm>
	<primary>LISA</primary>
      </indexterm>

      <para><command>dump</command>, <emphasis>Punkt und Schluss.</emphasis>
	Elizabeth&nbsp;D. Zwicky hat alle hier genannten Backup-Programme
	bis zur Erschöpfung ausgetestet.  Ihre eindeutige Wahl zur
	Sicherung aller Daten mit Berücksichtigung aller Besonderheiten
	von &unix; Dateisystemen ist <command>dump</command>.</para>

      <para>Elizabeth erzeugte Dateisysteme mit einer großen Vielfalt
        ungewöhnlicher Bedingungen (und einiger gar nicht so
        ungewöhnlicher) und testete jedes Programm durch ein Backup und
        eine Wiederherstellung dieser Dateisysteme.  Unter den Besonderheiten
        waren Dateien mit Löchern, Dateien mit Löchern und einem
        Block mit Null-Zeichen, Dateien mit ausgefallenen Buchstaben im
        Dateinamen, unlesbare und nichtschreibbare Dateien,
        Gerätedateien, Dateien, deren Länge sich während des
        Backups ändert, Dateien, die während des Backups erzeugt und
        gelöscht werden, u.v.m.  Sie berichtete über ihre Ergebnisse
        in LISA V im Oktober 1991, s. <link xlink:href="http://www.coredumps.de/doc/dump/zwicky/testdump.doc.html">Torture-testing
          Backup and Archive Programs</link>.</para>
    </sect2>

    <sect2>
      <title>Die Wiederherstellung in einem Notfall</title>

      <sect3>
        <title>Vor dem Unglück</title>

	<para>Es sind vier Vorkehrungen zu treffen, um auf jedes
	  erdenkliche Unglück vorbereitet zu sein.</para>

	<indexterm>
	  <primary><command>bsdlabel</command></primary>
	</indexterm>

	<para>Als erstes drucken Sie das bsdlabel jeder Festplatte mit
	  einem Befehl wie <command>bsdlabel da0 | lpr</command>.
	  Drucken Sie ebenfalls eine Kopie von
	  <filename>/etc/fstab</filename>) sowie alle
	  Bootmeldungen.</para>

	<indexterm><primary>Live-CD</primary></indexterm>

        <para>Zweitens, brennen Sie eine <quote>livefs</quote>-CD.
	  Diese CD-ROM enthält alle nötigen Programme, um in einen
          Reperaturmodus zu starten, aus dem heraus Sie unter anderem
          &man.dump.8;, &man.restore.8;, &man.fdisk.8;,
	  &man.bsdlabel.8;, &man.newfs.8; sowie &man.mount.8; starten
	  können.  ISO-Abbilder für das <quote>livefs</quote>-System
	  finden Sie unter <uri
	    xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel2.current;/&os;-&rel2.current;-RELEASE-&arch.i386;-livefs.iso">ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/ISO-IMAGES/&rel.current;/&os;-&rel.current;-RELEASE-&arch.i386;-livefs.iso</uri>.</para>

	<note>
	  <para>Seit &os;&nbsp;9.0-RELEASE sind ISO-Abbilder
	    für das <quote>livefs</quote>-System nicht mehr verfügbar.
	    Neben den ISO-Abbildern für CD-ROM können auch Abbilder
	    für USB-Datenspeicher verwendet werden, um ein System
	    wiederherzustellen.  Das <quote>memstick</quote>-Abbild
	    für &os;/&arch.i386;&nbsp;&rel.current;-RELEASE finden Sie
	    unter <uri
	      xlink:href="ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/&arch.i386;/ISO-IMAGES/&rel.current;/&os;-&rel.current;-RELEASE-&arch.i386;-memstick.img">ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/&arch.i386;/&arch.i386;/ISO-IMAGES/&rel.current;/&os;-&rel.current;-RELEASE-&arch.i386;-memstick.img</uri>.</para>
	</note>

        <para>Drittens, machen Sie regelmäßig Backups auf Band.
	  Jede Änderung seit dem letzten Backup kann
	  unwiederbringlich verloren gehen.  Versehen Sie die
	  Backup-Bänder mit Schreibschutz.</para>

	<para>Viertens, testen Sie das erstellte
	  <quote>livefs</quote>-System sowie die Backups.
	  Dokumentieren Sie diesen Test und bewahren Sie diese
	  Notizen zusammen mit der <quote>livefs</quote>-CD und den
	  Backups.  Diese Notizen können Ihnen im Notfall helfen
	  eine versehentliche Zerstörung des Backups zu verhindern,
	  während Sie unter Druck eine Wiederherstellung
	  durchführen.</para>

	<para>Als zusätzliche Sicherheitsvorkehrung, kann man jeweils
	  die <quote>livefs</quote>-CD und Bänder doppelt erstellen.
	  Eine der Kopien sollte an einem entfernten Standort
	  aufbewahrt werden.  Ein entfernter Standort ist NICHT der
	  Keller im gleichen Gebäude.  Ein entfernter Standort sollte
	  von den Computern und den Festplatten physikalisch durch
	  eine erhebliche Entfernung getrennt sein.</para>
      </sect3>

      <sect3>
        <title>Nach dem Unglück</title>

	<para>Prüfen Sie als Erstes, ob die Hardware überlebt hat.
	  Dank regelmäßigen
	  <foreignphrase>Offside-Backups</foreignphrase> besteht kein
	  Grund, sich um die Software Sorgen zu machen.</para>

        <para>Falls die Hardware beschädigt wurde, ersetzen Sie zuerst
          die defekten Teile bevor Sie den Computer benutzen.</para>

	<para>Falls die Hardware funktioniert, legen Sie die
	  <quote>livefs</quote>-CD ein und starten den Rechner.  Das
	  originale Installationsprogramm wird auf dem Bildschirm
	  angezeigt werden.  Legen Sie zuerst Ihr Land fest.  Danach
	  öffnen Sie das Menü
	  <literal>Fixit -- Repair mode with CD-ROM/DVD/floppy or start
	    a shell.</literal> und wählen den Eintrag
	  <guimenuitem>CD-ROM/DVD -- Use the live filesystem
	    CD-ROM/DVD</guimenuitem> aus.  <command>restore</command>
	  und die anderen benötigten Programme, befinden sich dann im
	  Verzeichnis <filename>/mnt2/rescue</filename>.</para>

        <para>Stellen Sie die Dateisysteme nacheinander wieder her.</para>

	<indexterm>
	  <primary><command>mount</command></primary>
	</indexterm>
	<indexterm>
	  <primary>Root-Partition</primary>
	</indexterm>
	<indexterm>
	  <primary><command>bsdlabel</command></primary>
	</indexterm>
	<indexterm>
	  <primary><command>newfs</command></primary>
	</indexterm>

	<para>Versuchen Sie mit <command>mount</command> die
	  Root-Partition der ersten Festplatte einzuhängen.  Wenn das
	  bsdlabel beschädigt wurde, benutzen Sie
	  <command>bsdlabel</command> um die Platte neu zu
	  partitionieren und zu benennen und zwar so, dass die
	  Festplatte mit dem Label übereinstimmt, welches ausgedruckt
	  und aufbewahrt wurde.</para>

	<para>Verwenden Sie <command>newfs</command> um die
	  Dateisysteme neu zu erstellen.  Hängen Sie mit
	  <command>mount -u -o rw /mnt</command> die Root-Partition
	  der Festplatte mit Schreibzugriff ein.  Benutzen Sie die
	  Backups, um die Daten für das jeweilige Dateisystem
	  wieder her zu stellen. Hängen Sie das Dateisystem mit
	  <command>umount /mnt</command> wieder aus.  Wiederholen Sie
	  diesen Ablauf für jedes beschädigte Dateisystem.</para>

	<para>Sobald das System wieder läuft, machen Sie gleich wieder
	  ein vollständiges Backup auf neue Bänder.  Denn die Ursache
	  für den Absturz oder den Datenverlust kann wieder
	  zuschlagen.  Eine weitere Stunde, die Sie jetzt noch
	  investieren, kann später weiteres Missgeschick
	  ersparen.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-virtual">
    <info><title>Netzwerk-, speicher- und dateibasierte Dateisysteme</title>
      <authorgroup>
	<author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Verbessert und neu strukturiert von </contrib></author>
      </authorgroup>
    </info>
    
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>virtuelle</secondary>
    </indexterm>

    <para>Neben physikalischen Laufwerken, wie Disketten, CDs und
      Festplatten, unterstützt &os; auch
      <firstterm>virtuelle Laufwerke</firstterm>.</para>

    <indexterm><primary>NFS</primary></indexterm>
    <indexterm><primary>Coda</primary></indexterm>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>speicherbasierte</secondary>
    </indexterm>
    <indexterm>
      <primary>Laufwerke</primary>
      <secondary>RAM-Disks</secondary>
    </indexterm>

    <para>Dazu zählen Netzwerkdateisysteme wie
      <link linkend="network-nfs">Network Filesystem</link> und Coda,
      speicher- und dateibasierte Dateisysteme.</para>

    <para>Abhängig von der verwendeten &os; Version werden
      speicher- und dateibasierte Dateisysteme mit unterschiedlichen
      Werkzeugen angelegt.</para>

    <note>
      <para>Gerätedateien werden unter &os; automatisch
	von &man.devfs.5; angelegt.</para>
    </note>

    <sect2 xml:id="disks-mdconfig">
      <title>Dateibasierte Laufwerke unter FreeBSD</title>
      <indexterm>
        <primary>Laufwerke</primary>
        <secondary>dateibasierte</secondary>
      </indexterm>

      <para>Unter &os; werden virtuelle Laufwerke, &man.md.4;,
	mit &man.mdconfig.8; erzeugt.  Dazu muss das Modul
	&man.md.4; geladen sein.  Bei der Verwendung einer eigenen
	Kernelkonfiguration, muss diese Zeile enthalten sein:</para>

      <programlisting>device md</programlisting>

      <para>&man.mdconfig.8; unterstützt verschiedene Arten von
	speicherbasierten virtuellen Laufwerken: speicherbasierte
	Laufwerke, deren Speicher von &man.malloc.9; zur Verfügung
	gestellt wird, und dateibasierte Laufwerke, deren Speicher von
	einer Datei oder dem Swap-Bereich zur Verfügung gestellt wird.
	Eine mögliche Anwendung ist das Einhängen von CD-ROMs.</para>

      <para>Das Abbild eines Dateisystems wird wie folgt
        eingehangen:</para>

      <example>
	<title>Einhängen eines existierenden Abbildes unter
	  &os;</title>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f diskimage -u 0</userinput>
&prompt.root; <userinput>mount /dev/md0 /mnt</userinput></screen>
      </example>

      <para>Ein neues Dateisystem-Abbild erstellen Sie mit
        &man.mdconfig.8; wie folgt:</para>

      <example>
	<title>Erstellen eines dateibasierten Laufwerks mit
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=newimage bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdconfig -a -t vnode -f newimage -u 0</userinput>
&prompt.root; <userinput>bsdlabel -w md0 auto</userinput>
&prompt.root; <userinput>newfs md0a</userinput>
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups (for fsck -b #) at:
 160, 2720, 5280, 7840
&prompt.root; <userinput>mount /dev/md0a /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</screen>
      </example>

      <para>Wenn keine Gerätenummer mit <option>-u</option> angegeben
	ist, wird von &man.md.4; automatisch eine
	ungenutzte Gerätenummer zugewiesen.  Das zugewiesene Gerät
	wird auf der Standardausgabe ausgegeben (zum Beispiel
	<filename>md4</filename>).  Weitere Informationen finden Sie
	in &man.mdconfig.8;.</para>

      <para>Obwohl &man.mdconfig.8; sehr nützlich ist, benötigt es
	einige Kommandos, um ein dateibasiertes Dateisystem zu
	erstellen.  &os; enthält auch &man.mdmfs.8;, das die
	notwendigen Schritte in einem Befehl zusammenfasst.  Es
	konfiguriert mit &man.mdconfig.8; ein &man.md.4;-Laufwerk,
	erstellt darauf mit &man.newfs.8; ein UFS-Dateisystem und
	hängt es anschließend mit &man.mount.8; ein.  Das virtuelle
	Laufwerk aus dem obigen Beispiel kann mit den nachstehenden
	Befehlen erstellt werden:</para>

      <example>
	<title>Mit <command>mdmfs</command> ein dateibasiertes
	  Dateisystem erstellen</title>

	<screen>&prompt.root; <userinput>dd if=/dev/zero of=newimage bs=1k count=5k</userinput>
5120+0 records in
5120+0 records out
&prompt.root; <userinput>mdmfs -F newimage -s 5m md0 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0        4718    4  4338     0%    /mnt</screen>
      </example>

      <para>Wenn <option>md</option> ohne Gerätenummer verwendet wird,
	wählt &man.md.4; automatisch ein ungenutztes
	Gerät aus.  Weitere Einzelheiten entnehmen Sie bitte der
	Hilfeseite &man.mdmfs.8;.</para>
    </sect2>

    <sect2 xml:id="disks-md-freebsd5">
      <title>Speicherbasierte Laufwerke unter FreeBSD</title>

      <indexterm>
	<primary>Laufwerke</primary>
	<secondary>speicherbasierte</secondary>
      </indexterm>

      <para>Bei einem speicherbasierten Dateisystem sollte
	<quote>swap backing</quote> aktiviert werden.  Das heißt
	allerdings nicht, dass das speicherbasierte Laufwerk
	automatisch auf die Festplatte ausgelagert wird, vielmehr
	wird der Speicherplatz danach aus einem Speicherpool
	angefordert, der bei Bedarf auf die Platte ausgelagert werden
	kann.  Zusätzlich ist es möglich, &man.malloc.9;-gestützte
	speicherbasierte Laufwerke zu erstellen.  Das Anlegen solcher
	Laufwerke kann allerdings zu einer System-Panic führen, wenn
	der Kernel danach über zu wenig Speicher verfügt.</para>

      <example>
	<title>Erstellen eines speicherbasierten Laufwerks mit
	  <command>mdconfig</command></title>

	<screen>&prompt.root; <userinput>mdconfig -a -t swap -s 5m -u 1</userinput>
&prompt.root; <userinput>newfs -U md1</userinput>
/dev/md1: 5.0MB (10240 sectors) block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups (for fsck -b #) at:
 160, 2752, 5344, 7936
&prompt.root; <userinput>mount /dev/md1 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</screen>
      </example>

      <example>
	<title>Erstellen eines speicherbasierten Laufwerks mit
	  <command>mdmfs</command></title>
	<screen>&prompt.root; <userinput>mdmfs -s 5m md2 /mnt</userinput>
&prompt.root; <userinput>df /mnt</userinput>

&prompt.root; <userinput>df /mnt</userinput>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md2        4846    2  4458     0%    /mnt</screen>
      </example>
    </sect2>

    <sect2>
      <title>Virtuelle Laufwerke freigeben</title>
      <indexterm>
        <primary>Laufwerke</primary>
        <secondary>Freigabe von virtuellen Laufwerken</secondary>
      </indexterm>

      <para>Wenn ein virtuelles Laufwerk nicht mehr in Gebrauch ist,
	sollten seine belegten Ressourcen an das System zurückgegeben
	werden.  Zuerst wird das Dateisystem abgehängt und dann die
	benutzten Ressourcen mit &man.mdconfig.8; freigegeben.</para>

      <para>Alle von <filename>/dev/md4</filename> belegten Ressourcen
        werden mit dem nachstehenden Kommando freigegeben:</para>

      <screen>&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

      <para>Informationen zu eingerichteten &man.md.4;-Geräten werden
	mit <command>mdconfig -l</command> angezeigt.</para>

    </sect2>
  </sect1>

  <sect1 xml:id="snapshots">
    <info><title>Schnappschüsse von Dateisystemen</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      
    </info>

    

    <indexterm>
      <primary>Schnappschüsse</primary>
      <secondary>von Dateisystemen</secondary>
    </indexterm>

    <para>Zusammen mit
      <link linkend="soft-updates">Soft Updates</link> bietet &os;
      eine weitere Funktion: Schnappschüsse von Dateisystemen.</para>

    <para>UFS-Schnappschüsse sind Dateien, die ein Abbild eines
      Dateisystems enthalten und müssen auf dem jeweiligen Dateisystem
      erstellt werden.  Pro Dateisystem darf es maximal
      20&nbsp;Schnappschüsse, die im Superblock vermerkt werden,
      geben.  Schnappschüsse bleiben erhalten, wenn das Dateisystem
      abgehangen, neu eingehangen oder das System neu gestartet wird.
      Wenn ein Schnappschuss nicht mehr benötigt wird, kann er
      mit &man.rm.1; gelöscht werden.  Es ist egal, in welcher
      Reihenfolge Schnappschüsse gelöscht werden.  Es kann allerdings
      vorkommen, dass nicht der gesamte Speicherplatz wieder
      freigegeben wird, da ein anderer Schnappschuss einen Teil der
      entfernten Blöcke für sich beanspruchen kann.</para>

    <para>Das unveränderliche <option>Snapshot</option>-Dateiflag
      wird nach der Erstellung des Snaphshots von &man.mksnap.ffs.8;
      gesetzt.  Durch die Verwendung von &man.unlink.1; ist es
      allerdings möglich, einen Schnappschuss zu löschen.</para>

    <para>Schnappschüsse werden mit &man.mount.8; erstellt.  Das
      folgende Kommando legt einen Schnappschuss von
      <filename>/var</filename> in <filename>/var/snapshot/snap</filename>
      ab:</para>

<screen>&prompt.root; <userinput>mount -u -o snapshot /var/snapshot/snap /var</userinput></screen>

    <para>Alternativ kann der Schnappschuss auch mit
      &man.mksnap.ffs.8; erstellt werden.</para>

    <screen>&prompt.root; <userinput>mksnap_ffs /var /var/snapshot/snap</userinput></screen>

    <para>Um Schnappschüsse auf einem Dateisystem, beispielsweise
      <filename>/var</filename> zu finden, kann man &man.find.1;
      verwenden:</para>

    <screen>&prompt.root; <userinput>find /var -flags snapshot</userinput></screen>

    <para>Nachdem ein Schnappschuss erstellt wurde, können Sie
      ihn für verschiedene Zwecke benutzen:</para>

    <itemizedlist>
      <listitem>
	<para>Sie können den Schnappschuss für die
	  Datensicherung benutzen und ihn auf eine CD oder ein Band
	  schreiben.</para>
      </listitem>

      <listitem>
	<para>Die Intigrität des Schnappschusses kann mit &man.fsck.8;
	  geprüft werden.  Wenn das Dateisystem zum Zeitpunkt der
	  Erstellung des Schnappschusses in Ordnung war, sollte
	  &man.fsck.8; immer erfolgreich durchlaufen.</para>
      </listitem>

      <listitem>
	<para>Sie können den Schnappschuss mit &man.dump.8;
	  sichern.  Sie erhalten dann eine konsistente Sicherung des
	  Dateisystems zu dem Zeitpunkt, der durch den Zeitstempel des
	  Schnappschusses gegeben ist.  Der Schalter
	  <option>-L</option> von &man.dump.8; erstellt für die
	  Sicherung einen Schnappschuss und entfernt diesen am Ende
	  der Sicherung wieder.</para>
      </listitem>

      <listitem>
	<para>Sie können einen Schnappschuss in den
	  Verzeichnisbaum einhängen und sich dann den Zustand des
	  Dateisystems zu dem Zeitpunkt ansehen, an dem der
	  Schnappschuss erstellt wurde.  Der folgende Befehl
	  hängt den Schnappschuss
	  <filename>/var/snapshot/snap</filename> ein:</para>

	<screen>&prompt.root; <userinput>mdconfig -a -t vnode -f /var/snapshot/snap -u 4</userinput>
&prompt.root; <userinput>mount -r /dev/md4 /mnt</userinput></screen>

      </listitem>
    </itemizedlist>

    <para>Der eingefrorene Stand des
      <filename>/var</filename>-Dateisystems ist nun unterhalb von
      <filename>/mnt</filename> verfügbar.  Mit Ausnahme der früheren
      Schnappschüsse, die als leere Dateien auftauchen, wird zu
      Beginn alles so aussehen, wie zum Zeitpunkt der Erstellung des
      Schnappschusses.  Der Schnappschuss kann wie folgt abgehängt
      werden:</para>

    <screen>&prompt.root; <userinput>umount /mnt</userinput>
&prompt.root; <userinput>mdconfig -d -u 4</userinput></screen>

    <para>Weitere Informationen über Soft Updates und
      Schnappschüsse von Dateisystemen sowie technische Artikel finden
      Sie auf der <link xlink:href="http://www.mckusick.com/">Webseite
        von Marshall Kirk McKusick</link>.</para>
  </sect1>

  <sect1 xml:id="quotas">
    <title>Dateisystem-Quotas</title>
    <indexterm>
      <primary>Accounting</primary>
      <secondary>Plattenplatz</secondary>
    </indexterm>
    <indexterm><primary>Disk Quotas</primary></indexterm>

    <para>Quotas sind eine optionale Funktion des Betriebssystems,
      die es erlauben, den Plattenplatz und/oder die Anzahl
      der Dateien eines Benutzers oder der Mitglieder einer Gruppe,
      auf Dateisystemebene zu beschränken.  Oft wird dies
      auf Timesharing-Systemen (Mehrbenutzersystemen) genutzt, da
      es dort erwünscht ist, die Ressourcen, die ein Benutzer oder
      eine Gruppe von Benutzern belegen können, zu limitieren.  Das
      verhindert, dass ein Benutzer oder eine Gruppe von Benutzern
      den ganzen verfügbaren Plattenplatz belegt.</para>

    <sect2>
      <title>Konfiguration des Systems, um Quotas zu
	aktivieren</title>

      <para>Bevor Quotas benutzt werden können, müssen
	sie im Kernel konfiguriert werden, wozu die folgende Zeile
	der Kernelkonfiguration hinzugefügt wird:</para>

      <programlisting>options QUOTA</programlisting>

      <para>Vor &os;&nbsp;9.2 ist diese Option in der Regel nicht im
	<filename>GENERIC</filename>-Kernel enthalten.
	<command>sysctl kern.features.ufs_quota</command> kann benutzt
	werden um zu testen, ob der aktuelle Kernel Quotas
	unterstützt.  Wenn die Option nicht vorhanden ist, muss ein
	angepasster Kernel erstellt werden.  Weitere
	Informationen zur Kernelkonfiguration finden Sie in
	<xref linkend="kernelconfig"/>.</para>

      <para>Durch Hinzufügen der folgenden Zeile in
	<filename>/etc/rc.conf</filename> wird das Quota-System
	aktiviert:</para>

      <programlisting>quota_enable="YES"</programlisting>

      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>überprüfen</secondary>
      </indexterm>

      <para>Um den Start des Quota-Systems zu beeinflussen, steht
	eine weitere Variable zur Verfügung.  Normalerweise
	wird beim Booten die Integrität der Quotas auf
	allen Dateisystemen mit &man.quotacheck.8;
	überprüft.  Dieses Programm stellt sicher, dass die
	Quota-Datenbank mit den Daten auf einem Dateisystem
	übereinstimmt.  Dies ist allerdings ein zeitraubender Prozess,
	der die Zeit, die das System zum Booten braucht, signifikant
	beeinflusst.  Eine Variable in
	<filename>/etc/rc.config</filename> erlaubt es, diesen Schritt
	zu überspringen:</para>

      <programlisting>check_quotas="NO"</programlisting>

      <para>Zuletzt muss noch <filename>/etc/fstab</filename>
	bearbeitet werden, um die Plattenquotas auf Dateisystemebene
	zu aktivieren.  Dort können für die Dateisysteme Quotas für
	Benutzer oder Gruppen aktiviert werden.</para>

      <para>Um Quotas pro Benutzer für ein Dateisystem zu aktivieren,
	geben Sie für dieses Dateisystem <option>userquota</option> im
	Feld Optionen von <filename>/etc/fstab</filename> an.
	Beispiel:</para>

      <programlisting>/dev/da1s2g   /home    ufs rw,userquota 1 2</programlisting>

      <para>Um Quotas für Gruppen einzurichten, verwenden
	Sie <option>groupquota</option>.  Um Quotas für Benutzer
	und Gruppen einzurichten, ändern Sie den Eintrag
	wie folgt ab:</para>

      <programlisting>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</programlisting>

      <para>Die Quota-Dateien werden standardmäßig im Rootverzeichnis
	des Dateisystems unter <filename>quota.user</filename> und
	<filename>quota.group</filename> abgelegt.  Weitere
	Informationen finden Sie in &man.fstab.5;.  Obwohl die
	Quota-Dateien an anderer Stelle gespeichert werden können,
	wird das nicht empfohlen, da es den Anschein hat, dass die
	verschiedenen Quota-Utilities dies nicht richtig
	unterstüzten.</para>

      <para>Sobald die Konfiguration abgeschlossen ist, booten Sie das
	System mit dem neuen Kernel.
	<filename>/etc/rc</filename> wird dann automatisch die
	richtigen Kommandos aufrufen, die die Quota-Dateien für
	alle Quotas, die Sie in <filename>/etc/fstab</filename>
	definiert haben, anlegen.  Es besteht keine Notwendigkeit,
	leere Quota-Dateien manuell zu erstellen .</para>

      <para>Normalerweise brauchen die Kommandos
	&man.quotacheck.8;, &man.quotaon.8; oder
	&man.quotaoff.8; nicht händisch aufgerufen werden,
	obwohl man die entsprechenden Seiten im
	Manual lesen sollte, um sich mit ihnen vertraut
	zu machen.</para>
    </sect2>

    <sect2>
      <title>Setzen von Quota-Limits</title>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>Limits</secondary>
      </indexterm>

      <para>Sobald das System konfiguriert wurde, Quotas zu
	aktivieren, stellen Sie sicher, dass diese auch tatsächlich
	aktiviert sind:</para>

      <screen>&prompt.root; <userinput>quota -v</userinput></screen>

      <para>Für jedes Dateisystem, auf dem Quotas aktiviert sind,
	sollte eine Zeile mit der Plattenauslastung und den
	aktuellen Quota-Limits zu sehen sein.</para>

      <para>Mit &man.edquota.8; können nun
	Quota-Limits zugewiesen werden.</para>

      <para>Mehrere Möglichkeiten stehen zur Verfügung, um Limits für
	den Plattenplatz, den ein Benutzer oder eine Gruppe verbrauchen
	kann, oder die Anzahl der Dateien, die angelegt werden dürfen,
	festzulegen.  Die Limits können auf dem Plattenplatz
	(Block-Quotas), der Anzahl der Dateien (Inode-Quotas) oder
	einer Kombination von beiden basieren.
	Jedes Limit wird weiterhin in zwei Kategorien geteilt:
	Hardlimits und Softlimits.</para>

      <indexterm><primary>Hardlimit</primary></indexterm>
      <para>Ein Hardlimit kann nicht überschritten werden.
	Hat der Benutzer einmal ein Hardlimit erreicht, so kann er
	auf dem betreffenden Dateisystem keinen weiteren Platz mehr
	beanspruchen.  Hat ein Benutzer beispielsweise ein Hardlimit
	von 500 Kilobytes auf einem Dateisystem und benutzt davon
	490 Kilobyte, so kann er nur noch 10 weitere Kilobytes
	beanspruchen.  Der Versuch, weitere 11 Kilobytes zu beanspruchen,
	wird fehlschlagen.</para>

      <indexterm><primary>Softlimit</primary></indexterm>
      <para>Softlimits können für eine
	befristete Zeit überschritten werden.  Diese Frist
	beträgt in der Grundeinstellung
	eine Woche.  Hat der Benutzer das Softlimit über die
	Frist hinaus überschritten, so wird das Softlimit in
	ein Hardlimit umgewandelt und der Benutzer kann
	keinen weiteren Platz mehr beanspruchen.  Wenn er einmal
	das Softlimit unterschreitet, wird die Frist wieder
	zurückgesetzt.</para>

      <para>Das folgende Beispiel zeigt die Benutzung von
	&man.edquota.8;.  Wenn &man.edquota.8; aufgerufen wird,
	wird der Editor gestartet, der durch <envar>EDITOR</envar>
	gegeben ist oder <application>vi</application> falls
	<envar>EDITOR</envar> nicht gesetzt ist.  In dem Editor
	können Sie die Limits eingeben.</para>

      <screen>&prompt.root; <userinput>edquota -u test</userinput></screen>

      <programlisting>Quotas for user test:
/usr: kbytes in use: 65, limits (soft = 50, hard = 75)
        inodes in use: 7, limits (soft = 50, hard = 60)
/usr/var: kbytes in use: 0, limits (soft = 50, hard = 75)
        inodes in use: 0, limits (soft = 50, hard = 60)</programlisting>

      <para>Für jedes Dateisystem, auf dem Quotas aktiv sind,
	sind zwei Zeilen zu sehen.  Eine repräsentiert die
	Block-Quotas und die andere die Inode-Quotas.  Um ein Limit zu
	modifizieren, ändern Sie einfach den angezeigten Wert.  Um
	beispielsweise das Blocklimit dieses Benutzers von einem
	Softlimit von 50 und einem Hardlimit von 75 auf ein Softlimit
	von 500 und ein Hardlimit von 600 zu erhöhen, ändern Sie
	die Zeile:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 50, hard = 75)</programlisting>

      <para>zu:</para>

      <programlisting>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</programlisting>

      <para>Die neuen Limits sind wirksam, sobald der Editor verlassen
	wird.</para>

      <para>Manchmal ist es erwünscht, die Limits für einen
	Bereich von UIDs zu setzen.  Dies kann mit der <option>-p</option>
	Option von &man.edquota.8; bewerkstelligt werden.
	Weisen Sie dazu die Limits einem Benutzer zu und rufen danach
	<command>edquota -p protouser startuid-enduid</command> auf.
	Besitzt beispielsweise der Benutzer <systemitem class="username">test</systemitem>
	die gewünschten Limits, können diese mit
	dem folgenden Kommando für die UIDs 10.000 bis 19.999
	dupliziert werden:</para>

      <screen>&prompt.root; <userinput>edquota -p test 10000-19999</userinput></screen>

      <para>Weitere Informationen finden Sie in
	&man.edquota.8;.</para>
    </sect2>

    <sect2>
      <title>Überprüfen von Quota-Limits und Plattennutzung</title>
      <indexterm>
	<primary>Disk Quotas</primary>
	<secondary>überprüfen</secondary>
      </indexterm>

      <para>&man.quota.1; oder &man.repquota.8; können benutzt werden,
	um Quota-Limits und Plattennutzung zu überprüfen.  Um die
	Limits oder die Plattennutzung individueller Benutzer und
	Gruppen zu überprüfen, kann &man.quota.1; benutzt werden.  Ein
	Benutzer kann nur die eigenen Quotas und die Quotas der
	Gruppe, der er angehört untersuchen.  Nur der Superuser darf
	sich alle Limits ansehen.  Mit &man.repquota.8; erhalten Sie
	eine Zusammenfassung von allen Limits und der
	Plattenausnutzung für alle Dateisysteme, auf denen Quotas
	aktiv sind.</para>

      <para>Das folgende Beispiel zeigt die Ausgabe von
	<command>quota -v</command> für einen Benutzer, der
	Quota-Limits auf zwei Dateisystemen besitzt:</para>

      <programlisting>Disk quotas for user test (uid 1002):
     Filesystem  usage   quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</programlisting>

     <indexterm><primary>grace period</primary></indexterm>
     <para>Im Dateisystem <filename>/usr</filename> liegt der Benutzer
	momentan 15 Kilobytes über dem Softlimit von
	50 Kilobytes und hat noch 5 Tage seiner Frist übrig.
	Der Stern <literal>*</literal> zeigt an, dass der
	Benutzer sein Limit überschritten hat.</para>

      <para>In der Ausgabe von &man.quota.1; werden Dateisysteme,
	auf denen ein Benutzer keinen Platz verbraucht, nicht angezeigt,
	auch wenn diesem Quotas zugewiesen wurden.  Mit <option>-v</option>
	werden diese Dateisysteme, wie <filename>/usr/var</filename>
	im obigen Beispiel, angezeigt.</para>
    </sect2>

    <sect2>
      <title>Quotas über NFS</title>
      <indexterm><primary>NFS</primary></indexterm>

      <para>Quotas werden von dem Quota-Subsystem auf dem NFS Server
	erzwungen.  Der &man.rpc.rquotad.8; Daemon stellt
	&man.quota.1; die Quota Informationen auf dem NFS Client
	zur Verfügung, so dass Benutzer auf diesen
	Systemen ihre Quotas abfragen können.</para>

      <para>Aktivieren Sie <command>rpc.rquotad</command> in
	<filename>/etc/inetd.conf</filename> wie folgt:</para>

      <programlisting>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</programlisting>

      <para>Anschließend starten Sie <command>inetd</command>
	neu:</para>

      <screen>&prompt.root; <userinput>service inetd restart</userinput></screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-encrypting">
    <info><title>Partitionen verschlüsseln</title>
      <authorgroup>
	<author><personname><firstname>Lucky</firstname><surname>Green</surname></personname><contrib>Beigetragen von </contrib><affiliation>
	    <address><email>shamrock@cypherpunks.to</email></address>
	  </affiliation></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>Partitionen</primary>
      <secondary>verschlüsseln</secondary>
    </indexterm>

    <para>&os; bietet ausgezeichnete Möglichkeiten, Daten vor
      unberechtigten Zugriffen zu schützen.  Wenn das
      Betriebssystem läuft, schützen Zugriffsrechte und
      vorgeschriebene Zugriffskontrollen (MAC) (siehe <xref linkend="mac"/>)
      die Daten.  Die Zugriffskontrollen des Betriebssystems
      schützen allerdings nicht vor einem Angreifer, der
      Zugriff auf den Rechner hat.  Der Angreifer
      kann eine Festplatte in ein anderes System einbauen
      und dort die Daten analysieren.</para>

    <para>Die für &os; verfügbaren kryptografischen Subsysteme,
      GEOM Based Disk Encryption (<command>gbde</command>)
      und <command>geli</command> sind in der Lage, Daten auf
      Dateisystemen auch vor hoch motivierten Angreifern zu
      schützen,  die über erhebliche Mittel verfügen.
      Dieser Schutz ist unabhängig von der Art und Weise, durch
      die ein Angreifer Zugang zu einer Festplatte oder zu einem
      Rechner erlangt hat.  Im Gegensatz zu schwerfälligen
      Systemen, die einzelne Dateien verschlüsseln,
      verschlüsseln <application>gbde</application> und
      <command>geli</command> transparent ganze Dateisysteme.  Auf der
      Festplatte werden dabei keine Daten im Klartext gespeichert.</para>

    <sect2>
      <title>Plattenverschlüsselung mit
        <application>gbde</application></title>

      <procedure>
	<step>
	  <para>Sie benötigen Superuser-Rechte, um
	    <application>gbde</application> einzurichten.</para>

	  <screen>&prompt.user; <userinput>su -</userinput>
Password:</screen>
	</step>

	<step>
	  <para>Wird eine angepasste Kernelkonfigurationsdatei
	    verwendet, stellen Sie sicher, dass folgende Zeile
	    enthalten ist:</para>

	  <para><literal>options GEOM_BDE</literal></para>

	  <para>Wenn der Kernel diese Unterstützung bereits enthält,
	    verwenden Sie <command>kldload</command> um
	    &man.gbde.4; zu laden:</para>

	  <screen>&prompt.root; <userinput>kldload geom_bde</userinput></screen>
	</step>
      </procedure>

    <sect3>
      <title>Einrichten einer verschlüsselten Festplatte</title>

      <para>Das folgende Beispiel beschreibt, wie eine Partition
	auf einer neuen Festplatte verschlüsselt wird.  Die
	Partition wird in <filename>/private</filename> eingehangen.
	Mit <application>gbde</application> könnten auch
	<filename>/home</filename> und <filename>/var/mail</filename>
	verschlüsselt werden.  Die dazu nötigen Schritte
	können allerdings in dieser Einführung
	nicht behandelt werden.</para>

      <procedure>
	<step>
	  <title>Installieren der Festplatte</title>

	  <para>Installieren Sie die Festplatte wie in
	    <xref linkend="disks-adding"/> beschrieben.  Im Beispiel
	    verwenden wir die Partition <filename>/dev/ad4s1c</filename>.
	    Die Gerätedateien
	    <filename>/dev/ad0s1*</filename>
	    sind Standard-Partitionen des &os;-Systems.</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</screen>
	</step>

	<step>
	  <title>Verzeichnis für gbde-Lock-Dateien anlegen</title>

	  <screen>&prompt.root; <userinput>mkdir /etc/gbde</userinput></screen>

	  <para>Die Lock-Dateien sind für den Zugriff von
	    <application>gbde</application> auf verschlüsselte
	    Partitionen notwendig.  Ohne die Lock-Dateien können
	    die Daten nur mit erheblichem manuellen Aufwand wieder
	    entschlüsselt werden (dies wird auch von der Software
	    nicht unterstützt).  Jede verschlüsselte
	    Partition benötigt eine gesonderte Lock-Datei.</para>
	</step>

	<step>
	  <title>Vorbereiten der gbde-Partition</title>

	  <para>Eine von <application>gbde</application> benutzte
	    Partition muss einmalig vorbereitet werden:</para>

	  <screen>&prompt.root; <userinput>gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>&man.gbde.8; öffnet eine Vorlage im Standard-Editor,
	    um verschiedene Optionen einstellen zu können.
	    Setzen Sie <varname>sector_size</varname> auf
	    <literal>2048</literal>, wenn Sie
	    UFS1 oder UFS2 benutzen.</para>

	  <programlisting># &dollar;FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $
#
# Sector size is the smallest unit of data which can be read or written.
# Making it too small decreases performance and decreases available space.
# Making it too large may prevent filesystems from working.  512 is the
# minimum and always safe.  For UFS, use the fragment size
#
sector_size     =       2048
[...]</programlisting>

	  <para>&man.gbde.8; fragt zweimal die Passphrase zum Schutz
	    der Daten ab.  Die Passphrase muss beide Mal gleich
	    eingegeben werden.  Die Sicherheit der Daten hängt allein
	    von der Qualität der gewählten Passphrase ab.  Die Auswahl
	    einer sicheren und leicht zu merkenden Passphrase wird auf
	    der Webseite <link xlink:href="http://world.std.com/~reinhold/diceware.html">Diceware
	      Passphrase</link> beschrieben.</para>

	  <para>Mit <command>gbde init</command> wurde im Beispiel
	    auch die Lock-Datei <filename>/etc/gbde/ad4s1c.lock</filename>
	    angelegt.  <application>gbde</application>-Lockdateien
	    müssen die Dateiendung <quote>.lock</quote> aufweisen,
	    damit sie von <filename>/etc/rc.d/gbde</filename>, dem
	    Startskript von <application>gbde</application>, erkannt
	    werden.</para>

	  <caution>
	    <para>Sichern Sie die Lock-Dateien von
	      <application>gbde</application> immer zusammen mit den
	      verschlüsselten Dateisystemen.  Ein entschlossener
	      Angreifer kann die Daten vielleicht auch ohne die
	      Lock-Datei entschlüsseln.  Ohne die Lock-Datei
	      können Sie allerdings nicht auf die
	      verschlüsselten Daten zugreifen.  Dies ist nur noch
	      mit erheblichem manuellen Aufwand möglich, der nicht
	      &man.gbde.8; wird.</para>
	  </caution>
	</step>

	<step>
	  <title>Einbinden der verschlüsselten Partition
	    in den Kernel</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>Dieses Kommando fragt die Passphrase ab, die bei der
	    Initialisierung der verschlüsselten Partition eingegeben
	    wurde.  Das neue verschlüsselte Gerät erscheint danach in
	    <filename>/dev</filename> als
	    <filename>/dev/device_name.bde</filename>:</para>

	  <screen>&prompt.root; <userinput>ls /dev/ad*</userinput>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</screen>
	</step>

	<step>
	  <title>Dateisystem auf dem verschlüsselten Gerät
	    anlegen</title>

	  <para>Nachdem die verschlüsselte Partition im Kernel
	    eingebunden ist, kann mit &man.newfs.8; ein Dateisystem
	    erstellt werden.  Dieses Beispiel erstellt ein
	    UFS2-Dateisystem mit aktivierten Soft Updates.</para>

	  <screen>&prompt.root; <userinput>newfs -U -O2 /dev/ad4s1c.bde</userinput></screen>

	  <note>
	    <para>&man.newfs.8; muss auf einer eingebundenen
	      <application>gbde</application>-Partition ausgeführt
	      werden, welche durch das Suffix
	      <filename><replaceable>*</replaceable>.bde</filename>
	      identifiziert wird.</para>
	  </note>
	</step>

	<step>
	  <title>Einhängen der verschlüsselten Partition</title>

	  <para>Legen Sie einen Mountpunkt für das
	    verschlüsselte Dateisystem an:</para>

	  <screen>&prompt.root; <userinput>mkdir /private</userinput></screen>

	  <para>Hängen Sie das verschlüsselte Dateisystem
	    ein:</para>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>
	</step>

	<step>
	  <title>Überprüfen des verschlüsselten
	    Dateisystems</title>

	  <para>Das verschlüsselte Dateisystem sollte jetzt
	    von &man.df.1; erkannt werden und benutzt werden
	    können.</para>

	  <screen>&prompt.user; <userinput>df -H</userinput>
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</screen>
	</step>
      </procedure>
    </sect3>

    <sect3>
      <title>Einhängen eines existierenden verschlüsselten
	Dateisystems</title>

      <para>Nach jedem Neustart müssen verschlüsselte
	Dateisysteme dem Kernel wieder bekannt gemacht werden,
	auf Fehler überprüft werden und eingehangen
	werden.  Die dazu nötigen Befehle müssen als
	<systemitem class="username">root</systemitem> durchgeführt werden.</para>

      <procedure>
	<step>
	  <title>gbde-Partition im Kernel bekannt geben</title>

	  <screen>&prompt.root; <userinput>gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</userinput></screen>

	  <para>Dieses Kommando fragt nach der Passphrase, die
	    während der Initialisierung der verschlüsselten
	    <application>gbde</application>-Partition festgelegt
	    wurde.</para>
	</step>

	<step>
	  <title>Prüfen des Dateisystems</title>

	  <para>Das verschlüsselte Dateisystem kann noch nicht
	    automatisch über <filename>/etc/fstab</filename>
	    eingehangen werden.  Daher muss es vor dem Einhängen
	    mit &man.fsck.8; geprüft werden:</para>

	  <screen>&prompt.root; <userinput>fsck -p -t ffs /dev/ad4s1c.bde</userinput></screen>
	</step>

	<step>
	  <title>Einhängen des verschlüsselten
	    Dateisystems</title>

	  <screen>&prompt.root; <userinput>mount /dev/ad4s1c.bde /private</userinput></screen>

	  <para>Das verschlüsselte Dateisystem steht danach
	    zur Verfügung.</para>
	</step>
      </procedure>

      <sect4>
	<title>Verschlüsselte Dateisysteme automatisch
	  einhängen</title>

	<para>Mit einem Skript können verschlüsselte
	  Dateisysteme automatisch bekannt gegeben, geprüft
	  und eingehangen werden.  Wir raten Ihnen allerdings
	  aus Sicherheitsgründen davon ab.  Starten Sie das
	  Skript manuell an der Konsole oder in einer
	  &man.ssh.1;-Sitzung.</para>

	<para>Alternativ existiert ein
	  <filename>rc.d</filename>-Skript, an das über
	  Einträge in &man.rc.conf.5; Argumente übergeben werden
	  können:</para>

	<programlisting>gbde_autoattach_all="YES"
gbde_devices="ad4s1c"
gbde_lockdir="/etc/gbde"</programlisting>

	<para>Durch diese Argumente muss beim Systemstart die
	  <application>gbde</application>-Passphrase eingegeben werden.
	  Erst nach Eingabe der korrekten Passphrase wird die
	  <application>gbde</application>-verschlüsselte
	  Partition automatisch in den Verzeichnisbaum
	  eingehängt.  Dieses Vorgehen ist
	  nützlich, wenn <application>gbde</application> auf
	  einem Laptop eingesetzt wird.</para>
      </sect4>
    </sect3>

    <sect3>
      <title>Kryptografische Methoden von gbde</title>

      <para>&man.gbde.8; benutzt den 128-Bit AES im CBC-Modus,
	um die Daten eines Sektors zu verschlüsseln.  Jeder
	Sektor einer Festplatte wird mit einem unterschiedlichen
	AES-Schlüssel verschlüsselt.  Weitere Informationen,
	unter anderem wie die Schlüssel für einen Sektor
	aus der gegebenen Passphrase ermittelt werden, finden
	Sie in &man.gbde.4;.</para>
    </sect3>

    <sect3>
      <title>Kompatibilität</title>

      <para>&man.sysinstall.8; kann nicht mit verschlüsselten
	<application>gbde</application>-Geräten umgehen.  Vor
	dem Start von &man.sysinstall.8; sind alle
	<filename>*.bde</filename>-Geräte
	zu deaktivieren, da &man.sysinstall.8; sonst bei der
	Gerätesuche abstürzt.  Das im Beispiel verwendete
	Gerät wird mit dem folgenden Befehl deaktiviert:</para>

      <screen>&prompt.root; <userinput>gbde detach /dev/ad4s1c</userinput></screen>

    </sect3>
    </sect2>

    <sect2>
      <info><title>Plattenverschlüsselung mit <command>geli</command></title>
	<authorgroup>
	  <author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname><contrib>Beigetragen von </contrib></author>
	</authorgroup>
      </info>

      

      <para>Mit <command>geli</command> ist eine alternative
	kryptografische GEOM-Klasse verfügbar.
	<command>geli</command> unterscheidet sich von
	<command>gbde</command> durch unterschiedliche Fähigkeiten und
	einen unterschiedlichen Ansatz für die Verschlüsselung.</para>

      <para>Die wichtigsten Merkmale von &man.geli.8; sind:</para>

      <itemizedlist>
	<listitem>
	  <para>Die Nutzung des &man.crypto.9;-Frameworks.  Wenn das
	    System über kryptografische Hardware verfügt, wird diese
	    von <command>geli</command> automatisch verwendet.</para>
	</listitem>

	<listitem>
	  <para>Die Unterstützung verschiedener kryptografischer
	    Algorithmen, wie beispielsweise AES, Blowfish, und
	    3DES.</para>
	</listitem>

	<listitem>
	  <para>Die Möglichkeit, die root-Partition zu
	    verschlüsseln.  Um auf die verschlüsselte
	    root-Partition zugreifen zu können, muss beim
	    Systemstart die Passphrase eingegeben werden.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> erlaubt den Einsatz von zwei
	    voneinander unabhängigen Schlüsseln, etwa einem
	    privaten <quote>Schlüssel</quote> und einem
	    <quote>Unternehmens-Schlüssel</quote>.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> ist durch einfache
	    Sektor-zu-Sektor-Verschlüsselung sehr schnell.</para>
	</listitem>

	<listitem>
	  <para>Die Möglichkeit, Master-Keys zu sichern und
	    wiederherzustellen.  Wenn ein Benutzer seinen Schlüssel
	    zerstört, kann er über seinen zuvor gesicherten
	    Schlüssel wieder auf seine Daten zugreifen.</para>
	</listitem>

	<listitem>
	  <para><command>geli</command> erlaubt es, Platten mit
	    einem zufälligen Einmal-Schlüssel einzusetzen,
	    was für Swap-Partitionen und
	    temporäre Dateisysteme interessant ist.</para>
	</listitem>
      </itemizedlist>

      <para>Weitere Merkmale von
	<command>geli</command> finden Sie in &man.geli.8;.</para>

      <para>Dieser Abschnitt beschreibt, wie <command>geli</command>
	im &os;-Kernel aktiviert wird und wie ein
	<command>geli</command>-Verschlüsselungs-Provider
	angelegt wird.</para>

      <para>Da der Kernel angepasst werden muss, werden
	<systemitem class="username">root</systemitem>-Privilegien
	benötigt.</para>

      <procedure>
	<step>
	  <title>Aufnahme der <command>geli</command>-Unterstützung
	    in Ihre Kernelkonfigurationsdatei</title>

	  <para>Stellen Sie bei einer angepassten
	    Kernelkonfigurationsdatei sicher, dass diese Zeile
	    enthalten ist:</para>

	  <programlisting>options GEOM_ELI
device crypto</programlisting>

	  <para>Alternativ kann auch das
	    <command>geli</command>-Kernelmodul beim Systemstart
	    geladen werden, indem folgende Zeile in
	    <filename>/boot/loader.conf</filename> eingefügt
	    wird:</para>

	  <programlisting>geom_eli_load="YES"</programlisting>

	  <para>Ab sofort wird &man.geli.8; vom Kernel
	    unterstützt.</para>
	</step>

	<step>
	  <title>Erzeugen des Master-Keys</title>

	  <para>Das folgende Beispiel beschreibt, wie eine
	    Schlüsseldatei erzeugt wird, die als Teil des
	    Master-Keys für den Verschlüsselungs-Provider
	    verwendet wird, der unter <filename>/private</filename>
	    in den Verzeichnisbaum eingehängt wird.  Die
	    Schlüsseldatei liefert zufällige Daten, die für die
	    Verschlüsselung des Master-Keys benutzt werden.
	    Zusätzlich wird  der Master-Key durch eine Passphrase
	    geschützt.  Die Sektorgröße des Providers beträgt
	    4&nbsp;KB.  Das Beispiel beschreibt, wie Sie einen
	    <command>geli</command>-Provider aktivieren, ein vom ihm
	    verwaltetes Dateisystem erzeugen, es mounten, mit ihm
	    arbeiten und wie Sie es schließlich wieder unmounten
	    und den Provider deaktivieren.</para>

	  <para>Um eine bessere Leistung zu erzielen, wird eine
	    größere Sektorgröße, beispielsweise 4&nbsp;KB,
	    empfohlen.</para>

	  <para>Der Master-Key wird durch eine Passphrase sowie, den
	    Daten der Schlüsseldatei aus
	    <filename>/dev/random</filename> geschützt.
	    Die Sektorgröße des Providers
	    <filename>/dev/da2.eli</filename> beträgt
	    4&nbsp;KB.</para>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/root/da2.key bs=64 count=1</userinput>
&prompt.root; <userinput>geli init -s 4096 -K /root/da2.key /dev/da2</userinput>
Enter new passphrase:
Reenter new passphrase:</screen>

	  <para>Es ist nicht zwingend nötig, sowohl eine Passphrase
	    als auch eine Schlüsseldatei zu verwenden.  Die
	    einzelnen Methoden können auch unabhängig
	    voneinander eingesetzt werden.</para>

	  <para>Wird für die Schlüsseldatei
	    <quote>-</quote> angegeben, wird dafür die
	    Standardeingabe verwendet.  Das folgende Beispiel zeigt,
	    dass auch mehr als eine Schlüsseldatei verwendet werden
	    kann:</para>

	  <screen>&prompt.root; <userinput>cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</userinput></screen>
	</step>

	<step>
	  <title>Aktivieren des Providers mit dem erzeugten
	    Schlüssel</title>

	  <screen>&prompt.root; <userinput>geli attach -k /root/da2.key /dev/da2</userinput>
Enter passphrase:</screen>

	  <para>Dadurch wird die (Normaltext-)Gerätedatei
	    <filename>/dev/da2.eli</filename>
	    angelegt.</para>

	  <screen>&prompt.root; <userinput>ls /dev/da2*</userinput>
/dev/da2  /dev/da2.eli</screen>
	</step>

	<step>
	  <title>Das neue Dateisystem erzeugen</title>

	  <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev/da2.eli bs=1m</userinput>
&prompt.root; <userinput>newfs /dev/da2.eli</userinput>
&prompt.root; <userinput>mount /dev/da2.eli /private</userinput></screen>

	<para>Das verschlüsselte Dateisystem wird nun von
	  &man.df.1; angezeigt und kann ab sofort eingesetzt werden.</para>

	  <screen>&prompt.root; <userinput>df -H</userinput>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</screen>

	</step>

	<step>
	  <title>Das Dateisystem unmounten und den Provider deaktivieren</title>

	  <para>Wenn Sie nicht mehr mit dem verschlüsselten
	    Dateisystem arbeiten und die unter <filename>/private</filename> eingehängte
	    Partition daher nicht mehr benötigen,  sollten
	    Sie diese unmounten und den
	    <command>geli</command>-Verschlüsselungs-Provider
	    wieder deaktivieren:</para>

	  <screen>&prompt.root; <userinput>umount /private</userinput>
&prompt.root; <userinput>geli detach da2.eli</userinput></screen>
	</step>
      </procedure>

      <para>Weitere Informationen zum Einsatz von
	<command>geli</command> finden Sie in &man.geli.8;.</para>

      <sect3>
	<title>Der Einsatz des <filename>geli</filename>-
	  <filename>rc.d</filename>-Skripts</title>

	<para><command>geli</command> verfügt über ein
	  <filename>rc.d</filename>-Skript,
	  das den Einsatz von <command>geli</command>
	  deutlich vereinfacht.  Es folgt nun ein Beispiel, in dem
	  <command>geli</command> über die Datei
	  &man.rc.conf.5; konfiguriert wird:</para>

	<programlisting>geli_devices="da2"
geli_da2_flags="-p -k /root/da2.key"</programlisting>

	<para>Durch diese Einträge wird
	  <filename>/dev/da2</filename> als
	  <command>geli</command>-Provider festgelegt.  Der Master-Key
	  befindet sich in <filename>/root/da2.key</filename>.  Beim
	  Aktivieren des <command>geli</command>-Providers wird keine
	  Passphrase abgefragt.  Beachten Sie, dass dies nur dann
	  möglich ist, wenn <command>geli</command> mit dem
	  Parameter <option>-P</option> initialisiert wurde.  Wird das
	  System heruntergefahren, wird der
	  <literal>geli</literal>-Provider zuvor deaktiviert.</para>

	<para>Weitere Informationen zur Konfiguration der
	  <filename>rc.d</filename>-Skripten
	  finden Sie im Abschnitt <link linkend="configtuning-rcd">rc.d</link> des Handbuchs.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="swap-encrypting">
    <info><title>Den Auslagerungsspeicher verschlüsseln</title>
      <authorgroup>
	<author><personname><firstname>Christian</firstname><surname>Brüffer</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>
    </info>

    

    <indexterm>
      <primary>Auslagerungsspeicher</primary>
      <secondary>verschlüsseln</secondary>
    </indexterm>

    <para>Wie die Verschlüsselung von Partitionen, wird auch der
      Auslagerungsspeicher verschlüsselt, um sensible Informationen
      zu schützen.  Stellen Sie sich eine Anwendung vor, die mit
      Passwörtern umgeht.  Solange sich diese Passwörter im
      Arbeitsspeicher befinden, werden sie nicht auf die Festplatte
      geschrieben und nach einem Neustart gelöscht.  Falls &os; jedoch
      damit beginnt Speicher auszulagern, um Platz für andere
      Anwendungen zu schaffen, können die Passwörter unverschlüsselt
      auf die Festplatte geschrieben werden.  Die Verschlüsselung des
      Auslagerungsspeichers kann in solchen Situationen Abhilfe
      schaffen.</para>

    <para>Das
      &man.gbde.8;- oder das &man.geli.8;-Verschlüsselungs-Subsystem
      kann für die Verschlüsselung des Auslagerungsspeichers
      eingesetzt werden.  Beide Subsysteme nutzen das
      <filename>encswap</filename>
      <link linkend="configtuning-rcd">rc.d</link>-Skript.</para>

    <note>
      <para>Für den Rest dieses Abschnitts wird
	<filename>ad0s1b</filename> die Swap-Partition
	darstellen.</para>
    </note>

    <para>Swap-Partitionen werden standardmäßig nicht verschlüsselt.
      Sie sollten daher alle sensiblen Daten im Auslagerungsspeicher
      löschen, bevor Sie fortfahren.  Führen Sie folgenden Befehl aus,
      um die Swap-Partition mit Zufallsdaten zu überschreiben:</para>

    <screen>&prompt.root; <userinput>dd if=/dev/random of=/dev
/<replaceable>ad0s1b</replaceable> bs=1m</userinput></screen>

    <sect2>
      <title>Den Auslagerungsspeicher mit &man.gbde.8;
	verschlüsseln</title>

      <para>In der Datei <filename>/etc/fstab</filename> sollte
	das Suffix <literal>.bde</literal> an den Gerätenamen
	der Swap-Partition anhängt werden:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.bde         none            swap    sw              0       0</programlisting>
    </sect2>

    <sect2>
      <title>Den Auslagerungsspeicher mit &man.geli.8;
	verschlüsseln</title>

      <para>Die Vorgehensweise für die Verschlüsselung des
	Auslagerungsspeichers mit &man.geli.8; ist der von
	&man.gbde.8; sehr ähnlich.  Bei der Verwendung
	von &man.geli.8; in <filename>/etc/fstab</filename> wird das
	Suffix <literal>.eli</literal> an den Gerätenamen der
	Swap-Partition angehangen:</para>

      <programlisting># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/ad0s1b.eli         none            swap    sw              0       0</programlisting>

      <para>In der Voreinstellung verschlüsselt &man.geli.8; den
	Auslagerungsspeicher mit dem <acronym>AES</acronym>-Algorithmus
	und einer Schlüssellänge von 128 Bit.  Diese Voreinstellungen
	können mittels <literal>geli_swap_flags</literal> in
	<filename>/etc/rc.conf</filename> angepasst werden.  Die
	folgende Zeile weist das rc.d-Skript
	<filename>encswap</filename> an, &man.geli.8;-Swap-Partitionen
	mit dem Blowfish-Algorithmus und einer Schlüssellänge von
	128&nbsp;Bit zu verschlüsseln.  Zusätzlich wird die
	Sektorgröße auf 4&nbsp;Kilobyte gesetzt und
	<quote>detach on last close</quote> aktiviert:</para>

      <programlisting>geli_swap_flags="-e blowfish -l 128 -s 4096 -d"</programlisting>

      <para>Eine Auflistung möglicher Optionen für
	<command>onetime</command> finden Sie in der Manualpage von
	&man.geli.8;.</para>
    </sect2>

    <sect2>
      <title>Überprüfung des verschlüsselten
	Auslagerungsspeichers</title>

      <para>Nachdem das System neu gestartet wurde, kann die korrekte
	Funktion des verschlüsselten Auslagerungsspeichers mit
	<command>swapinfo</command> geprüft werden.</para>

      <para>Wenn Sie &man.gbde.8; einsetzen, erhalten Sie eine
	Meldung ähnlich der folgenden:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.bde    542720        0   542720     0%</screen>

      <para>Wenn Sie &man.geli.8; einsetzen, erhalten Sie hingegen
	eine Ausgabe ähnlich der folgenden:</para>

      <screen>&prompt.user; <userinput>swapinfo</userinput>
Device          1K-blocks     Used    Avail Capacity
/dev/ad0s1b.eli    542720        0   542720     0%</screen>
    </sect2>
  </sect1>

  <sect1 xml:id="disks-hast">
    <info><title>Highly Available Storage (HAST)</title>
      <authorgroup>
	<author><personname><firstname>Daniel</firstname><surname>Gerzo</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Freddie</firstname><surname>Cash</surname></personname><contrib>Mit Beiträgen von </contrib></author>
	<author><personname><firstname>Pawel Jakub</firstname><surname>Dawidek</surname></personname></author>
	<author><personname><firstname>Michael W.</firstname><surname>Lucas</surname></personname></author>
	<author><personname><firstname>Viktor</firstname><surname>Petersson</surname></personname></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
      
    </info>

    
    <indexterm>
      <primary>HAST</primary>
      <secondary>high availability</secondary>
    </indexterm>

    <sect2>
      <title>Überblick</title>

      <para>Hochverfügbarkeit ist eine der Hauptanforderungen von
        ernsthaften Geschäftsanwendungen und hochverfügbarer Speicher
        ist eine Schlüsselkomponente in solchen Umgebungen.  Highly
        Available STorage, oder <acronym>HAST<remark role="acronym">Highly Available STorage</remark></acronym>, wurde von
        &a.pjd.email; als ein Framework entwickelt, welches die transparente
        Speicherung der gleichen Daten über mehrere physikalisch getrennte
        Maschinen ermöglicht, die über ein TCP/IP-Netzwerk verbunden
        sind.  <acronym>HAST</acronym> kann als ein netzbasiertes RAID1
        (Spiegel) verstanden werden und ist dem DRBD&reg;-Speichersystem der
        GNU/&linux;-Plattform ähnlich.  In Kombination mit anderen
        Hochverfügbarkeitseigenschaften von &os;
        wie <acronym>CARP</acronym>, ermöglicht es
        <acronym>HAST</acronym>, hochverfügbare Speichercluster zu bauen,
        die in der Lage sind, Hardwareausfällen zu widerstehen.</para>

      <para>Nachdem Sie diesen Abschnitt gelesen haben, werden Sie folgendes
        wissen:</para>

      <itemizedlist>
	<listitem>
	  <para>Was <acronym>HAST</acronym> ist, wie es funktioniert und
	    welche Eigenschaften es besitzt.</para>
	</listitem>
	<listitem>
	  <para>Wie man <acronym>HAST</acronym> auf &os; aufsetzt und
	    verwendet.</para>
	</listitem>
	<listitem>
	  <para>Wie man <acronym>CARP</acronym> und &man.devd.8; kombiniert, um
	    ein robustes Speichersystem zu bauen.</para>
 	</listitem>
      </itemizedlist>

      <para>Bevor Sie diesen Abschnitt lesen, sollten Sie:</para>

      <itemizedlist>
	<listitem>
	  <para>die Grundlagen von &unix; und &os; verstanden haben
	    (<xref linkend="basics"/>).</para>
	</listitem>
	<listitem>
	  <para>wissen, wie man Netzwerkschnittstellen und andere Kernsysteme
	    von &os; konfiguriert (<xref linkend="config-tuning"/>).</para>
	</listitem>
	<listitem>
	  <para>ein gutes Verständnis der &os;-Netzwerkfunktionalität
	    besitzen (<xref linkend="network-communication"/>).</para>
	</listitem>
      </itemizedlist>

      <para>Das <acronym>HAST</acronym>-Projekt wurde von der &os; Foundation
        mit Unterstützung der <link xlink:href="http://www.omc.net/">OMCnet Internet Service GmbH</link> und
        <link xlink:href="http://www.transip.nl/">TransIP BV</link>
        gesponsert.</para>
    </sect2>

    <sect2>
      <title>HAST-Merkmale</title>

      <para>Die Hauptmerkmale des <acronym>HAST</acronym>-Systems sind:</para>

      <itemizedlist>
        <listitem>
	  <para>Es kann zur Maskierung von I/O-Fehlern auf lokalen Festplatten
	    eingesetzt werden.</para>
	</listitem>
	<listitem>
	  <para>Dateisystem-unabhängig, was es erlaubt, jedes von &os;
	    unterstützte Dateisystem zu verwenden.</para>
	</listitem>
	<listitem>
	  <para>Effiziente und schnelle Resynchronisation: es werden nur die
	    Blöcke synchronisiert, die während der Ausfallzeit eines
	    Knotens geändert wurden.</para>
	</listitem>
	<!--
        <listitem>
	  <para>Besitzt mehrere Synchronisationsmodi, um eine schnelle
	    Übergabe an einen anderen Knoten (sog. failover) zu
	    ermöglichen.</para>
	</listitem>
	-->
	<listitem>
	  <para>Es kann in einer bereits bestehenden Umgebung eingesetzt
	    werden, um zusätzliche Redundanz zu erreichen.</para>
	</listitem>
	<listitem>
	  <para>Zusammen mit <acronym>CARP</acronym>,
	    <application>Heartbeat</application>, oder anderen Werkzeugen, ist
	    es möglich, ein robustes und dauerhaftes Speichersystem zu
	    bauen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2>
      <title>HAST im Einsatz</title>

      <para><acronym>HAST</acronym> stellt auf Block-Ebene eine synchrone
        Replikation eines beliebigen Speichermediums auf mehreren Maschinen zur
	Verfügung.  Daher werden mindestens zwei physikalische
	Maschinen benötigt: der <literal>primary</literal>, auch
	bekannt als <literal>master</literal> Knoten, sowie der
	<literal>secondary</literal>, oder <literal>slave</literal>
	Knoten.  Diese beiden Maschinen zusammen werden als Cluster
	bezeichnet.</para>

      <note>
	<para>HAST ist momentan auf insgesamt zwei Knoten im Cluster
	  beschränkt.</para>
      </note>

      <para>Da <acronym>HAST</acronym> in einer
        primär-sekundär-Konfiguration funktioniert, ist immer nur ein
        Knoten des Clusters zu jeder Zeit aktiv.  Der
        <literal>primäre</literal> Knoten, auch
        <literal>active</literal> genannt, ist derjenige, der alle I/O-Anfragen
	verarbeitet, die an die <acronym>HAST</acronym>-Schnittstelle gesendet
	werden.  Der <literal>secondary</literal>-Knoten wird automatisch vom
	<literal>primary</literal>-Knoten aus synchronisiert.</para>

      <para>Die physischen Komponenten des <acronym>HAST</acronym>-Systems
        sind:</para>

      <itemizedlist>
	<listitem>
	  <para>lokale Platte am Primärknoten</para>
	</listitem>
	<listitem>
	  <para>entfernte Platte am Sekundärknoten</para>
	</listitem>
      </itemizedlist>

      <para><acronym>HAST</acronym> arbeitet synchron auf Blockebene,
	was es für Dateisysteme und Anwendungen transparent macht.
        <acronym>HAST</acronym> stellt gewöhnliche GEOM-Provider in
	<filename>/dev/hast/</filename> für die Verwendung durch
	andere Werkzeuge oder Anwendungen zur Verfügung.  Somit gibt
	es keinen Unterschied zwischen dem Einsatz von
	<acronym>HAST</acronym> bereitgestellten Geräten und
        herkömmlichen Platten, Partitionen, etc.</para>

      <para>Jede Schreib-, Lösch- oder Entleerungsoperation wird an die
        lokale und über TCP/IP zu der entfernt liegenden
        Platte gesendet.  Jede Leseoperation wird von der lokalen Platte
        durchgeführt, es sei denn, die lokale Platte ist nicht aktuell
        oder es tritt ein I/O-Fehler auf.  In solchen Fällen wird die
        Leseoperation an den Sekundärknoten geschickt.</para>

      <sect3>
	<title>Synchronisation und Replikationsmodi</title>

	<para><acronym>HAST</acronym> versucht, eine schnelle Fehlerbereinigung
	  zu gewährleisten.  Aus diesem Grund ist es sehr wichtig, die
	  Synchronisationszeit nach dem Ausfall eines Knotens zu reduzieren.
	  Um eine schnelle Synchronisation zu ermöglichen, verwaltet
	  <acronym>HAST</acronym> eine Bitmap von unsauberen Bereichen
	  auf der Platte und synchronisiert nur diese während einer
	  regulären Synchronisation (mit Ausnahme der initialen
	  Synchronisation).</para>

	<para>Es gibt viele Wege, diese Synchronisation zu behandeln.
	  <acronym>HAST</acronym> implementiert mehrere Replikationsarten, um
	  unterschiedliche Methoden der Synchronisation zu realisieren:</para>

	<itemizedlist>
	  <listitem>
	    <para><emphasis>memsync</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn die lokale Schreiboperation beendet ist
	      und der entfernt liegende Knoten die Ankunft der Daten
	      bestätigt hat, jedoch bevor die Daten wirklich gespeichert
	      wurden.  Die Daten werden auf dem entfernt liegenden Knoten
	      direkt nach dem Senden der Bestätigung gespeichert.  Dieser
	      Modus ist dafür gedacht, Latenzen zu verringern und
	      zusätzlich eine gute Verlässlichkeit zu bieten.</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>fullsync</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn die lokale Schreiboperation beendet ist
	      und die entfernte Schreiboperation ebenfalls abgeschlossen wurde.
	      Dies ist der sicherste und zugleich der langsamste
	      Replikationsmodus.  Er stellt den momentanen Standardmodus
	      dar.</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>async</emphasis>: meldet Schreiboperationen als
	      vollständig, wenn lokale Schreibvorgänge abgeschlossen
	      wurden.  Dies ist der schnellste und gefährlichste
	      Replikationsmodus.  Er sollte verwendet werden, wenn die Latenz
	      zu einem entfernten Knoten bei einer Replikation zu hoch ist
	      für andere Modi.</para>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>

    <sect2>
      <title>HAST-Konfiguration</title>

      <para><acronym>HAST</acronym> benötigt
	<literal>GEOM_GATE</literal>-Unterstützung, welche
	standardmäßig nicht im <literal>GENERIC</literal>-Kernel
	enthalten ist.  Jedoch ist in der Standardinstallation von
	&os; <filename>geom_gate.ko</filename> als ladbares Modul
	vorhanden.  Alternativ lässt sich die
	<literal>GEOM_GATE</literal>-Unterstützung in den Kernel
	statisch einbauen, indem folgende Zeile zur
	Kernelkonfigurationsdatei hinzugefügt wird:</para>

      <programlisting>options	GEOM_GATE</programlisting>

      <para>Das <acronym>HAST</acronym>-Framework besteht aus Sicht des
        Betriebssystems aus mehreren Bestandteilen:</para>

      <itemizedlist>
        <listitem>
	  <para>Dem &man.hastd.8;-Daemon, welcher für
	    Datensynchronisation verantwortlich ist,</para>
	</listitem>
	<listitem>
	  <para>Dem &man.hastctl.8; Management-Werkzeug,</para>
	</listitem>
	<listitem>
	  <para>Der Konfigurationsdatei &man.hast.conf.5;.</para>
	</listitem>
      </itemizedlist>

      <para>Das folgende Beispiel beschreibt, wie man zwei Knoten als
        <literal>master</literal>-<literal>slave</literal> /
        <literal>primary</literal>-<literal>secondary</literal> mittels
        <acronym>HAST</acronym> konfiguriert, um Daten zwischen diesen beiden
        auszutauschen.  Die Knoten werden als
        <literal>hasta</literal> mit der IP-Adresse
        <replaceable>172.16.0.1</replaceable> und
        <literal>hastb</literal> mit der IP-Adresse
        <replaceable>172.16.0.2</replaceable> bezeichnet.  Beide Knoten
        besitzen eine dedizierte Festplatte
        <filename>/dev/ad6</filename> mit der
        gleichen Grösse für den <acronym>HAST</acronym>-Betrieb.
	Der <acronym>HAST</acronym>-Pool, manchmal auch Ressource
	genannt, oder der GEOM-Provider in
	<filename>/dev/hast/</filename> wird als
	<filename>test</filename> bezeichnet.</para>

      <para>Die Konfiguration von <acronym>HAST</acronym> wird in
        <filename>/etc/hast.conf</filename> vorgenommen.  Diese Datei sollte
        auf beiden Knoten gleich sein.  Die denkbar einfachste Konfiguration
        ist folgende:</para>

      <programlisting>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</programlisting>

      <para>Fortgeschrittene Konfigurationsmöglichkeiten finden Sie in
	&man.hast.conf.5;.</para>

      <tip>
	<para>Es ist ebenfalls möglich, den Hostnamen in den
	  <literal>remote</literal>-Anweisungen zu verwenden.  Stellen Sie in
	  solchen Fällen sicher, dass diese Rechner auch aufgelöst
	  werden können und in <filename>/etc/hosts</filename>, oder
	  im lokalen <acronym>DNS</acronym> definiert sind.</para>
      </tip>

      <para>Da nun die Konfiguration auf beiden Rechnern vorhanden
	ist, kann ein <acronym>HAST</acronym>-Pool erstellt werden.
	Lassen Sie diese Kommandos auf beiden Knoten ablaufen, um die
	initialen Metadaten auf die lokale Platte zu schreiben und
	starten Sie anschliessend &man.hastd.8;:</para>

      <screen>&prompt.root; <userinput>hastctl create test</userinput>
&prompt.root; <userinput>service hastd onestart</userinput></screen>

      <note>
	<para>Es ist <emphasis>nicht</emphasis> möglich, GEOM-Provider
	  mit einem bereits bestehenden Dateisystem zu verwenden, um
	  beispielsweise einen bestehenden Speicher in einen von
	  <acronym>HAST</acronym> verwalteten Pool zu konvertieren.
	  Dieses Verfahren muss einige Metadaten auf den Provider
	  schreiben und dafür würde nicht genug freier Platz zur
	  Verfügung stehen.</para>
      </note>

      <para>Die Rolle eines HAST Knotens, <literal>primary</literal>
	oder <literal>secondary</literal>, wird vom einem
	Administrator, oder einer Software wie
	<application>Heartbeat</application>, mittels
	&man.hastctl.8; festgelegt.  Auf dem primären
	Knoten <literal><replaceable>hasta</replaceable></literal>
	geben Sie diesen Befehl ein:</para>

      <screen>&prompt.root; <userinput>hastctl role primary test</userinput></screen>

      <para>Geben Sie folgendes Kommando auf dem sekundären
	Knoten <literal><replaceable>hastb</replaceable></literal>
	ein:</para>

      <screen>&prompt.root; <userinput>hastctl role secondary test</userinput></screen>

      <caution>
	<para>Es kann passieren, dass beide Knoten nicht in der Lage
	  sind, miteinander zu kommunizieren und dadurch beide als
	  primäre Knoten konfiguriert sind; die Konsequenz daraus wird
	  als <literal>split-brain</literal> bezeichnet.  Um diese
	  Situation zu bereinigen, folgen Sie den Schritten, die
	  in <xref linkend="disks-hast-sb"/> beschrieben sind.</para>
      </caution>

      <para>Überprüfen Sie das Ergebnis mit &man.hastctl.8; auf beiden
        Knoten:</para>

      <screen>&prompt.root; <userinput>hastctl status test</userinput></screen>

      <para>Der wichtigste Teil ist die
	<literal>status</literal>-Textzeile, die auf jedem Knoten
	<literal>complete</literal> lauten sollte.  Falls der Status
	als <literal>degraded</literal> zurückgemeldet wird, ist etwas
	schief gegangen.  Zu diesem Zeitpunkt hat die Synchronisation
	zwischen den beiden Knoten bereits begonnen.  Die
	Synchronisation ist beendet, wenn
	<command>hastctl status</command> meldet, dass die
	<literal>dirty</literal>-Bereiche 0 Bytes betragen.</para>

      <para>Der nächste Schritt ist, ein Dateisystem auf dem
	<filename>/dev/hast/test</filename> GEOM-Provider anzulegen
	und dieses ins System einzuhängen.  Dies muss auf dem
	<literal>primary</literal>-Knoten durchgeführt werden, da
	<filename>/dev/hast/test</filename> nur auf dem
	<literal>primary</literal>-Knoten erscheint.  Die Erstellung
	des Dateisystems kann ein paar Minuten dauern, abhängig von
	der Grösse der Festplatte:</para>

      <screen>&prompt.root; <userinput>newfs -U /dev/hast/test</userinput>
&prompt.root; <userinput>mkdir /hast/test</userinput>
&prompt.root; <userinput>mount /dev/hast/test /hast/test</userinput></screen>

      <para>Sobald das <acronym>HAST</acronym>-Framework richtig
	konfiguriert wurde, besteht der letzte Schritt nun darin,
	sicherzustellen, dass <acronym>HAST</acronym> während des
	Systemstarts automatisch gestartet wird.  Fügen Sie diese
	Zeile in <filename>/etc/rc.conf</filename> hinzu:</para>

      <programlisting>hastd_enable="YES"</programlisting>

      <sect3>
	<title>Failover-Konfiguration</title>

	<para>Das Ziel dieses Beispiels ist, ein robustes
	  Speichersystem zu bauen, welches Fehlern auf einem
	  beliebigen Knoten widerstehen kann.  Das Szenario besteht
	  darin, dass der <literal>primary</literal>-Knoten des
	  Clusters ausfällt.  Sollte das passieren, ist der
	  <literal>secondary</literal>-Knoten da, um nahtlos
	  einzuspringen, das Dateisystem zu prüfen, einzuhängen und
	  mit der Arbeit fortzufahren, ohne dass auch nur ein
	  einzelnes Bit an Daten verloren geht.</para>

	<para>Um diese Aufgabe zu bewerkstelligen, wird eine
	  weitere Eigenschaft von &os; benutzt,
	  <acronym>CARP</acronym>,  welches ein automatisches Failover
	  auf der IP-Schicht ermöglicht.
	  <acronym>CARP</acronym> (Common Address Redundancy Protocol)
	  erlaubt es mehreren Rechnern im gleichen Netzsegment, die
	  gleiche IP-Adresse zu verwenden.  Setzen Sie
	  <acronym>CARP</acronym> auf beiden Knoten des Clusters
	  anhand der Dokumentation in <xref linkend="carp"/> auf.
	  Nach der Konfiguration wird jeder Knoten seine eigene
	  <filename>carp0</filename>-Schnittstelle, mit der geteilten
	  IP-Adresse <replaceable>172.16.0.254</replaceable> besitzen.
	  Der primäre <acronym>HAST</acronym>-Knoten des Clusters muss
	  der <acronym>CARP</acronym>-Masterknoten sein.</para>

	<para>Der <acronym>HAST</acronym>-Pool, welcher im vorherigen Abschnitt
	  erstellt wurde, ist nun bereit für den Export über das
	  Netzwerk auf den anderen Rechner.  Dies kann durch den Export
	  über <acronym>NFS</acronym> oder <application>Samba</application>
	  erreicht werden, indem die geteilte IP-Addresse
	  <replaceable>172.16.0.254</replaceable> verwendet wird.  Das einzige
	  ungelöste Problem ist der automatische Failover, sollte der
	  primäre Knoten einmal ausfallen.</para>

	<para>Falls die <acronym>CARP</acronym>-Schnittstelle
	  aktiviert oder deaktiviert wird, generiert das
	  &os;-Betriebssystem ein &man.devd.8;-Ereignis, was es
	  ermöglicht, Zustandsänderungen auf den
	  <acronym>CARP</acronym>-Schnittstellen zu überwachen.  Eine
	  Zustandsänderung auf der
	  <acronym>CARP</acronym>-Schnittstelle ist ein Indiz dafür,
	  dass einer der Knoten gerade ausgefallen oder wieder
	  verfügbar ist.  Diese Zustandsänderungen machen es möglich,
	  ein Skript zu starten, welches automatisch den HAST-Failover
	  durchführt.</para>

	<para>Um  Zustandsänderungen auf der
	  <acronym>CARP</acronym>-Schnittstelle abzufangen, müssen
	  diese Zeilen in <filename>/etc/devd.conf</filename> auf
	  jedem Knoten hinzugefügt werden:</para>

	<programlisting>notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_UP";
	action "/usr/local/sbin/carp-hast-switch master";
};

notify 30 {
	match "system" "IFNET";
	match "subsystem" "carp0";
	match "type" "LINK_DOWN";
	action "/usr/local/sbin/carp-hast-switch slave";
};</programlisting>

	<para>Starten Sie &man.devd.8; auf beiden Knoten neu, um
	  die neue Konfiguration wirksam werden zu lassen:</para>

	<screen>&prompt.root; <userinput>service devd restart</userinput></screen>

	<para>Wenn die <filename>carp0</filename>-Schnittstelle
	  aktiviert oder deaktiviert wird, erzeugt das System eine
	  Meldung, was es dem &man.devd.8;-Subsystem ermöglicht, ein
	  beliebiges Skript zu starten, in diesem Fall also
	  <filename>/usr/local/sbin/carp-hast-switch</filename>.
	  Dieses Skript führt den automatischen Failover durch.
	  Weitere Informationen zu der obigen
	  &man.devd.8;-Konfiguration, finden Sie in
	  &man.devd.conf.5;.</para>

	<para>Ein Beispiel für ein solches Skript könnte so
	  aussehen:</para>

<programlisting>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources="test"

# delay in mounting HAST resource after becoming master
# make your best guess
delay=3

# logging
log="local0.debug"
name="carp-hast"

# end of user configurable stuff

case "$1" in
	master)
		logger -p $log -t $name "Switching to primary provider for ${resources}."
		sleep ${delay}

		# Wait for any "hastd secondary" processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf "hastd: ${disk} \(secondary\)" &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to change role to primary for resource ${disk}."
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c "/dev/hast/${disk}" ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c "/dev/hast/${disk}" ]; then
				logger -p $log -t $name "GEOM provider /dev/hast/${disk} did not appear."
				exit 1
			fi
		done

		logger -p $log -t $name "Role for HAST resources ${resources} switched to primary."


		logger -p $log -t $name "Mounting disks."
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	slave)
		logger -p $log -t $name "Switching to secondary provider for ${resources}."

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q "^/dev/hast/${disk} on "
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name "Unable to switch role to secondary for resource ${disk}."
				exit 1
			fi
			logger -p $log -t $name "Role switched to secondary for resource ${disk}."
		done
	;;
esac</programlisting>

	<para>Im Kern führt das Skript die folgenden Aktionen durch,
	  sobald ein Knoten zum <literal>master</literal> /
	  <literal>primary</literal> wird:</para>

	<itemizedlist>
	  <listitem>
	    <para>Es ernennt den <acronym>HAST</acronym>-Pool als den
	      primären für einen gegebenen Knoten.</para>
	  </listitem>
	  <listitem>
	    <para>Es prüft das Dateisystem, dass auf dem
	      <acronym>HAST</acronym>-Pool erstellt wurde.</para>
	  </listitem>
	  <listitem>
	    <para>Es hängt die Pools an die richtige Stelle im System
	      ein.</para>
	  </listitem>
	</itemizedlist>

	<para>Wenn ein Knoten zum <literal>backup</literal> /
	  <literal>secondary</literal> ernannt wird:</para>

	<itemizedlist>
	  <listitem>
	    <para>Hängt es den <acronym>HAST</acronym>-Pool aus dem
	      Dateisystem aus.</para>
	  </listitem>
	  <listitem>
	    <para>Degradiert es den <acronym>HAST</acronym>-Pool zum
	      sekundären.</para>
	  </listitem>
	</itemizedlist>

	<caution>
	  <para>Bitte beachten Sie, dass dieses Skript nur ein Beispiel
	    für eine mögliche Lösung darstellt.  Es behandelt
	    nicht alle möglichen Szenarien, die auftreten können und
	    sollte erweitert bzw. abgeändert werden, so dass z.B.
	    benötigte Dienste gestartet oder gestoppt werden.</para>
	</caution>

	<tip>
	  <para>Für dieses Beispiel wurde ein Standard-UFS Dateisystem
	    verwendet.  Um die Zeit für die Wiederherstellung zu
	    verringern, kann ein UFS mit Journal oder ein ZFS-Dateisystem
	    benutzt werden.</para>
	</tip>

	<para>Weitere detaillierte Informationen mit zusätzlichen
	  Beispielen können auf der <link xlink:href="http://wiki.FreeBSD.org/HAST">HAST Wiki</link>-Seite
	  abgerufen werden.</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Fehlerbehebung</title>

      <sect3>
	<title>Allgemeine Tipps zur Fehlerbehebung</title>

	<para><acronym>HAST</acronym> sollte generell ohne Probleme
	  funktionieren. Jedoch kann es, wie bei jeder anderen Software auch,
	  zu gewissen Zeiten sein, dass sie sich nicht so verhält wie
	  angegeben.  Die Quelle dieser Probleme kann unterschiedlich sein,
	  jedoch sollte als Faustregel gewährleistet werden, dass die
	  Zeit für beide Knoten im Cluster synchron läuft.</para>

	<para>Für die Fehlersuche bei Problemen mit
	  <acronym>HAST</acronym> sollte die Anzahl an
	  Debugging-Meldungen von &man.hastd.8; erhöht werden.  Dies
	  kann durch das Starten des &man.hastd.8; mit
	  <literal>-d</literal> erreicht werden.  Diese Option kann 
	  mehrfach angegeben werden, um die Anzahl an Meldungen weiter
	  zu erhöhen.  Auf diese Weise erhalten Sie viele nützliche
	  Informationen.  Sie sollten ebenfalls die Verwendung von
	  <literal>-F</literal> in Erwägung ziehen, die
	  &man.hastd.8; im Vordergrund startet.</para>
     </sect3>

      <sect3 xml:id="disks-hast-sb">
	<title>Auflösung des Split-brain-Zustands</title>

	<para><literal>split-brain</literal> bezeichnet eine
	  Situation, in der beide Knoten des Clusters nicht in der
	  Lage sind, miteinander zu kommunizieren und dadurch beide
	  als primäre Knoten fungieren.  Dies ist ein
	  gefährlicher Zustand, weil es beiden Knoten erlaubt ist,
	  Änderungen an den Daten vorzunehmen, die miteinander nicht
	  in Einklang gebracht werden können.  Diese Situation muss
	  vom Systemadministrator händisch bereinigt werden.</para>

	<para>Der Administrator muss entscheiden, welcher Knoten die
	  wichtigsten Änderungen von beiden besitzt (oder diese
	  manuell miteinander vermischen) und anschliessend den
	  <acronym>HAST</acronym>-Knoten die volle Synchronisation mit
	  jenem Knoten durchführen zu lassen, welcher die beschädigten
	  Daten besitzt.  Um dies zu tun, geben Sie folgende
	  Befehle auf dem Knoten ein, der neu synchronisiert werden
	  soll:</para>

        <screen>&prompt.root; <userinput>hastctl role init &lt;resource&gt;</userinput>
&prompt.root; <userinput>hastctl create &lt;resource&gt;</userinput>
&prompt.root; <userinput>hastctl role secondary &lt;resource&gt;</userinput></screen>
      </sect3>
    </sect2>
  </sect1>
</chapter>
