<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde: de-docproj/books/handbook/boot/chapter.xml,v 1.63 2012/04/22 20:05:15 bcr Exp $
     basiert auf: r40897
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="boot">
  <info><title>&os;s Bootvorgang</title>
    <authorgroup>
      <author><personname><firstname>Hans-Christian</firstname><surname>Ebke</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>
  

  <sect1 xml:id="boot-synopsis">
    <title>Übersicht</title>
    <indexterm><primary>booten</primary></indexterm>
    <indexterm><primary>Bootstrap</primary></indexterm>

    <para>Das Starten des Computers und das Laden des Betriebssystems
      wird im Allgemeinen als <quote>Bootstrap-Vorgang</quote>
      bezeichnet, oder einfach als <quote>Booten</quote>.  &os;s
      Bootvorgang ermöglicht große Flexibilität, was
      das Anpassen dessen anbelangt, was passiert, wenn das System
      gestartet wird.  Es kann zwischen verschiedenen Betriebssystemen,
      die auf demselben Computer installiert sind oder verschiedenen
      Versionen desselben Betriebssystems oder installierten Kernels
      gewählt werden.</para>

    <para>Dieses Kapitel zeigt die zur Verfügung stehenden
      Konfigurationsmöglichkeiten und wie man den Bootvorgang anpasst.
      Dies schließt alles ein, bis der Kernel gestartet worden ist,
      der dann alle Geräte gefunden hat und &man.init.8; gestartet hat.
      Dies passiert, wenn die Farbe des Textes während des Bootvorgangs
      von weiß zu grau wechselt.</para>

    <para>Dieses Kapitel informiert über folgende Punkte:</para>

    <itemizedlist>
      <listitem>
	<para>Die Komponenten des &os;-Bootvorgangs und deren
	  Interaktion.</para>
      </listitem>

      <listitem>
	<para>Die Optionen, mit denen der &os;-Bootvorgang gesteuert
	  werden kann.</para>
      </listitem>

      <listitem>
	<para>Wie Geräte mit &man.device.hints.5; konfiguriert
	  werden.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Dieses Kapitel erklärt den Bootvorgang von &os; auf
        Intel x86-Plattformen.</para>
    </note>
  </sect1>

  <sect1 xml:id="boot-introduction">
    <title>Das Problem des Bootens</title>

    <para>Wenn der Computer eingeschaltet wird und das Betriebssystem
      gestartet werden soll, entsteht ein interessantes Dilemma, denn der
      Computer weiß per Definition nicht, wie er irgendetwas tut, bis
      das Betriebssystem gestartet wurde.  Das schließt das Starten von
      Programmen, die sich auf der Festplatte befinden, ein.  Wenn
      der Computer kein Programm von der Festplatte starten kann, sich
      das Betriebssystem aber genau dort befindet, wie
      wird es dann gestartet?</para>

    <para>Dieses Problem ähnelt einer Geschichte des Barons von
      Münchhausen.  Dort war eine Person in einen Sumpf gefallen
      und hat sich selbst an den Riemen seiner Stiefel (engl.
      <foreignphrase>bootstrap</foreignphrase>) herausgezogen.  In den
      jungen Jahren des Computerzeitalters wurde mit dem Begriff
      Bootstrap dann die Technik das Betriebssystem zu laden bezeichnet
      und wurde hinterher mit booten abgekürzt.</para>

    <indexterm><primary>BIOS</primary></indexterm>

    <indexterm>
      <primary>Basic Input/Output System</primary>
      <see>BIOS</see>
    </indexterm>

    <para>Auf x86-Plattformen ist das BIOS (Basic Input/Output System)
      dafür verantwortlich, das Betriebssystem zu laden.  Dazu
      liest das BIOS den Master Bootsektor (MBR; Master Boot Record)
      aus, der sich an einer bestimmten Stelle auf der
      Festplatte/Diskette befinden muss.  Das BIOS kann den MBR
      selbstständig laden und ausführen und geht davon aus,
      dass dieser die restlichen Dinge, die für das Laden des
      Betriebssystems notwendig sind, selbst oder mit Hilfe des BIOS
      erledigen kann.</para>

    <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

    <indexterm><primary>Boot Manager</primary></indexterm>

    <indexterm><primary>Boot Loader</primary></indexterm>

    <para>Der Code innerhalb des MBRs wird für gewöhnlich als
      <emphasis>Boot-Manager</emphasis> bezeichnet, insbesondere, wenn
      eine Interaktion mit dem Anwender stattfindet.  Ist dies der Fall,
      verwaltet der Boot-Manager zusätzlichen Code im ersten
      <emphasis>Track</emphasis> der Platte oder in Dateisystemen
      anderer Betriebssysteme.  (Boot-Manager werden manchmal auch als
      <emphasis>Boot Loader</emphasis> bezeichnet, unter &os; wird
      dieser Begriff aber für eine spätere Phase des
      Systemstarts verwendet.)  Zu den bekanntesten Boot-Managern
      gehören <application>boot0</application> (der auch als
      <application>Boot Easy</application> bekannte
      Standard-Boot-Manager von &os;), <application>Grub</application>,
      <application>GAG</application>, sowie
      <application>LILO</application>.
      (Von diesen Boot-Managern hat nur <application>boot0</application>
      innerhalb des MBRs Platz.)</para>

    <para>Falls nur ein Betriebssystem installiert ist, ist der
      Standard MBR ausreichend.  Dieser MBR sucht nach dem ersten
      bootbaren Slice (das dabei als <emphasis>active</emphasis>
      gekennzeichnet ist) auf dem Laufwerk und führt den dort
      vorhandenen Code aus, um das restliche Betriebssystem zu
      laden.  Der von &man.fdisk.8; in der Voreinstellung
      installierte MBR ist ein solcher MBR und basiert auf
      <filename>/boot/mbr</filename>.</para>

    <para>Falls mehrere Betriebssysteme installiert sind, kann ein
      anderer Boot-Manager installiert werden, der eine Liste der
      verfügbaren Betriebssysteme anzeigt, so dass der Benutzer wählen
      kann, welches Betriebssystem er booten möchte.  Der nächste
      Abschnitt beschreibt zwei Boot-Manager.</para>

    <para>Das restliche &os;-Bootstrap-System ist in drei Phasen
      unterteilt.  Die erste Phase wird vom MBR durchgeführt, der
      gerade genug Funktionalität besitzt um den Computer in
      einen bestimmten Status zu verhelfen und die zweite Phase zu
      starten.  Die zweite Phase führt ein wenig mehr Operationen
      durch und startet schließlich die dritte Phase, die das Laden
      des Betriebssystems abschließt.  Der ganze Prozess wird in drei
      Phasen durchgeführt, weil PC Standards die Größe
      der Programme, die in Phase eins und zwei ausgeführt
      werden, limitiert.  Durch das Verketten der durchzuführenden
      Aufgaben wird es &os; möglich, ein sehr flexibles
      Ladeprogramm zu besitzen.</para>

    <indexterm><primary>Kernel</primary></indexterm>
    <indexterm><primary><command>init</command></primary></indexterm>

    <para>Als nächstes wird der Kernel gestartet, der zunächst nach
      Geräten sucht und sie für den Gebrauch
      initialisiert.  Nach dem Booten des Kernels übergibt dieser
      die Kontrolle an den Benutzer Prozess &man.init.8;, der erst
      sicherstellt, dass alle Laufwerke benutzbar sind und die
      Ressourcen Konfiguration auf Benutzer Ebene startet.  Diese
      wiederum mountet Dateisysteme, macht die Netzwerkkarten für
      die Kommunikation mit dem Netzwerk bereit und startet
      alle Prozesse, die konfiguriert wurden, um beim Hochfahren des
      &os;-Systems gestartet zu werden.</para>
</sect1>

  <sect1 xml:id="boot-blocks">
    <title>Boot-Manager und Boot-Phasen</title>

    <indexterm><primary>Boot Manager</primary></indexterm>

    <sect2 xml:id="boot-boot0">
      <title>Der Boot-Manager</title>

      <indexterm><primary>Master Boot Record (MBR)</primary></indexterm>

      <para>Der Code im MBR oder im Boot-Manager wird manchmal auch
        als <emphasis>stage zero</emphasis> des Boot-Prozesses
        bezeichnet.  Dieser Abschnitt beschreibt zwei Boot-Manager:
        <application>boot0</application> und
        <application>LILO</application>.</para>

      <formalpara><title>Der <application>boot0</application> Boot-Manager:</title>

        <para>Der vom &os;-Installationsprogramm oder &man.boot0cfg.8;
          in der Voreinstelung installierte Master Boot Record (MBR)
	  basiert auf <filename>/boot/boot0</filename>.  Die Größe und
	  Leistungsfähigkeit von <application>boot0</application> ist
	  auf 446&nbsp;Bytes beschränkt, weil der restliche Platz
          für die  Partitionstabelle sowie den
          <literal>0x55AA</literal>-Identifier
	  am Ende des MBRs benötigt wird.  Wenn
	  <application>boot0</application> und mehrere
	  Betriebssysteme installiert sind, wird beim Starten des
	  Computers eine Anzeige ähnlich der folgenden zu sehen
	  sein:</para></formalpara>

      <example xml:id="boot-boot0-example">
	<title><filename>boot0</filename>-Screenshot</title>

	<screen>F1 Win
F2 FreeBSD

Default: F2</screen>
      </example>

      <para>Diverse Betriebssysteme, insbesondere &windows;,
	überschreiben den existierenden MBR, wenn sie nach &os;
	installiert werden.  Falls dies passiert, kann mit
        folgendem Kommando der momentane MBR durch den &os;-MBR
        ersetzt werden:</para>

      <screen>&prompt.root; <userinput>fdisk -B -b /boot/boot0 <replaceable>Gerät</replaceable></userinput></screen>

      <para>Bei <replaceable>Gerät</replaceable> handelt es sich
        um das Gerät, von dem gebootet wird, also beispielsweise
        <filename>ad0</filename> für die erste IDE-Festplatte,
        <filename>ad2</filename> für die erste IDE-Festplatte
        am zweiten IDE-Controller, <filename>da0</filename>
	für die erste SCSI-Festplatte.  Um eine angepasste
	Konfiguration des MBR zu erstellen, lesen Sie
	&man.boot0cfg.8;.</para>

      <formalpara>
	<title>Der LILO-Boot-Manager:</title>

	<para>Damit dieser Boot-Manager auch &os; booten kann, starten
	  Sie zuerst Linux und fügen danach folgende Zeilen in die
	  Konfigurationsdatei <filename>/etc/lilo.conf</filename>
	  ein:</para>
      </formalpara>

      <programlisting>other=/dev/hdXY
table=/dev/hdX
loader=/boot/chain.b
label=FreeBSD</programlisting>

      <para>Dabei muss die primäre Partition von &os;
	sowie dessen Platte im Linux-Format angeben werden.  Dazu wird
	<replaceable>X</replaceable> durch die Linux-Bezeichnung der
	Platte und <replaceable>Y</replaceable> durch die von Linux
	verwendete Partitionsnummer ersetzt.  Für ein
	<acronym>SCSI</acronym>-Laufwerk wird
	<replaceable>/dev/sd</replaceable> anstelle von
	<replaceable>/dev/hd</replaceable> verwendet.  Die Zeile
	<option>loader=/boot/chain.b</option> kann weggelassen werden,
	wenn beide Betriebssysteme auf der gleichen Platte installiert
	sind.  Geben Sie danach <command>/sbin/lilo&nbsp;-v</command>
	ein, um die Änderungen zu übernehmen.  Achten Sie
	dabei besonders auf etwaige Fehlermeldungen.</para>
    </sect2>

    <sect2 xml:id="boot-boot1">
      <title>Phase Eins, <filename>/boot/boot1</filename> und Phase Zwei,
	<filename>/boot/boot2</filename></title>

      <para>Im Prinzip sind die erste und die zweite Phase Teile
	desselben Programms, im selben Bereich auf der
	Festplatte.  Aufgrund von Speicherplatz-Beschränkungen
	wurden sie in zwei Teile aufgeteilt, welche jedoch immer
	zusammen installiert werden.  Beide werden entweder vom
	Installer oder von <application>bsdlabel</application> aus
	der kombinierten <filename>/boot/boot</filename>
	kopiert.</para>

      <para>Beide Phasen befinden sich außerhalb des Dateisystems
        im Bootsektor des Boot-Slices, wo <link linkend="boot-boot0">boot0</link> oder ein anderer Boot-Manager
        ein Programm erwarten, das den weiteren Bootvorgang
        durchführen kann.  Die Anzahl der dabei verwendeten
        Sektoren wird durch die Größe von
        <filename>/boot/boot</filename> bestimmt.</para>

      <para><filename>boot1</filename> ist ein sehr einfaches
        Programm, da es nur 512&nbsp;Bytes groß sein darf, und es
        besitzt gerade genug Funktionalität, um &os;s
        <firstterm>bsdlabel</firstterm>, das Informationen über
        den Slice enthält, auszulesen, und um
        <filename>boot2</filename> zu finden und
        auszuführen.</para>

      <para><filename>boot2</filename> ist schon ein wenig
        umfangreicher und besitzt genügend Funktionalität, um
        Dateien in &os;s Dateisystem zu finden.  Außerdem hat es
        eine einfache Schnittstelle, die es ermöglicht, den zu
        ladenden Kernel oder Loader auszuwählen.</para>

      <para>Da der <link linkend="boot-loader">Loader</link> einen
        weitaus größeren Funktionsumfang hat und eine schöne
        und einfach zu bedienende Boot-Konfigurations-Schnittstelle zur
        Verfügung stellt, wird er gewöhnlich von
        <filename>boot2</filename> anstatt des Kernels
        gestartet.  Früher war es jedoch dazu da den Kernel direkt
        zu starten.</para>

      <example xml:id="boot-boot2-example">
	<title><filename>boot2</filename>-Screenshot</title>

	<screen>&gt;&gt; FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:</screen>
      </example>

      <para>&man.bsdlabel.8; kann dazu verwendet werden, dass
	installierte <filename>boot1</filename> und
	<filename>boot2</filename> zu ersetzen:</para>

      <screen>&prompt.root; <userinput>bsdlabel -B <replaceable>diskslice</replaceable></userinput></screen>

      <para>Wobei <replaceable>diskslice</replaceable> das Laufwerk
	und die Slice darstellt, von dem gebootet wird, beispielsweise
        <filename>ad0s1</filename> für die erste Slice
        auf der ersten IDE-Festplatte.</para>

      <warning>
	<title>Dangerously Dedicated Mode</title>

	<para>Wenn man nur den Festplatten-Namen, also
          z.B. <filename>ad0</filename> benutzt, wird &man.bsdlabel.8;
	  eine "dangerously dedicated disk" erstellen, ohne Slices.
	  Das ist ein Zustand, den man meistens nicht
	  hervorrufen möchte.  Aus diesem Grund sollte man das
	  <replaceable>diskslice</replaceable> von &man.bsdlabel.8;
	  noch einmal prüfen, bevor <keycap>Return</keycap> gedrückt
	  wird.</para>
      </warning>
    </sect2>

    <sect2 xml:id="boot-loader">
      <title>Phase drei, <filename>/boot/loader</filename></title>

      <indexterm><primary>boot-loader</primary></indexterm>
      <para>Der boot-loader ist der letzte von drei Schritten im
        Bootstrap-Prozess und kann im Dateisystem normalerweise unter
        <filename>/boot/loader</filename> gefunden werden.</para>

      <para>Der Loader soll eine interaktive
	Konfigurations-Schnittstelle mit eingebauten Befehlssatz
	sein, ergänzt durch einen umfangreichen Interpreter mit einem
	komplexeren Befehlssatz.</para>

      <sect3 xml:id="boot-loader-flow">
        <title>Loader Ablauf</title>

        <para>Der Loader sucht während seiner Initialisierung
          nach Konsolen und Laufwerken, findet heraus, von welchem
          Laufwerk er gerade bootet, und setzt dementsprechend
          bestimmte Variablen.  Dann wird ein Interpreter gestartet,
          der Befehle interaktiv oder von einem Skript empfangen
          kann.</para>
        <indexterm><primary>loader</primary></indexterm>
        <indexterm><primary>loader Konfiguration</primary></indexterm>

        <para>Danach liest der Loader die Datei
          <filename>/boot/loader.rc</filename> aus, welche ihn
          standardmäßig anweist
          <filename>/boot/defaults/loader.conf</filename> zu lesen, wo
          sinnvolle Standardeinstellungen für diverse Variablen
          festgelegt werden und wiederum
          <filename>/boot/loader.conf</filename> für lokale
          Änderungen an diesen Variablen ausgelesen
          wird.  Anschließend arbeitet dann
          <filename>loader.rc</filename> entsprechend dieser Variablen
          und lädt die ausgewählten Module und den
          gewünschten Kernel.</para>

        <para>In der Voreinstellung wartet der Loader
          10&nbsp;Sekunden lang auf eine Tastatureingabe und bootet den
          Kernel, falls keine Taste betätigt wurde.  Falls doch
          eine Taste betätigt wurde wird dem Benutzer eine
          Eingabeaufforderung angezeigt.  Sie nimmt einen
          Befehlssatz entgegen, der es dem Benutzer
          erlaubt, Änderungen an Variablen vorzunehmen, Module zu
          laden, alle Module zu entladen oder schließlich zu booten
          bzw. neu zu booten.</para>

      </sect3>

      <sect3 xml:id="boot-loader-commands">
        <title>Die eingebauten Befehle des Loaders</title>

        <para>Dies sind nur die gebräuchlichsten Befehle.
	  Eine vollständige Beschreibung aller verfügbaren Befehle
	  finden Sie in &man.loader.8;.</para>

      <variablelist>
	<varlistentry>
	  <term>autoboot <replaceable>Sekunden</replaceable></term>

	  <listitem>
	    <para>Es wird mit dem Booten des Kernels fortgefahren,
              falls keine Taste in der gegebenen Zeitspanne
              betätigt wurde.  In der gegebenen Zeitspanne, Vorgabe
	      sind 10&nbsp;Sekunden, wird ein Countdown angezeigt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot
	    <optional>-options</optional>
	    <optional>Kernelname</optional></term>

	  <listitem>
	    <para>Bewirkt das sofortige Booten des Kernels mit allen
	      gegebenen Optionen, oder dem angegebenen Kernelnamen.
	      Das übergeben eines Kernelnamens ist nur nach einem
	      <emphasis>unload</emphasis>-Befehl anwendbar,
	      andernfalls wird der zuvor verwendete Kernel
	      benutzt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>boot-conf</term>

	  <listitem>
	    <para>Bewirkt die automatische Konfiguration der Module,
	      abhängig von den entsprechenden Variablen (üblicherweise
	      <envar>kernel</envar>).  Dies nur dann sinnvoll, wenn
	      zuvor <command>unload</command> benutzt wurde.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>help
	    <optional>Thema</optional></term>

	  <listitem>
	    <para>Zeigt die Hilfe an, die zuvor aus der Datei
              <filename>/boot/loader.help</filename> gelesen
              wird.  Falls <literal>index</literal> als Thema angegeben
              wird, wird die Liste der zur Verfügung stehenden
              Hilfe-Themen angezeigt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>include <replaceable>Dateiname</replaceable>
	    &hellip;</term>

	  <listitem>
	    <para>Verarbeitet die angegebene Datei.  Das Einlesen und
	      Interpretieren geschieht Zeile für Zeile und wird im Falle eines
	      Fehlers umgehend unterbrochen.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>load <optional>-t
	    Typ</optional>
	    <replaceable>Dateiname</replaceable></term>

	  <listitem>
	    <para>Lädt den Kernel, das Kernel-Modul, oder die Datei
	      des angegebenen Typs.  Optionen, die auf
	      <replaceable>Dateinamen</replaceable> folgen, werden
	      der Datei übergeben.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>ls <optional>-l</optional>
	    <optional>Pfad</optional></term>

	  <listitem>
	    <para>Listet die Dateien im angegebenen Pfad auf, oder das
	      root-Verzeichnis(/), falls kein Pfad angegeben
	      wurde.  Die Option <option>-l</option> bewirkt, dass die
	      Dateigrößen ebenfalls angezeigt werden.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>lsdev <optional>-v</optional></term>

	  <listitem>
	    <para>Listet alle Geräte auf, für die Module geladen
	      werden können.  Die Option <option>-v</option> bewirkt
	      eine detailreichere Ausgabe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>lsmod <optional>-v</optional></term>

	  <listitem>
	    <para>Listet alle geladenen Module auf.  Die Option
	      <option>-v</option> bewirkt eine detailreichere
	      Ausgabe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>more <replaceable>Dateiname</replaceable></term>

	  <listitem>
	    <para>Zeigt den Dateinhalt der angegebenen Datei an, wobei
	      eine Pause alle <varname>LINES</varname> Zeilen gemacht
	      wird.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>reboot</term>

	  <listitem>
	    <para>Bewirkt einen umgehenden Neustart des Systems.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>set <replaceable>Variable</replaceable></term>
	  <term>set
	    <replaceable>Variable</replaceable>=<replaceable>Wert</replaceable></term>

	  <listitem>
	    <para>Setzt die Umgebungsvariablen des Loaders.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>unload</term>

	  <listitem>
	    <para>Entlädt sämtliche geladenen Module.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect3>

    <sect3 xml:id="boot-loader-examples">
      <title>Beispiele für die Loader Bedienung</title>

      <para>Hier ein paar praktische Beispiele für die Bedienung
	des Loaders.</para>

      <indexterm><primary>Single-User Modus</primary></indexterm>

      <itemizedlist>
	<listitem>
	  <para>Um den gewöhnlichen Kernel im Single-User Modus zu
	    starten:</para>

	  <screen><userinput>boot -s</userinput></screen>
	</listitem>

	<listitem>
	  <para>Um alle gewöhnlichen Kernelmodule zu entladen und dann
	    den alten, oder einen anderen Kernel zu
	    laden:</para>

	  <screen><userinput>unload</userinput>
<userinput>load <replaceable>kernel.old</replaceable></userinput></screen>

	  <para>Verwenden Sie <filename>kernel.GENERIC</filename>,
	    um den allgemeinen Kernel zu bezeichnen, der
	    vorinstalliert wird.  <filename>kernel.old</filename>
	    bezeichnet den Kernel, der vor dem System-Upgrade
	    installiert war.</para>

	  <note>
	    <para>Der folgende Befehl lädt die gewöhnlichen Module mit
              einem anderen Kernel:</para>

	    <screen><userinput>unload</userinput>
<userinput>set kernel="kernel.old"</userinput>
<userinput>boot-conf</userinput></screen></note>
	</listitem>

	<listitem>
	  <para>Folgendes lädt ein Kernelkonfigurations-Skript (ein
	    automatisiertes Skript, dass dasselbe tut, was der
	    Benutzer normalerweise von Hand an der Eingabeaufforderung
	    durchführen würde):</para>

	  <screen><userinput>load -t userconfig_script /boot/kernel.conf</userinput></screen>
	</listitem>
      </itemizedlist>
    </sect3>

    <sect3 xml:id="boot-splash">
      <info><title>Willkommmensbildschirme während des Bootvorgangs</title>
        <authorgroup>
          <author><personname><firstname>Joseph J.</firstname><surname>Barbish</surname></personname><contrib>Contributed by </contrib></author>
        </authorgroup>

        <authorgroup>
          <author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
        </authorgroup>
      </info>

      <para>Der Willkommmensbildschirm erzeugt einen alternativen
	Boot-Bildschirm, der alle Bootmeldungen und Meldungen über
	startende Dienste bis zur Anzeige des Anmeldeprompts
	überdeckt.</para>

      <para>Es existieren zwei grundlegende Umgebungen in &os;.  Die erste
        ist die altbekannte, auf virtuellen Konsolen basierte Kommandozeile.
        Nachdem das System den Bootvorgang abgeschlossen hat, wird ein
        Anmeldebildschirm auf der Konsole anzeigt.  Die zweite Umgebung
	ist die graphische Umgebung von <link linkend="x11">Xorg</link>.
	In diesem Kapitel finden Sie weitere Informationen zur
	Installation und Konfiguration eines grafischen
	Display-Managers und Login-Managers.</para>

      <sect4 xml:id="boot-splash-function">
        <title>Willkommensbildschirm-Funktionalität</title>

        <para>Die Willkommensbildschirm-Funktionalität unterstützt
	  256-Farben in den Formaten Bitmap
	  (<filename>.bmp</filename>), ZSoft <acronym>PCX</acronym>
	  (<filename>.pcx</filename>) oder TheDraw
	  (<filename>.bin</filename>).  Die
	  Willkommensbildschirm-Dateien dürfen eine Auflösung von 320
	  mal 200 Pixeln oder weniger besitzen, damit Standard-VGA
	  Geräte damit arbeiten können.</para>

        <para>Damit grössere Bilder bis zu einer maximalen Auflösung
	  von 1024 mal 768 Pixeln verwendet werden können, muss das
	  <acronym>VESA</acronym> Modul beim Systemstart geladen
	  werden.  Für einen <link linkend="kernelconfig">angepassten
	    Kernel</link> muss die
	  <literal>VESA</literal>-Kernelkonfigurationsoption
	  eingefügt werden.  <acronym>VESA</acronym>-Unterstützung
	  ermöglicht es, einen Willkommensbildschirm als Vollbild
	  auf dem gesamten Bildschirm anzuzeigen.</para>

        <para>Wenn der Willkommensbildschirm beim Bootvorgang angezeigt wird,
          kann dieser jederzeit mit einem beliebigen Tastendruck ausgeschaltet
          werden.</para>

        <para>Der Willkommensbildschirm ist standardmässig so
	  eingestellt, dass er als Bildschirmschoner verwendet wird.
	  Nach einer bestimmten Zeit der Untätigkeit
          wird der Willkommensbildschirm angezeigt und wechselt durch
          verschiedene Stufen der Intensität von hell zu einem
          sehr dunklen Bild und wieder zurück.  Das Verhalten des
	  Willkommensbildschirms kann durch hinzufügen einer
	  <literal>saver=</literal>-Zeile in
	  <filename>/etc/rc.conf</filename> geändert werden.  Es gibt
	  mehrere eingebaute Bildschirmschoner, die in &man.splash.4;
	  beschrieben werden.  Die <literal>saver=</literal>-Option
	  bezieht sich nur auf virtuelle Konsolen und hat keinen
	  Effekt bei grafischen Display-Managern.</para>

        <para>Ein paar Nachrichten des Bootloaders und ganz besonders das
          Menü mit den Bootoptionen und dem Warte-Countdown werden
          zur Bootzeit angezeigt, selbst wenn der Willkommensbildschirm
          aktiviert ist.</para>

        <para>Dateien mit Beispiel-Willkommensbildschirmen können von
          der Galerie auf <link xlink:href="http://artwork.freebsdgr.org/node/3/">http://artwork.freebsdgr.org</link> heruntergeladen werden.
          Durch die Installation des Ports <package>sysutils/bsd-splash-changer</package> können
          Willkommensbildschirme von einer zufällig ausgewählten
          Sammlung von Bildern bei jedem Neustart angezeigt werden.</para>
      </sect4>

      <sect4 xml:id="boot-splash-enable">
        <title>Aktivieren der Willkommensbildschirm-Funktionalität</title>

        <para>Die Willkommensbildschirm-Datei
	  <filename>.bmp</filename>, <filename>.pcx</filename> oder
	  <filename>.bin</filename>
	  muss im Wurzelverzeichnis, z.B. <filename>/boot</filename>
	  abgelegt werden.</para>

        <para>Für die Standard-Auflösung von 256-Farben, 320 mal
          200 Pixel oder weniger, bearbeiten Sie
          <filename>/boot/loader.conf</filename>, so dass diese die
          folgenden Zeilen enthält:</para>

        <programlisting>splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bmp</replaceable>"</programlisting>

        <para>Für grössere Video-Auflösungen bis zum Maximum
          von 1024 mal 768 Pixeln ändern Sie die Datei
          <filename>/boot/loader.conf</filename>, damit diese die folgenden
          Zeilen enthält:</para>

        <programlisting>vesa_load="YES"
splash_bmp_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bmp</replaceable>"</programlisting>

        <para>Dieses Beispiel geht davon aus, das
          <filename>/boot/splash.bmp</filename>
          als Willkommensbildschirm verwendet wird.  Um eine
          <acronym>PCX</acronym>-Datei zu verwenden, benutzen Sie
          die folgenden Zeilen, inklusive der
          <literal>vesa_load="YES"</literal>-Zeile, abhängig von der
          Auflösung:</para>

        <programlisting>splash_pcx_load="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.pcx</replaceable>"</programlisting>

	<para>Beginnend mit &os;&nbsp;8.3 gibt es die Option,
	  ASCII-Art im <uri
	    xlink:href="https://en.wikipedia.org/wiki/TheDraw">TheDraw</uri>-Format
	  zu benutzen.</para>

	<programlisting>splash_txt="YES"
bitmap_load="YES"
bitmap_name="<replaceable>/boot/splash.bin</replaceable>"</programlisting>

	<para>Der Dateiname ist nicht, wie im obigen Beispiel gezeigt,
	  auf <quote>splash</quote> beschränkt.  Es darf ein
	  beliebiger Name sein, solange die Datei von einem der
	  unterstützten Typen ist, beispielsweise
	  <filename><replaceable>splash_640x400</replaceable>.bmp</filename>
	  oder
	  <filename><replaceable>bluewave</replaceable>.pcx</filename>.</para>

        <para>Weitere interessante Optionen für
          <filename>loader.conf</filename> sind:</para>

        <variablelist>
          <varlistentry>
            <term><literal>beastie_disable="YES"</literal></term>

            <listitem>
              <para>Diese Option verhindert die Anzeige des Menüs mit
                den Bootoptionen, aber der Countdown ist immer noch aktiv.
                Selbst wenn das Bootmenü deaktiviert ist, kann
                während des Countdowns eine der korrespondierenden
                Optionen ausgewählt werden.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>loader_logo="beastie"</literal></term>

            <listitem>
              <para>Dies ersetzt die Standardanzeige des Wortes
		<quote>&os;</quote>. Stattdessen wird auf der rechten
		Seite des Bootmenüs das bunte Beastie-Logo
		angezeigt.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Weitere Informationen finden Sie in
          &man.splash.4;, &man.loader.conf.5; und &man.vga.4;.</para>
     </sect4>
    </sect3>
   </sect2>
  </sect1>

  <sect1 xml:id="boot-kernel">
    <title>Kernel Interaktion während des Bootprozesses</title>
    <indexterm>
      <primary>Kernel</primary>
      <secondary>boot interaction</secondary>
    </indexterm>

    <para>Wenn der Kernel einmal geladen ist, entweder durch den
      <link linkend="boot-loader">Loader</link> oder durch
      <link linkend="boot-boot1">boot2</link> welches den Loader
      umgeht, dann überprüft er evtl. vorhandene Boot-Flags und passt
      sein Verhalten nach Bedarf an.</para>

    <sect2 xml:id="boot-kernel-bootflags">
      <title>Kernel Boot-Flags</title>
      <indexterm>
        <primary>Kernel</primary>
        <secondary>bootflags</secondary>
      </indexterm>

      <para>Es folgt eine Auflistung der gebräuchlichsten
        Boot-Flags:</para>

      <variablelist xml:id="boot-kernel-bootflags-list">
	<varlistentry>
	  <term><option>-a</option></term>

	  <listitem>
	    <para>Bewirkt, dass während der
	      Kernel-Initialisierung gefragt wird, welches Gerät als
	      Root-Dateisystem gemounted werden soll.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-C</option></term>

	  <listitem>
	    <para>Es wird von CD-ROM gebootet.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-c</option></term>

	  <listitem>
	    <para>Startet UserConfig, das Boot-Zeit
	      Konfigurationsprogramm.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-s</option></term>

	  <listitem>
	    <para>Bewirkt den Start des Single-User Modus.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-v</option></term>

	  <listitem>
	    <para>Zeigt mehr Informationen während des Starten des
	      Kernels an.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <note>
	<para>Informationen zu den anderen Boot-Flags finden Sie in
	  &man.boot.8;.</para></note>
    </sect2>

<!--    <sect2 id="boot-kernel-userconfig">
      <title>UserConfig: Das Boot-Zeit Konfigurationsprogramm</title>

      <para> </para>
    </sect2> -->
  </sect1>

  <sect1 xml:id="device-hints">
    <info><title>Konfiguration von Geräten</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>


    <indexterm>
      <primary>device.hints</primary>
    </indexterm>

    <para>Der Boot-Loader liest während des Systemstarts die Datei
      &man.device.hints.5;, die Variablen, auch <quote>device hints</quote>
      genannt, zur Konfiguration von Geräten enthält.</para>

    <para>Die Variablen können auch mit Kommandos in der <link linkend="boot-loader">Phase&nbsp;3 des Boot-Loaders</link> bearbeitet
      werden.  Neue Variablen werden mit <command>set</command> gesetzt,
      <command>unset</command> löscht schon definierte Variablen und
      <command>show</command> zeigt Variablen an.  Variablen aus
      <filename>/boot/device.hints</filename> können zu diesem Zeitpunkt
      überschrieben werden.  Die hier durchgeführten Änderungen
      sind nicht permanent und beim nächsten Systemstart nicht mehr
      gültig.</para>

    <para>Nach dem Systemstart können alle Variablen mit &man.kenv.1;
      angezeigt werden.</para>

    <para>Pro Zeile enthält <filename>/boot/device.hints</filename>
      eine Variable.  Kommentare werden durch <literal>#</literal>
      eingeleitet.  Die verwendete Syntax lautet:</para>

    <screen><userinput>hint.driver.unit.keyword="value"</userinput></screen>

    <para>Der Boot-Loader verwendet die nachstehende Syntax:</para>

    <screen><userinput>set hint.driver.unit.keyword=<replaceable>value</replaceable></userinput></screen>

    <para>Der Gerätetreiber wird mit <literal>driver</literal>,
      die Nummer des Geräts mit <literal>unit</literal>
      angegeben.  <literal>keyword</literal> ist eine Option aus
      der folgenden Liste:</para>

    <itemizedlist>
      <listitem>
	<para><option>at</option>: Gibt den Bus, auf dem sich das
	  Gerät befindet, an.</para>
      </listitem>

      <listitem>
	<para><option>port</option>: Die Startadresse des
	  <acronym>I/O</acronym>-Bereichs.</para>
      </listitem>

      <listitem>
	<para><option>irq</option>: Gibt die zu verwendende
	  Unterbrechungsanforderung (IRQ) an.</para>
      </listitem>

      <listitem>
	<para><option>drq</option>: Die Nummer des DMA Kanals.</para>
      </listitem>

      <listitem>
	<para><option>maddr</option>: Die physikalische Speicheradresse des
	  Geräts.</para>
      </listitem>

      <listitem>
	<para><option>flags</option>: Setzt verschiedene
	  gerätespezifische Optionen.</para>
      </listitem>

      <listitem>
	<para><option>disabled</option>: Deaktiviert das Gerät, wenn
	  der Wert auf <literal>1</literal> gesetzt wird.</para>
      </listitem>
    </itemizedlist>

    <para>Ein Gerätetreiber kann mehr Optionen, als die hier
      beschriebenen, besitzen oder benötigen.  Es wird empfohlen, die
      Optionen in der Manualpage des Treibers nachzuschlagen.  Weitere
      Informationen finden Sie in &man.device.hints.5;, &man.kenv.1;,
      &man.loader.conf.5; und &man.loader.8;.</para>
  </sect1>

  <sect1 xml:id="boot-init">
    <title>Init: Initialisierung der Prozess-Kontrolle</title>
    <indexterm>
      <primary><command>init</command></primary>
    </indexterm>

    <para>Nachdem der Kernel den Bootprozess abgeschlossen hat,
      übergibt er die Kontrolle an den Benutzer-Prozess
      &man.init.8;.  Dieses Programm befindet sich in
      <filename>/sbin/init</filename>, oder dem Pfad, der durch die
      Variable <envar>init_path</envar> im <command>Loader</command>
      spezifiziert wird.</para>

    <sect2 xml:id="boot-autoreboot">
      <title>Der automatische Reboot-Vorgang</title>

      <para>Der automatische Reboot-Vorgang stellt sicher, dass alle
	Dateisysteme des Systems konsistent sind.  Falls dies nicht
	der Fall ist und die Inkonsistenz des UFS-Dateisystems nicht
	durch &man.fsck.8; behebbar ist, schaltet &man.init.8; das
	System in den <link
	  linkend="boot-singleuser">Single-User Modus</link>, damit
	der Systemadministrator sich des Problems annehmen
	kann.</para>
    </sect2>

    <sect2 xml:id="boot-singleuser">
      <title>Der Single-User Modus</title>
      <indexterm><primary>Single-User Modus</primary></indexterm>
      <indexterm><primary>Konsole</primary></indexterm>

      <para>Der Wechsel in den Single-User Modus kann durch <link
	  linkend="boot-autoreboot">den automatischen
	  Reboot-Vorgang</link>, das Booten mit der Option
	<option>-s</option>, oder das Setzen der
	<envar>boot_single</envar> Variable in
	<command>loader</command> erreicht werden.</para>

      <para>Weiterhin kann der Single-User Modus aus dem <link
	  linkend="boot-multiuser">Mehrbenutzermodus</link> heraus
	durch den Aufruf von &man.shutdown.8;, ohne die Option
	<option>-r</option> oder <option>-h</option>,
        erreicht werden.</para>

      <para>Falls die System-Konsole (<literal>console</literal>) in
        <filename>/etc/ttys</filename> auf <literal>insecure</literal>
	(dt.: unsicher) gesetzt ist, fordert das System zur Eingabe
	des Passworts von
	<systemitem class="username">root</systemitem> auf, bevor es
	den Single-User Modus aktiviert.</para>

      <example xml:id="boot-insecure-console">
	<title>Auf insecure gesetzte Konsole in
	  <filename>/etc/ttys</filename></title>

	<programlisting># name  getty                           type    status          comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</programlisting>
      </example>

      <note>
        <para>Eine Konsole sollte auf <literal>insecure</literal>
	  gesetzt sein, wenn die physikalische Sicherheit der Konsole
	  nicht gegeben ist und sichergestellt werden soll, dass nur
	  Personen, die das Passwort von <systemitem
	    class="username">root</systemitem> kennen, den
	  Single-User Modus benutzen können.  Daher kann man
	  <literal>insecure</literal> anstatt dem voreingestellten
	  <literal>secure</literal> verwenden, um dieses Maß an
	  Sicherheit zu ergänzen.</para>
      </note>
    </sect2>

    <sect2 xml:id="boot-multiuser">
      <title>Mehrbenutzermodus</title>
      <indexterm><primary>Mehrbenutzermodus</primary></indexterm>

      <para>Stellt &man.init.8; fest, dass das Dateisystem
	in Ordnung ist, oder der Benutzer den <link
	  linkend="boot-singleuser">Single-User Modus</link> beendet,
	schaltet das System in den Mehrbenutzermodus, in dem dann die
	Ressourcen Konfiguration des Systems gestartet wird.</para>

      <sect3 xml:id="boot-rc">
	<title>Ressourcen Konfiguration, rc-Dateien</title>
      <indexterm><primary>rc-Dateien</primary></indexterm>

	<para>Das Ressourcen Konfigurationssystem (engl.
	  <foreignphrase>resource configuration</foreignphrase>, rc)
	  liest seine Standardkonfiguration von
	  <filename>/etc/defaults/rc.conf</filename> und
	  System-spezifische Details von
	  <filename>/etc/rc.conf</filename>.  Dann mountet es die
	  Dateisysteme gemäß <filename>/etc/fstab</filename>, startet
	  die Netzwerkdienste, diverse System Daemons und führt
	  schließlich die Start-Skripten der lokal installierten
	  Anwendungen aus.</para>

	<para>Lesen Sie &man.rc.8; und ebenso die Skripte an sich, um
	  mehr über das Ressourcen Konfigurationssystem zu
	  erfahren.</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="boot-shutdown">
    <title>Der Shutdown-Vorgang</title>
    <indexterm>
      <primary><command>shutdown</command></primary>
    </indexterm>

    <para>Im Falle eines regulären Herunterfahrens durch
      &man.shutdown.8; führt &man.init.8;
      <filename>/etc/rc.shutdown</filename> aus, sendet dann
      sämtlichen Prozessen ein <literal>TERM</literal> Signal und
      schließlich ein <literal>KILL</literal> Signal an alle Prozesse,
      die sich nicht rechtzeitig beendet haben.</para>

    <para>&os;-Systeme, die Energieverwaltungsfunktionen
      unterstützen, können mit <command>shutdown -p now</command>
      ausgeschaltet werden.  Zum Neustart des Systems wird
      <command>shutdown -r now</command> benutzt.  Das Kommando
      &man.shutdown.8; kann nur von
      <systemitem class="username">root</systemitem> oder Mitgliedern
      der Gruppe <systemitem class="groupname">operator</systemitem>
      benutzt werden.  Man kann auch &man.halt.8; und &man.reboot.8;
      verwenden.  Weitere Informationen finden Sie in den
      Hilfeseiten der drei Kommandos.</para>

    <note>
      <para>Die Energieverwaltungsfunktionen erfordern, dass die
	Unterstützung für &man.acpi.4; als Modul geladen, oder
	statisch in einen angepassten Kernel kompiliert wird.</para>
    </note>
  </sect1>
</chapter>
