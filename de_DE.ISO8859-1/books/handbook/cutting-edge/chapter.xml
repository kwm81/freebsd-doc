<?xml version="1.0" encoding="iso-8859-1"?>
<!--
     The FreeBSD Documentation Project
     The FreeBSD German Documentation Project

     $FreeBSD$
     $FreeBSDde$
     basiert auf: r40998
-->
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:id="updating-upgrading">
  <info><title>&os; aktualisieren</title>
    <authorgroup>
      <author><personname><firstname>Jim</firstname><surname>Mock</surname></personname><contrib>Umstrukturiert und aktualisiert von </contrib></author>
      <!-- Mar 2000 -->
    </authorgroup>

    <authorgroup>
      <author><personname><firstname>Jordan</firstname><surname>Hubbard</surname></personname><contrib>Im Original von </contrib></author>
      <author><personname><firstname>Poul-Henning</firstname><surname>Kamp</surname></personname></author>
      <author><personname><firstname>John</firstname><surname>Polstra</surname></personname></author>
      <author><personname><firstname>Nik</firstname><surname>Clayton</surname></personname></author>
    </authorgroup>

    
    <authorgroup>
      <author><personname><firstname>Martin</firstname><surname>Heinen</surname></personname><contrib>Übersetzt von </contrib></author>
    </authorgroup>
  </info>


  <sect1 xml:id="updating-upgrading-synopsis">
    <title>Übersicht</title>

    <para>&os; wird zwischen einzelnen Releases ständig weiter
      entwickelt.  Manche Leute bevorzugen die offiziellen Release-Versionen,
      während andere wiederum lieber auf dem aktuellen Stand der
      Entwicklung bleiben möchten.  Wie dem auch sei, sogar offizielle
      Release-Versionen werden oft mit Sicherheitsaktualisierungen und
      anderen kritischen Fehlerbereinigungen versorgt.  Unabhängig von
      der eingesetzten Version bringt &os; alle nötigen Werkzeuge mit,
      um das System aktuell zu halten und es innerhalb verschiedener
      Versionen zu aktualisieren.  Dieses Kapitel beschreibt, wie man
      einem Entwicklungssystem folgen kann, sowie die
      grundlegenden Werkzeuge um &os; zu aktualisieren.</para>

    <para>Nachdem Sie dieses Kapitel gelesen haben, werden Sie</para>

    <itemizedlist>
      <listitem>
	<para>wissen, welche Werkzeuge verwendet werden können, um das
	  System und die Port-Sammlung zu aktualisieren.</para>
      </listitem>

      <listitem>
	<para>wissen, wie das System mit
	  <application>freebsd-update</application>,
	  <application>Subversion</application> oder
	  <application>CTM</application> aktualisiert wird.</para>
      </listitem>

      <listitem>
	<para>wissen, wie man das aktuell installierte System mit einer
	  ursprünglichen Version vergleicht.</para>
      </listitem>

      <listitem>
	<para>wissen, wie die installierte Dokumentation mit
	  <application>Subversion</application> oder
	  Dokumentations-Ports
          <!-- oder <application>Docsnap</application> -->
	  aktualisiert wird.</para>
      </listitem>

      <listitem>
	<para>den Unterschied zwischen den beiden Entwicklungszweigen
	  &os.stable; und &os.current; kennen.</para>
      </listitem>

      <listitem>
	<para>wissen, wie das komplette Basissystem neu gebaut und
	installiert wird.</para>
      </listitem>
    </itemizedlist>

    <para>Bevor Sie dieses Kapitel lesen, sollten Sie</para>

    <itemizedlist>
      <listitem>
	<para>das Netzwerk richtig konfiguriert haben
	  (<xref linkend="advanced-networking"/>).</para>
      </listitem>

      <listitem>
	<para>wissen, wie Software Dritter installiert wird
	  (<xref linkend="ports"/>).</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>In diesem Kapitel wird <command>svn</command> verwendet,
	um die &os; Quellen zu beziehen und zu aktualisieren.  Um es
	zu verwenden, muss zuerst der Port oder das Paket
	<package>devel/subversion</package> installiert werden.</para>
    </note>
  </sect1>

  <sect1 xml:id="updating-upgrading-freebsdupdate">
    <info>
      <title>&os;-Update</title>

      <authorgroup>
        <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>Basierend auf bereitgestellten Mitschriften von </contrib></author>
      </authorgroup>

      <authorgroup>
        <author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
    </info>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>freebsd-update</primary>
      <see>updating-upgrading</see>
    </indexterm>

    <para>Das Einspielen von Sicherheitsaktualisierungen ist ein wichtiger
      Bestandteil bei der Wartung von Computersoftware, besonders wenn es um
      das Betriebssystem geht.  Für lange Zeit war dieser Prozess unter
      &os; nicht einfach.  Fehlerbehebungen mussten auf den Quellcode
      angewendet werden, danach wurde der Code zu neuen Binärdateien
      übersetzt und schliesslich mussten diese Dateien neu installiert
      werden.</para>

    <para>Das ist seit längerem nicht mehr der Fall, da &os; jetzt ein
       Werkzeug namens <command>freebsd-update</command> enthält.  Dieses
       Werkzeug bringt zwei getrennte Funktionen mit sich.   Die erste Funktion
       ermöglicht die Anwendung von Sicherheitsaktualisierungen im
       Binärformat auf das &os; Basissystem, ohne dieses neu zu
       übersetzen und zu installieren.  Die zweite Funktion
       unterstützt Aktualisierungen zwischen Haupt- und
       Unterversionen.</para>

    <note>
      <para>Binäre Aktualisierungen sind für alle Architekturen und
        Releases verfügbar, die aktuell vom &os; Security Team betreut
        werden.  Vor
        der Aktualisierung auf eine neue Release-Version sollten die aktuellen
        Ankündigungen zu dem Release gelesen werden, da diese wichtige
        Informationen zu der gewünschten Version enthalten.  Release
	Ankündigungen finden Sie unter <uri
	  xlink:href="http://www.FreeBSD.org/releases/">http://www.FreeBSD.org/releases/</uri>.</para>
    </note>

    <para>Wenn eine <command>crontab</command> existiert, welche die
      Eigenschaften von &man.freebsd-update.8; verwendet, muss diese
      deaktiviert werden, bevor die folgende Aktion gestartet wird.</para>

    <sect2 xml:id="freebsdupdate-config-file">
      <title>Die Konfigurationsdatei</title>

      <para>Manche Anwender möchten sicherlich Einstellungen in der
        Standard-Konfigurationsdatei unter
        <filename>/etc/freebsd-update.conf</filename> vornehmen, um
        bessere Kontrolle über den
        gesamten Prozess zu besitzen.  Die Optionen sind gut dokumentiert,
        jedoch benötigen die folgenden ein paar zusätzliche
        Erklärungen:</para>

      <programlisting># Components of the base system which should be kept updated.
Components src world kernel</programlisting>

      <para>Dieser Parameter kontrolliert, welche Teile von &os; auf dem
        aktuellen Stand gehalten werden sollen.  In der Voreinstellung
	wird der Quellcode, das gesamte Basissystem sowie der Kernel
	aktualisiert.  Die Komponenten sind die gleichen wie während
	der Installation.  Das hinzufügen von
	<literal>world/games</literal> erlaubt es,
        Aktualisierungen für Spiele anzuwenden.
        Die Verwendung von <literal>src/bin</literal> erlaubt es, den
        Quellcode in <filename>src/bin</filename> aktuell zu
        halten.</para>

      <para>Die beste Einstellung ist, diese Option so zu belassen, da eine
        Änderung es bedingt, dass man als Benutzer jede Komponente
        auflisten muss, die aktualisiert werden soll.  Dies könnte
        katastrophale Folgen nach sich ziehen, da der Quellcode und die
        Binärdateien dadurch nicht mehr synchron wären.</para>

      <programlisting># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths</programlisting>

      <para>Fügen Sie Pfade wie <filename>/bin</filename> oder <filename>/sbin</filename> hinzu, um diese speziellen
        Verzeichnisse während des Aktualisierungsprozesses unberührt
        zu lassen.  Diese Option kann verwendet werden, um zu verhindern, dass
        <command>freebsd-update</command> lokale Änderungen
        überschreibt.</para>

      <programlisting># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</programlisting>

      <para>Aktualisiert nur unmodifizierte Konfigurationsdateien in
	den angegebenen Verzeichnissen.  Jede
        Änderung, die der Benutzer daran vorgenommen hat, wird die
        automatische Aktualisierung dieser Dateien ungültig machen.
        Es gibt eine weitere Option <literal>KeepModifiedMetadata</literal>,
        die <command>freebsd-update</command> instruiert, die Änderungen
        während der Zusammenführung zu speichern.</para>

      <programlisting># When upgrading to a new &os; release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/</programlisting>

      <para>Eine Liste von Verzeichnissen mit Konfigurationsdateien, in denen
        <command>freebsd-update</command> Zusammenführungen versuchen
        soll.  Dieser Verschmelzungsprozess von Dateien ist eine Serie von
        &man.diff.1;-Korrekturen, ähnlich wie &man.mergemaster.8;, aber
	mit weniger Optionen. Die Änderungen werden entweder akzeptiert,
        oder öffnen einen Editor, oder <command>freebsd-update</command> bricht
        ab.  Im Zweifelsfall sichern Sie <filename>/etc</filename> und
	akzeptieren einfach die Änderungen. Lesen Sie <xref
	  linkend="mergemaster"/>, um Informationen über
	<command>mergemaster</command> zu erhalten.</para>

      <programlisting># Directory in which to store downloaded updates and temporary
# files used by &os; Update.
# WorkDir /var/db/freebsd-update</programlisting>

      <para>In diesem Verzeichnis werden alle Korrekturen und
	temporären Dateien abgelegt.  Im Falle einer
	Versionsaktualisierung sollte diesem Verzeichnis mindestens
	ein Gigabyte Festplattenspeicher zur Verfügung stehen.</para>

      <programlisting># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which &os; Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</programlisting>

      <para>Wenn diese Option auf <literal>yes</literal> gesetzt ist, wird
        <command>freebsd-update</command> annehmen, dass die
        <literal>Components</literal>-Liste vollständig ist und nicht
        versuchen, Änderungen ausserhalb dieser Liste zu tätigen.
        Tatsächlich wird <command>freebsd-update</command> versuchen, jede
        Datei zu aktualisieren, die zu der <literal>Components</literal>-Liste
        gehört.</para>
    </sect2>

    <sect2 xml:id="freebsdupdate-security-patches">
      <title>Sicherheitsaktualisierungen</title>

      <para>Sicherheitsaktualisierungen für &os; können wie folgt
	heruntergeladen und installiert werden:</para>

      <screen>&prompt.root; <userinput>freebsd-update fetch</userinput>
&prompt.root; <userinput>freebsd-update install</userinput></screen>

      <para>Wenn während Aktualisierung Korrekturen am Kernel
	angewendet werden, muss das System neu gestartet werden, damit
	der korrigierte Kernel gebootet wird.  Andernfalls sollte das
	System aktualisiert sein und <command>freebsd-update</command>
	kann als nächtlicher &man.cron.8;-Job laufen, indem folgender
	Eintrag in <filename>/etc/crontab</filename> hinzugefügt
	wird:</para>

      <programlisting>@daily                                  root    freebsd-update cron</programlisting>

      <para>Dieser Eintrag besagt, dass
	<command>freebsd-update</command> einmal am Tag ausgeführt
	wird.  Wenn es über <option>cron</option> ausgeführt wird,
	prüft <command>freebsd-update</command> lediglich, ob
	Aktualisierungen vorliegen.  Wenn Korrekturen existieren,
	werden diese automatisch auf die lokale Festplatte
	heruntergeladen, aber nicht eingespielt.  Der <systemitem
	  class="username">root</systemitem>-Benutzer bekommt eine
	Nachricht, damit die Korrekturen überprüft und manuell
	installiert werden können.</para>

      <para>Wenn etwas schief geht, kann
	<command>freebsd-update</command> den letzten Satz von
	Änderungen mit folgendem Befehl rückgängig machen:</para>

      <screen>&prompt.root; <userinput>freebsd-update rollback</userinput></screen>

      <para>Sobald dieser Vorgang abgeschlossen ist, sollte das System neu
        gestartet werden, wenn der Kernel oder ein beliebiges Kernelmodul
        geändert wurde.  Dies ermöglicht es &os;, die neuen
        Binärdateien in den Hauptspeicher zu laden.</para>

      <para>Das <command>freebsd-update</command>-Werkzeug kann nur den
        <filename>GENERIC</filename>-Kernel automatisch aktualisieren.  Wenn
        ein angepasster Kernel verwendet wird, muss dieser neu
        erstellt und installiert werden, nachdem
        <command>freebsd-update</command> den Rest der Aktualisierungen
        durchgeführt hat.  Allerdings wird
	<command>freebsd-update</command> den
	<filename>GENERIC</filename>-Kernel in
	<filename>/boot/GENERIC</filename> erkennen und aktualisieren,
	selbst wenn dies nicht der aktuell verwendete Kernel des
	Systems ist.</para>

      <note>
        <para>Es ist eine gute Idee, immer eine Kopie des
          <filename>GENERIC</filename>-Kernels in <filename>/boot/GENERIC</filename> aufzubewahren.  Das wird
          bei der Diagnose von verschiedenen Problemen eine grosse Hilfe sein,
          sowie bei der Durchführung von Versionsaktualisierungen mit
          <command>freebsd-update</command>, wie in <xref linkend="freebsdupdate-upgrade"/> beschrieben ist.</para>
      </note>

      <para>Solange die Standardkonfiguration in
        <filename>/etc/freebsd-update.conf</filename> nicht geändert
        wurde, wird <command>freebsd-update</command> die aktualisierten
        Quellcodedateien des Kernels zusammen mit dem Rest der Neuerungen
        installieren.  Die erneute Übersetzung und Installation eines
        neuen, angepassten Kernels kann dann auf die übliche
        Art und Weise durchgeführt werden.</para>

      <note>
        <para>Die Aktualisierungen, die über
          <command>freebsd-update</command> verteilt werden, betreffen nicht
          immer den Kernel.  Es ist nicht notwendig, den angepassten
          Kernel neu zu erstellen, wenn die Kernelquellen nicht durch die
          Ausführung von <command>freebsd-update install</command>
          geändert wurden.  Allerdings wird
          <command>freebsd-update</command> immer
          <filename>/usr/src/sys/conf/newvers.sh</filename> aktualisieren.
          Der aktuelle Patch-Level, der mit der
	  <literal>-p</literal>-Nummer bei <command>uname -r</command>
	  ausgegeben wird, wird aus dieser Datei ausgelesen.
          Die Neuinstallation des angepassten Kernels, selbst wenn
          sich daran nichts geändert hat, erlaubt es &man.uname.1;, den
          aktuellen Patch-Level des Systems korrekt wiederzugeben.  Dies ist
          besonders hilfreich, wenn mehrere Systeme gewartet werden, da es
          eine schnelle Einschätzung der installierten Aktualisierungen in
          jedem einzelnen System ermöglicht.</para>
      </note>
    </sect2>

    <sect2 xml:id="freebsdupdate-upgrade">
      <title>Aktualisierungen an Haupt- und Unterversionen</title>

      <para>Aktualisierungen einer Unterversion zur nächsten in
	&os; ist beispielsweise die Aktualisierung von &os;&nbsp;9.0
	auf &os;&nbsp;9.1.  In der Regel funktionieren die
	installierten Anwendungen weiterhin problemlos nach der
	Aktualisierung einer Unterversion.</para>

      <para>Eine Aktualisierung der Hauptversion ist besipielsweise
	die Aktualisierung von &os;&nbsp;8.X auf &os;&nbsp;9.X.
	Dieser Prozess entfernt alte Objekt-Dateien und Bibliotheken,
	was dazu führt, dass die meisten Anwendungen von
	Drittherstellern nicht mehr funktionieren.  Nach der
	Aktualisierung auf eine neue Hauptversion wird empfohlen, dass
	alle installierten Ports entweder entfernt und neu
	installiert werden, oder mit einem Werkzeug wie
	<package>ports-mgmt/portmaster</package> aktualisiert werden.
	Um die Neuerstellung aller installierten Anwendungen zu
	erwzingen, benutzen Sie folgenden Befehl:</para>

      <screen>&prompt.root; <userinput>portmaster -f</userinput></screen>

      <para>Dies sorgt dafür, dass alles korrekt neu installiert wird.
        Beachten Sie, dass das Setzen der
        <varname>BATCH</varname>-Umgebungsvariable auf <literal>yes</literal>
        während dieses Prozesses auf jede Eingabe mit
        <literal>ja</literal> antwortet, was es nicht mehr notwendig macht,
        manuell eingreifen zu müssen.</para>

      <sect3 xml:id="freebsd-update-custom-kernel">
	<title>Umgang mit angepassten Kerneln</title>

	<para>Wenn ein angepasster Kernel verwendet wird, ist der
	  Aktualisierungsprozess ein wenig aufwändiger und das
	  Vorgehen variiert je nach Version von &os;.</para>

	<sect4 xml:id="freebsd-update-custom-kernel-8x">
	  <title>Angepasste Kernel unter &os;&nbsp;8.X und
	    früher</title>

	  <para>Eine Kopie des <filename>GENERIC</filename>-Kernel
	    wird benötigt und sollte in
	    <filename>/boot/GENERIC</filename> abgelegt sein.  Wenn
	    der <filename>GENERIC</filename>-Kernel nicht im
	    System vorhanden ist, kann er über eine der folgenden
	    Methoden bezogen werden:</para>

	  <itemizedlist>
	    <listitem>
	      <para>Wenn ein angepasster Kernel erstmalig gebaut
		wurde, ist der Kernel in
		<filename>/boot/kernel.old</filename>  in Wirklichkeit
		der <filename>GENERIC</filename>-Kernel.  Benennen Sie
		dieses Verzeichnis in
		<filename>/boot/GENERIC</filename> um.</para>
	    </listitem>

	    <listitem>
	      <para>Angenommen, ein direkter Zugriff auf die
		Maschine ist möglich, so kann eine Kopie des
		<filename>GENERIC</filename>-Kernels von den
		Installationsmedien installiert werden.  Benutzen
		Sie dazu folgende Befehle:</para>

	      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/X.Y-RELEASE/kernels</userinput>
&prompt.root; <userinput>./install.sh GENERIC</userinput></screen>

	      <para>Ersetzen Sie <filename>X.Y-RELEASE</filename>
		durch die aktuelle Version des verwendeten Releases.  Der
		<filename>GENERIC</filename>-Kernel wird standardmäßig
		in <filename>/boot/GENERIC</filename>
		installiert.</para>
	    </listitem>

	    <listitem>
	      <para>Falls alle obigen Schritte fehlschlagen, kann der
		<filename>GENERIC</filename>-Kernel folgendermaßen
		aus den Quellen neu gebaut und installiert
		werden:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>env DESTDIR=/boot/GENERIC make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput>
&prompt.root; <userinput>mv /boot/GENERIC/boot/kernel/* /boot/GENERIC</userinput>
&prompt.root; <userinput>rm -rf /boot/GENERIC/boot</userinput></screen>

	      <para>Damit dieser Kernel als
		<filename>GENERIC</filename>-Kernel von
		<command>freebsd-update</command> erkannt wird, darf
		die <filename>GENERIC</filename>-Konfigurationsdatei
		in keiner Weise geändert worden sein.  Es wird
		ebenfalls empfohlen, dass dieser ohne irgendwelche
		speziellen Optionen erstellt wird.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Der Neustart in den
	    <filename>GENERIC</filename>-Kernel ist zu diesem
	    Zeitpunkt nicht notwendig.</para>
	</sect4>

	<sect4 xml:id="freebsd-update-custom-kernel-9x">
	  <title>Angepasste Kernel unter &os;&nbsp;9.X und
	    später</title>

	  <itemizedlist>
	    <listitem>
	      <para>Wenn ein angepasster Kernel erstmalig gebaut
		wurde, ist der Kernel in
		<filename>/boot/kernel.old</filename>  in Wirklichkeit
		der <filename>GENERIC</filename>-Kernel.  Benennen Sie
		einfach dieses Verzeichnis in
		<filename>/boot/GENERIC</filename> um.</para>
	    </listitem>

	    <listitem>
	      <para>Angenommen, ein direkter Zugriff auf die Maschine
		ist möglich, so kann eine Kopie des
		<filename>GENERIC</filename>-Kernels von den
		Installationsmedien installiert werden.  Benutzen Sie
		dazu folgende Befehle:</para>

	      <screen>&prompt.root; <userinput>mount /cdrom</userinput>
&prompt.root; <userinput>cd /cdrom/usr/freebsd-dist</userinput>
&prompt.root; <userinput>tar -C/ -xvf kernel.txz boot/kernel/kernel</userinput></screen>
	    </listitem>

	    <listitem>
	      <para>Wenn die oben genannten Optionen nicht verwendet
		werden können, kann der
		<filename>GENERIC</filename>-Kernel aus den Quellen
		neu gebaut und installiert werden:</para>

	      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</userinput></screen>

	      <para>Damit dieser Kernel als
		<filename>GENERIC</filename>-Kernel von
		<command>freebsd-update</command> erkannt wird, darf
		die <filename>GENERIC</filename>-Konfigurationsdatei
		in keiner Weise geändert worden sein.  Es wird
		ebenfalls empfohlen, dass dieser ohne irgendwelche
		speziellen Optionen erstellt wird.</para>
	    </listitem>
	  </itemizedlist>

	  <para>Der Neustart in den
	    <filename>GENERIC</filename>-Kernel ist zu diesem
	    Zeitpunkt nicht notwendig.</para>
	</sect4>
      </sect3>

      <sect3 xml:id="freebsdupdate-using">
	<title>Die Aktualisierung durchführen</title>

	<para>Aktualisierungen an Haupt- und Unterversionen können
	  durchgeführt werden, wenn man
	  <command>freebsd-update</command> eine Release-Version als
	  Ziel übergibt.  Beispielsweise wird das folgende Kommando
	  das System auf &os;&nbsp;9.1 aktualisieren:</para>

	<screen>&prompt.root; <userinput>freebsd-update -r 9.1-RELEASE upgrade</userinput></screen>

	<para>Nachdem das Kommando empfangen wurde, überprüft
	  <command>freebsd-update</command> die Konfigurationsdatei
	  und das aktuelle System, um die nötigen Informationen für
	  die Systemaktualisierung zu sammeln.  Eine Bildschirmausgabe
	  wird anzeigen, welche Komponenten erkannt und welche nicht
	  erkannt wurden.  Zum Beispiel:</para>

	<screen>Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature for 9.0-RELEASE from update1.FreeBSD.org... done.
Fetching metadata index... done.
Inspecting system... done.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD do not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable (y/n)? y</screen>

	<para>An diesem Punkt wird <command>freebsd-update</command>
	  versuchen, alle notwendigen Dateien für die Aktualisierung
	  herunter zu laden.  In manchen Fällen wird der Benutzer mit
	  Fragen konfrontiert, um festzustellen, was installiert
	  werden soll oder auf welche Art und Weise fortgesetzt
	  werden soll.</para>

	<para>Wenn ein angepasster Kernel benutzt wird, produziert der
	  vorherige Schritt eine Warnung ähnlich zu der
	  folgenden:</para>

	<screen>WARNING: This system is running a "
<replaceable>MYKERNEL</replaceable>" kernel, which is not a
kernel configuration distributed as part of FreeBSD 9.0-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running "/usr/sbin/freebsd-update install"</screen>

	<para>Diese Warnung kann an dieser Stelle problemlos ignoriert
	  werden.  Der aktualisierte
	  <filename>GENERIC</filename>-Kernel wird als ein
	  Zwischenschritt im Aktualisierungsprozess verwendet.</para>

	<para>Nachdem alle Korrekturen auf das lokale System
	  heruntergeladen wurden, werden diese eingespielt.
	  Dieser Prozess kann eine gewisse Zeit in Anspruch nehmen,
	  abhängig von der Geschwindigkeit und Auslastung der
	  Maschine.  Konfigurationsdateien werden ebenfalls
	  zusammengefügt.  Dieser Teil der Prozedur
	  verlangt einige Benutzereingaben, da eine Datei
	  möglicherweise von Hand zusammengefasst werden muss oder ein
	  Editor erscheint auf dem Bildschirm zum manuellen
	  bearbeiten.  Die Ergebnisse von jeder erfolgreichen
	  Zusammenfassung werden dem Benutzer angezeigt, während der
	  Prozess weiter läuft.  Eine fehlgeschlagene oder ignorierte
	  Zusammenfassung wird den Prozess sofort beenden.  Benutzer
	  sollten eine Sicherung von <filename>/etc</filename> anlegen
	  und wichtige Dateien später manuell vereinen, beispielsweise
	  <filename>master.passwd</filename> oder
	  <filename>group</filename>.</para>

	<note>
	  <para>Das System ist zu diesem Zeitpunkt noch nicht
	    verändert worden, da alle Korrekturen und Vereinigungen
	    in einem anderen Verzeichnis vorgenommen wurden.  Wenn
	    alle Korrekturen erfolgreich eingespielt, alle
	    Konfigurationsdateien zusammengefügt wurden und es den
	    Anschein hat, dass der Prozess problemlos verlaufen wird,
	    müssen die Änderungen vom Anwender noch angewendet und auf
	    die Platte geschrieben werden:</para>

	  <screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>
	</note>

	<para>Der Kernel und die Module werden zuerst aktualisiert.
	  Zu diesem Zeitpunkt muss die Maschine neu gestartet werden.
	  Wenn das System einen angepassten Kernel verwendet, benutzen
	  Sie &man.nextboot.8;, um den Kernel für den nächsten
	  Neustart auf <filename>/boot/GENERIC</filename> zu
	  setzen:</para>

	<screen>&prompt.root; <userinput>nextboot -k GENERIC</userinput></screen>

	<warning>
	  <para>Bevor das System mit dem
	    <filename>GENERIC</filename>-Kernel neu gestartet wird,
	    vergewissern Sie sich, dass für den Neustart alle
	    benötigten Treiber enthalten sind.  Falls auf die
	    Maschine aus der Ferne zugegriffen wird, stellen Sie
	    sicher, dass das System ordnungsgemäß an das Netzwerk
	    angeschlossen ist.  Achten Sie besonders darauf, dass wenn
	    der angepasste Kernel Funktionalität beinhaltet, die
	    normalerweise von Kernelmodulen zur Verfügung gestellt
	    werden, dass diese temporär über
	    <filename>/boot/loader.conf</filename> in den
	    <filename>GENERIC</filename>-Kernel übernommen werden.
	    Zudem wird empfohlen, nicht benötigte Dienste, eingehängte
	    Platten und verbundene Netzlaufwerke zu deaktivieren, bis
	    der Aktualisierungsprozess abgeschlossen ist.</para>
	</warning>

        <para>Die Maschine sollte nun mit dem aktualisierten Kernel neu
          gestartet werden:</para>

        <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

	<para>Sobald das System wieder online ist, muss
	  <command>freebsd-update</command> erneut gestartet werden.
	  Der Zustand des Prozesses wurde zuvor gesichert und deshalb
	  wird <command>freebsd-update</command> nicht von vorne
	  beginnen, jedoch alle alten gemeinsam genutzten
	  Bibliotheken und Objektdateien löschen.</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<note>
	  <para>Abhängig davon, ob irgendwelche Bibliotheksversionen
	    erhöht wurden, kann es sein, dass nur zwei
	    Installationsphasen anstatt drei durchlaufen
	    werden.</para>
	</note>
      </sect3>

      <sect3 xml:id="freebsdupdate-portsrebuild">
	<title>Neubau der Ports nach einer Aktualisierung auf eine
	  Hauptversion</title>

	<para>Nach der Aktualisierung auf eine Hauptversion, muss
	  jegliche Drittanbieter-Software neu erstellt und
	  installiert werden.  Dies ist notwendig, da die
	  installierte Software möglicherweise Abhängigkeiten zu
	  Bibliotheken enthält, die während der Aktualisierung
	  entfernt wurden.  Dieser Prozess kann mit einem Werkzeug wie
	  <package>ports-mgmt/portmaster</package> automatisiert
	  werden:</para>

	<screen>&prompt.root; <userinput>portmaster -f</userinput></screen>

	<para>Sobald dies abgeschlossen ist, beenden Sie den
	  Aktualisierungsprozess mit einem letzten Aufruf von
	  <command>freebsd-update</command>.  Geben Sie den folgenden
	  Befehl ein, um alle losen Enden des Aktualisierungsprozesses
	  miteinander zu verknüpfen:</para>

	<screen>&prompt.root; <userinput>freebsd-update install</userinput></screen>

	<para>Wenn der <filename>GENERIC</filename>-Kernel temporär
	  Verwendung fand, ist dies der richtige Zeitpunkt, einen neuen,
	  angepassten Kernel zu bauen und über die übliche
	  Methode zu installieren.</para>

	<para>Booten Sie anschließend die Maschine in die neue &os;-Version.
	  Der Prozess ist damit abgeschlossen.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="freebsdupdate-system-comparison">
      <title>Vergleich des Systemzustands</title>

      <para><command>freebsd-update</command> kann verwendet werden,
	um den Zustand der installierten &os;-Version gegenüber
	einer bekannten und funktionierenden Kopie zu vergleichen.
	Diese Option vergleicht die aktuelle Version von
	Systemwerkzeugen, Bibliotheken und Konfigurationsdateien.  Um
	diesen Vergleich zu starten, geben Sie den folgenden Befehl
	ein:</para>

      <screen>&prompt.root; <userinput>freebsd-update IDS &gt;&gt; outfile.ids</userinput></screen>

      <warning>
        <para>Obwohl der Befehlsname <acronym>IDS</acronym> lautet,
	  ist dies kein Ersatz für ein echtes Intrusion Detection
	  System wie <package>security/snort</package>.  Da
	  <command>freebsd-update</command> seine Daten auf Platte
	  ablegt, ist die Möglichkeit von Verfälschungen
	  offensichtlich.  Obwohl diese Möglichkeit durch die
	  Verwendung von <varname>kern.securelevel</varname> oder die
	  Ablage von Daten auf einem Nur-Lese Dateisystem eingedämmt
	  werden kann, besteht eine bessere Lösung darin, das System
	  gegen ein gesichertes Medium, wie eine
	  <acronym>DVD</acronym> oder einen externen, separat
	  aufbewahrten <acronym>USB</acronym>-Plattenspeicher, zu
	  vergleichen.</para>
      </warning>

      <para>Das System wird nun überprüft, und eine lange Liste
	von Dateien zusammen mit den &man.sha256.1;-Hashwerten, sowohl
	der von der Release-Version bekannte Wert als auch der des
	aktuell installierten Systems, in
	<filename>outfile.ids</filename> geschrieben.</para>

      <para>Die Zeilen in der Ausgabe sind extrem lang, aber das
	Ausgabeformat kann einfach verarbeitet werden.  Um
	beispielsweise eine Liste von allen Dateien zu erhalten, die
	sich vom aktuellen Release unterscheiden, geben Sie das
	folgende Kommando ein:</para>

      <screen>&prompt.root; <userinput>cat outfile.ids | awk '{ print $1 }' | more</userinput>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</screen>

      <para>Diese Beispielausgabe wurde abgeschnitten, da noch viele
	weitere Dateien vorhanden sind.  Einige Dateien wurden auf
	natürliche Art verändert.  <filename>/etc/passwd</filename>
	wurde beispielsweise geändert, um Benutzer zum System
	hinzuzufügen.  Andere Dateien, wie Kernelmodule, unterscheiden
	sich, weil <command>freebsd-update</command> diese
	aktualisiert hat.  Um bestimmte Dateien oder Verzeichnisse
	auszuschließen, fügen Sie diese an die
	<literal>IDSIgnorePaths</literal>-Option in
	<filename>/etc/freebsd-update.conf</filename> an.</para>

      <para>Diese Vorgehensweise kann als Teil einer ausgeklügelten
        Aktualisierungsmethode benutzt werden, unabhängig von der zuvor
        angesprochenen Variante.</para>
    </sect2>
  </sect1>

  <sect1 xml:id="updating-upgrading-portsnap">
    <info><title>Portsnap: Ein Werkzeug zur Aktualisierung der Ports-Sammlung</title>
      <authorgroup>
	<author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Geschrieben von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Colin</firstname><surname>Percival</surname></personname><contrib>Basierend auf bereitgestellten Mitschriften von </contrib></author>
      </authorgroup>
      <authorgroup>
	<author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
    </info>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>
    <indexterm>
      <primary>Portsnap</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Das Basissystem von &os; enthält &man.portsnap.8; zum
      Aktualisieren der Ports-Sammlung.  Dieses Programm verbindet
      sich mit einem entfernten Rechner, überprüft den
      Sicherungsschlüssel und lädt eine neue Kopie der Ports-Sammlung
      herunter.  Der Schlüssel wird verwendet, um die Integrität aller
      heruntergeladenen Dateien zu prüfen.  Um die aktuellsten Dateien
      der Ports-Sammlung herunter zu laden, geben Sie das folgende
      Kommando ein:</para>

    <screen>&prompt.root; <userinput>portsnap fetch</userinput>
Looking up portsnap.FreeBSD.org mirrors... 9 mirrors found.
Fetching snapshot tag from geodns-1.portsnap.freebsd.org... done.
Fetching snapshot metadata... done.
Updating from Tue May 22 02:12:15 CEST 2012 to Wed May 23 16:28:31 CEST 2012.
Fetching 3 metadata patches.. done.
Applying metadata patches... done.
Fetching 3 metadata files... done.
Fetching 90 patches.....10....20....30....40....50....60....70....80....90. done.
Applying patches... done.
Fetching 133 new ports or files... done.</screen>

    <para>Dieses Beispiel zeigt, dass &man.portsnap.8; mehrere
      Korrekturen für die aktuellen Ports-Daten gefunden und
      verifiziert hat.  Es zeigt auch, dass das Programm zuvor schon
      einmal gestartet wurde.  Wäre es das erste Mal, würde nur die
      Ports-Sammlung heruntergeladen werden.</para>

    <para>Wenn &man.portsnap.8; die <command>fetch</command>-Operation
      erfolgreich abgeschlossen hat, befinden sich die Ports-Sammlung
      und die dazugehörigen Korrekturen, welche die Überprüfung
      bestanden haben, auf dem lokalen System.  Wenn
      <command>portsnap</command> das erste Mal ausgeführt wird,
      muss <literal>portsnap extract</literal> aufgerufen werden,
      um die Ports-Sammlung zu installieren:</para>

    <screen>&prompt.root; <userinput>portsnap extract</userinput>
/usr/ports/.cvsignore
/usr/ports/CHANGES
/usr/ports/COPYRIGHT
/usr/ports/GIDs
/usr/ports/KNOBS
/usr/ports/LEGAL
/usr/ports/MOVED
/usr/ports/Makefile
/usr/ports/Mk/bsd.apache.mk
/usr/ports/Mk/bsd.autotools.mk
/usr/ports/Mk/bsd.cmake.mk
<replaceable>...</replaceable></screen>

    <para>Um eine bereits installierte Ports-Sammlung zu
      aktualisieren, verwenden Sie
      <command>portsnap update</command>:</para>

    <screen>&prompt.root; <userinput>portsnap update</userinput></screen>

    <para>Der Prozess ist jetzt abgeschlossen und Anwendungen können
      mittels der aktuellen Ports-Sammlung installiert oder aktualisiert
      werden.</para>

    <para>Die Operationen <literal>fetch</literal> und
      <literal>extract</literal> oder <literal>update</literal> können
      auch nacheinander ausgeführt werden:</para>

    <screen>&prompt.root; <userinput>portsnap fetch update</userinput></screen>

    <para>Dieser Befehl lädt die aktuelle Version der Ports-Sammlung
      herunter und aktualisiert anschließend die lokale Version unter
      <filename>/usr/ports</filename>.</para>
  </sect1>

  <sect1 xml:id="updating-upgrading-documentation">
    <info><title>Aktualisieren der Dokumentationssammlung</title>
      <authorgroup>
	<author><personname><firstname>Benedict</firstname><surname>Reuschling</surname></personname><contrib>Übersetzt von </contrib></author>
      </authorgroup>
    </info>

    <indexterm><primary>Updating and Upgrading</primary></indexterm>

    <indexterm>
      <primary>Documentation</primary>
      <see>Updating and Upgrading</see>
    </indexterm>

    <para>Dokumentation ein wichtiger Bestandteil des &os;
      Betriebssystems.  Obwohl eine aktuelle Version der &os;
      Dokumentation jederzeit auf der <link
      xlink:href="http://www.freebsd.org/doc/">&os; Webseite</link>
      verfügbar ist, verfügen manche Benutzer nur über eine langsame
      oder überhaupt keine Netzwerkverbindung.  Es gibt mehrere
      Möglichkeiten, die lokale Kopie der Dokumentation durch die
      aktuelle &os;-Dokumentationssammlung zu aktualisieren.</para>

    <sect2 xml:id="dsvn-doc">
      <title>Verwenden von <application>Subversion</application> um
	die Dokumentation zu aktualisieren</title>

      <para>Die Dokumentationsquellen von &os; können mittels
	<application>svn</application> aktualisiert werden.  Dieser
	Abschnitt beschreibt:</para>

      <itemizedlist>
	<listitem>
	  <para>Die Installation der Dokumentations-Werkzeugsammlung,
	    welche die Werkzeuge enthält, die nötig sind, um die &os;
	    Dokumentation aus den Quellen neu zu erstellen.</para>
	</listitem>

	<listitem>
	  <para>Das Herunterladen einer Kopie der
	    Dokumentationsquellen nach <filename>/usr/doc</filename>,
	    unter Verwendung von
	    <application>svn</application>.</para>
	</listitem>

	<listitem>
	  <para>Den Bau der &os; Dokumentation aus den Quellen und
	    die Installation unter
	    <filename>/usr/share/doc</filename>.</para>
	</listitem>

	<listitem>
	  <para>Manche der Optionen zum Erstellen, die vom System zum
	    Bauen der Dokumentation unterstützt werden, z.B. die
	    Optionen welche nur ein paar der unterschiedlichen
	    Sprachübersetzungen der Dokumentation erstellen oder die
	    Optionen, die ein bestimmtes Ausgabeformat
	    auswählen.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 xml:id="installing-documentation-toolchain">
      <title><application>svn</application> und die Werkzeugsammlung
	der Dokumentation installieren</title>

      <para>Die Erstellung der &os; Dokumentation aus den Quellen
	benötigt eine große Anzahl an Werkzeugen, die nicht Teil des
	&os; Basissystems sind, da sie eine große Menge
	Plattenplatz verbrauchen und nicht von allen &os;-Anwendern
	benötigt werden.  Sie sind daher nur für diejenigen Benutzer
	sinnvoll, die aktiv neue Dokumentation für &os; schreiben
	oder häufig die Dokumentation aus den Quellen
	aktualisieren.</para>

      <para>Alle benötigten Werkzeuge, einschließlich
	<application>svn</application> sind im Meta-Port
	<package>textproc/docproj</package> vorhanden, der
	vom &os; Documentation Project entwickelt wurde.</para>

      <note>
	<para>Wenn Sie die Dokumentation nicht als &postscript; oder PDF
	  benötigen, können Sie alternativ die Installation des
	  <package>textproc/docproj-nojadetex</package>-Ports
	  in Erwägung ziehen.  Diese Version der
	  Dokumentations-Werkzeugsammlung enthält alles ausser das
	  <application>teTeX</application>-Textsatzsystem.
	  <application>teTeX</application> ist eine sehr grosse Sammlung an
	  Werkzeugen, deshalb ist es vernünftig, deren Installation
	  auszulassen, wenn die Ausgabe von PDF nicht unbedingt gebraucht
	  wird.</para>
      </note>
    </sect2>

    <sect2 xml:id="updating-documentation-sources">
      <title>Die Dokumentationsquellen aktualisieren</title>

      <para>In diesem Beispiel wird <application>svn</application>
	verwendet, um eine saubere Kopie der Dokumentationsquellen
	über das <acronym>HTTPS</acronym>-Protokoll zu holen:</para>

      <screen>&prompt.root; <userinput>svn checkout <replaceable>https://svn.freebsd.org/doc/head</replaceable>/doc/head /usr/doc</userinput></screen>

      <para>Benutzen Sie dazu einen der Spiegel aus <link
	  linkend="svn-mirrors">Subversion Mirror Sites</link>.</para>

      <para>Es dauert eine Weile, wenn die Dokumentationsquellen das allererste
        Mal heruntergeladen werden. Lassen Sie es laufen, bis es fertig
        ist.</para>

      <para>Zukünftige Aktualisierungen der Dokumentationsquellen
        können wie folgt durchgeführt werden:</para>

      <screen>&prompt.root; <userinput>svn update /usr/doc</userinput></screen>

      <para>Nachdem die Quellen einmal ausgecheckt wurden,  wird durch
	<filename>/usr/doc/Makefile</filename> ein alternativer Weg
	unterstützt, die Dokumentation zu aktualisieren.  Geben Sie
	dazu die folgenden Befehle ein:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make update</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-documentation-options">
      <title>Einstellbare Optionen der Dokumentationsquellen</title>

      <para>Das System zum aktualisieren und erstellen der
	&os;-Dokumentationssammlung unterstützt ein paar Optionen,
	welche den Prozess der Aktualisierung von Teilen der
	Dokumentation oder einer bestimmten Übersetzung erleichtert.
	Diese Optionen können entweder systemweit in
	<filename>/etc/make.conf</filename> gesetzt, oder als
	Kommandozeilenoptionen an &man.make.1; übergeben
	werden.</para>

      <para>Zu den Optionen gehören:</para>

      <variablelist>
	<varlistentry>
	  <term><varname>DOC_LANG</varname></term>

	  <listitem>
	    <para>Eine Liste von Sprachen und Kodierungen, die gebaut
	      und installiert werden sollen, z.B.
	      <literal>en_US.ISO8859-1</literal>, um nur die englische
	      Dokumentation zu erhalten.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>FORMATS</varname></term>

	  <listitem>
	    <para>Ein einzelnes Format oder eine Liste von Ausgabeformaten, das
	      gebaut werden soll. Momentan werden <literal>html</literal>,
	      <literal>html-split</literal>, <literal>txt</literal>,
	      <literal>ps</literal>, <literal>pdf</literal>,
	      und <literal>rtf</literal> unterstützt.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>DOCDIR</varname></term>

	  <listitem>
	    <para>Wohin die Dokumentation installiert werden soll.  Der
	      Standardpfad ist <filename>/usr/share/doc</filename>.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Für weitere <command>make</command>-Variablen, die als
	systemweite Optionen in &os; unterstützt werden, lesen Sie
	&man.make.conf.5;.</para>

      <para>Für weitere <command>make</command>-Variablen, die vom
	System zum Erstellen der &os;-Dokumentation unterstützt
	werden, lesen Sie die <link
	  xlink:href="&url.doc.langbase;/books/fdp-primer">Fibel für
	  neue Mitarbeiter
	  des &os;-Dokumentationsprojekts</link>.</para>
    </sect2>

    <sect2 xml:id="updating-installed-documentation">
      <title>Die &os;-Dokumentation aus den Quellen
	installieren</title>

      <para>Sobald ein aktueller Schnappschuss der
	Dokumentationsquellen nach <filename>/usr/doc</filename>
	heruntergeladen wurde, ist alles bereit für eine
	Aktualisierung der bestehenden Dokumentation.</para>

      <para>Eine komplette Aktualisierung aller Sprachen, definiert in
	<varname>DOC_LANG</varname>, kann durch folgende Eingabe
	erreicht werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

      <para>Wenn nur eine Aktualisierung einer bestimmten Sprache
        gewünscht wird, kann &man.make.1; in einem sprachspezifischen
        Unterverzeichnis von <filename>/usr/doc</filename>
        aufgerufen werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc/en_US.ISO8859-1</userinput>
&prompt.root; <userinput>make update install clean</userinput></screen>

      <para>Die zu installierenden Ausgabeformate können durch das
	Setzen von <varname>FORMATS</varname> angegeben werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/doc</userinput>
&prompt.root; <userinput>make FORMATS='html html-split' install clean</userinput></screen>

      <para>Informationen zum Bearbeiten und Einreichen von
	Korrekturen finden Sie in der <link
	  xlink:href="&url.doc.langbase;/books/fdp-primer">Fibel für
	  neue Mitarbeiter des
	  &os;-Dokumentationsprojekts</link>.</para>
    </sect2>

    <sect2 xml:id="doc-ports">
      <info><title>Verwendung von Dokumentations-Ports</title>
	<authorgroup>
	  <author><personname><firstname>Marc</firstname><surname>Fonvieille</surname></personname><contrib>Basierend auf der Arbeit von </contrib></author>
	</authorgroup>
      </info>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>documentation package</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para>Im vorherigen Abschnitt wurde eine Methode gezeigt, wie
	die &os;-Dokumentation aus den Quellen gebaut werden kann.
	Allerdings sind quellbasierte Aktualisierungen möglicherweise
	nicht für alle &os;-Systeme geeignet oder praktikabel.  Das
	Erstellen der Dokumentationsquellen benötigt eine große Anzahl
	an Werkzeugen, Programmen und Hilfsmitteln, die
	<emphasis>documentation toolchain</emphasis>, einen gewissen
	Grad an Vertrautheit mit <application>svn</application>,
	ausgecheckte Quellen von einem Repository, sowie ein paar
	manuelle Schritte, um diese ausgecheckten Quellen zu bauen.
	Dieser Abschnitt beschreibt eine alternative Methode, in der
	die Ports-Sammlung verwendet wird und die es
	ermöglicht:</para>

      <itemizedlist>
	<listitem>
	  <para>vorgefertigte Schnappschüsse der Dokumentation
	    herunterzuladen und zu installieren, ohne vorher die
	    Werkzeugsammlung der Dokumentation installieren zu
	    müssen.</para>
	</listitem>

	<listitem>
	  <para>die Dokumentationsquellen herunterzuladen und durch
	    das Ports-System erstellen zu lassen, was die Schritte zum
	    Auschecken und Erstellen etwas erleichtert.</para>
	</listitem>
      </itemizedlist>

      <para>Diese beiden Methoden der Aktualisierung der
	&os;-Dokumentation werden durch eine Menge von
	<emphasis>Dokumentations-Ports</emphasis> unterstützt, die von
	&a.doceng; monatlich aktualisiert wird.  Diese sind in der
	&os; Ports-Sammlung unter der Kategorie docs gelistet
	(<link
	  xlink:href="http://www.freshports.org/docs/">http://www.freshports.org/docs/</link>).</para>

      <sect3 xml:id="doc-ports-install-make">
	<title>Erstellen und Installieren von Dokumentations-Ports</title>

	<para>Die Dokumentations-Ports nutzen das Ports-System, um das
	  Erstellen von Dokumentation wesentlich einfacher zu machen.  Es
	  automatisiert den Prozess des Auscheckens der Dokumentationsquellen,
	  aufrufen von &man.make.1; mit den passenden Umgebungsvariablen und
	  Kommandozeilenoptionen und macht die Installation und Deinstallation
	  von Dokumentation so einfach wie die Installation von jedem anderen
	  Port oder Paket.</para>

	<note>
	  <para>Als zusätzliche Eigenschaft zeichnen sie eine
	    Abhängigkeit zur
	    <emphasis>Dokumentations-Werkzeugsammlung</emphasis> auf,
	    wenn die Dokumentations-Ports lokal erstellt werden,
	    weshalb diese auch automatisch mitinstalliert wird.</para>
	</note>

	<para>Die Dokumentations-Ports sind wie folgt organisiert:</para>

	<itemizedlist>
	  <listitem>
	    <para>Der <quote>Master-Port</quote>,
	      <package>misc/freebsd-doc-en</package>, der alle
	      englischen Dokumentations-Ports installiert.</para>
	  </listitem>

	  <listitem>
	    <para>Der <quote>Alles-in-Einem-Port</quote>,
	      <package>misc/freebsd-doc-all</package>, welcher die
	      komplette Dokumentation in allen verfügbaren Sprachen
	      erstellt und installiert.</para>
	  </listitem>

	  <listitem>
	    <para>Es gibt noch einen <quote>Slave-Port</quote> für
	      jede Übersetzung, beispielsweise
	      <package>misc/freebsd-doc-hu</package> für Dokumentation
	      in ungarischer Sprache.</para>
	  </listitem>
	</itemizedlist>

	<para>Um die englische Dokumentation zu bauen im getrennten
	  <acronym>HTML</acronym>-Format in
	  <filename>/usr/local/share/doc/freebsd</filename> zu
	  installieren, installieren Sie den folgenden Port:</para>

	<screen>&prompt.root; <userinput>cd /usr/ports/misc/freebsd-doc-en</userinput>
&prompt.root; <userinput>make install clean</userinput></screen>

	<sect4 xml:id="doc-ports-options">
	  <title>Gebräuchliche Schalter und Optionen</title>

	  <para>Es gibt viele Optionen, die das Standardverhalten der
	    Dokumentations-Ports verändern.  Dazu gehören:</para>

	  <variablelist>
	    <varlistentry>
	      <term><varname>WITH_HTML</varname></term>

	      <listitem>
		<para>Erstellt das HTML-Format mit einer einzigen
		  HTML-Datei pro Dokument.  Die formatierte
		  Dokumentation wird als Datei mit dem Namen
		  <filename>article.html</filename>, oder
		  gegebenenfalls <filename>book.html</filename>,
		  zuzüglich der Bilder gespeichert.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>WITH_PDF</varname></term>

	      <listitem>
		<para>Erstellt das &adobe; Portable Document Format
		  (PDF).  Die formatierte Dokumentation wird als Datei
		  mit dem Namen <filename>article.pdf</filename>, oder
		  gegebenenfalls als <filename>book.pdf</filename>
		  gespeichert.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><varname>DOCBASE</varname></term>

	      <listitem>
		<para>Legt den Pfad fest, wohin die Dokumentation
		  installiert werden soll.  Die Voreinstellung ist
		  <filename>/usr/local/share/doc/freebsd</filename>.</para>

		<note>
		  <para>Der Standardpfad zum Verzeichnis unterscheidet
		    sich von dem Verzeichnis, das von
		    <application>svn</application> verwendet wird.
		    Das liegt daran, dass Ports üblicherweise in
		    <filename>/usr/local</filename> installiert
		    werden.  Dies kann durch die Verwendung von
		    <varname>PREFIX</varname> überschrieben
		    werden.</para>
		</note>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>Dieses Beispiel verwendet Variablen, um die ungarische
	    Dokumentation als PDF zu installieren:</para>

	  <screen>&prompt.root; cd /usr/ports/misc/freebsd-doc-hu
&prompt.root; make -DWITH_PDF DOCBASE=share/doc/freebsd/hu install clean</screen>
	</sect4>
      </sect3>

      <sect3 xml:id="doc-ports-install-package">
	<title>Verwendung von Dokumentations-Paketen</title>

	<para>Das Erstellen der Dokumentations-Ports aus den Quellen, wie im
	  vorherigen Abschnitt beschrieben, benötigt die lokale
	  Installation der Dokumentations-Werkzeugsammlung und ein wenig
	  Festplattenspeicher für das Bauen der Ports.  Sollten die
	  Ressourcen zum Bauen der Dokumentations-Werkzeugsammlung nicht zur
	  Verfügung stehen, oder weil das erstellen zuviel Plattenplatz
	  benötigen würde, ist es trotzdem möglich, bereits
	  zuvor gebaute Schnappschüsse der Dokumentations-Ports zu
	  installieren.</para>

	<para>&a.doceng; erstellt monatliche Schnappschüsse der
	  Dokumentations-Pakete von &os;.  Diese Binärpakete können
	  mit jedem der mitgelieferten Paketwerkzeuge installiert werden,
	  beispielsweise &man.pkg.add.1;, &man.pkg.delete.1; und so
	  weiter.</para>

	<note>
	  <para>Wenn Binärpakete zu Einsatz kommen, wird die
            &os;-Dokumentation in <emphasis>allen</emphasis> verfügbaren
            Formaten in der gegebenen Sprache installiert.</para>
	</note>

	<para>Zum Beispiel installiert das folgende Kommando das aktuelle,
	  vorgefertigte Paket der ungarischen Dokumentation:</para>

	<screen>&prompt.root; <userinput>pkg_add -r hu-freebsd-doc</userinput></screen>

	<note>
	  <para>Pakete verwenden ein Format, welches sich von dem
	    Namen des dazugehörigen Ports unterscheidet:
	    <literal><replaceable>lang</replaceable>-freebsd-doc</literal>.
	    <replaceable>lang</replaceable> entspricht hier der
	    Kurzform des Sprachcodes, z.B. <literal>hu</literal> für
	    Ungarisch, oder <literal>zh_cn</literal> für vereinfachtes
	    Chinesisch.</para>
	</note>
      </sect3>

      <sect3 xml:id="doc-ports-update">
	<title>Dokumentations-Ports aktualisieren</title>

	<para>Dokumentations-Ports können wie jeder andere Port
	  aktualisiert werden.  Beispielsweise aktualisiert das
	  folgende Kommando die installierte ungarische Dokumentation
	  mittels <package>ports-mgmt/portmaster</package> unter
	  Verwendung von Paketen:</para>

	<screen>&prompt.root; <userinput>portmaster -PP hu-freebsd-doc</userinput></screen>
      </sect3>
    </sect2>

<!-- FIXME: Waiting for a working docsnap server...

    <sect2 id="docsnap">
      <sect2info>
	<authorgroup>
	  <author>
	    <firstname>Pav</firstname>
	    <surname>Lucistnik</surname>
	    <contrib>Based on information provided by </contrib>
	  </author>
	</authorgroup>
      </sect2info>

      <title>Using Docsnap</title>

      <indexterm><primary>Updating and Upgrading</primary></indexterm>

      <indexterm>
	<primary>Docsnap</primary>
	<see>Updating and Upgrading</see>
      </indexterm>

      <para><application>Docsnap</application> is an &man.rsync.1;
	repository for updating installed &os; Documentation in a
	relatively easy and fast way.  A
	<quote><application>Docsnap</application> server</quote> tracks
	the documentation sources, and builds them in HTML format every
	hour.  The <filename role="package">textproc/docproj</filename>
	is unneeded with <application>Docsnap</application> as only
	patches to the built documentation exist.</para>

      <para>The only requirement for using this technique is
	the <filename role="package">net/rsync</filename> port or
	package.  To add it, use the following command:</para>

      <screen>&prompt.root; <userinput>pkg_add -r rsync</userinput></screen>

      <note>
	<para><application>Docsnap</application> has been originally
	  developed for updating documentation installed
	  to <filename class="directory">/usr/share/doc</filename>, but
	  the following examples could be adapted for other directories
	  as well.  For user directories, it does not require
	  <username>root</username> privileges.</para>
      </note>

      <para>To update the documentation set, issue the following
	command:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <note>
	<para>There is only one <application>Docsnap</application>
	  server at the moment;
	  the <hostid>docsnap.sk.FreeBSD.org</hostid> shown
	  above.</para>
      </note>

      <para>Do not use the <option>&dash;&dash;delete</option> flag here as there
	are some items installed
	into <filename class="directory">/usr/share/doc</filename>
	during <command>make installworld</command>, which would
	accidentally be removed.  To clean up, use this command
	instead:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz &dash;&dash;delete <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/??_??\.\* <replaceable>/usr/share/doc</replaceable></userinput></screen>

      <para>If a subset of documentation needs to be updated, for
	example, the English documentation only, the following command
	should be used:</para>

      <screen>&prompt.root; <userinput>rsync -rltvz <replaceable>docsnap.sk.FreeBSD.org</replaceable>::docsnap/en_US.ISO8859-1 <replaceable>/usr/share/doc</replaceable></userinput></screen>
    </sect2>
-->
  </sect1>

  <sect1 xml:id="current-stable">
    <title>Einem Entwicklungszweig folgen</title>
    <indexterm><primary>-CURRENT</primary></indexterm>
    <indexterm><primary>-STABLE</primary></indexterm>

    <para>&os; besitzt zwei Entwicklungszweige: &os.current; und
      &os.stable;.  Dieser Abschnitt beschreibt beide Zweige und
      erläutert, wie Sie ein System auf dem aktuellen Stand eines
      Zweiges halten.  Zuerst wird &os.current; vorgestellt, dann
      &os.stable;.</para>

    <sect2 xml:id="current">
      <title>&os.current;</title>

      <para>&os.current; ist die Spitze der Entwicklung von &os;.
	Benutzer von &os.current; sollten über sehr gute technische
	Fähigkeiten verfügen und in der Lage sein, schwierige Probleme
	alleine zu lösen.  Wenn &os; neu für Sie ist, verwenden Sie
	besser &os.stable;.</para>

      <sect3>
	<title>Was ist &os.current;?</title>
	<indexterm><primary>Snapshot</primary></indexterm>

	<para>&os.current; besteht aus den neuesten Quellen des
	  &os;-Systems.  Es enthält Sachen, an denen gerade
	  gearbeitet wird, experimentelle Änderungen und
	  Übergangsmechanismen, die im nächsten offiziellen
	  Release der Software enthalten sein können oder nicht.
	  Obwohl &os.current; täglich von vielen Entwicklern gebaut
	  wird, gibt es Zeiträume, in denen sich das System nicht
	  bauen lässt.  Diese Probleme werden so schnell wie
	  möglich behoben, aber ob Sie mit &os.current;
	  Schiffbruch erleiden oder die gewünschten Verbesserungen
	  erhalten, kann von dem Zeitpunkt abhängen, an dem
	  der Quelltext synchronisiert wurde.</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.current;?</title>

	<para>&os.current; wird hauptsächlich für drei
	  Interessengruppen zur Verfügung gestellt:</para>

	<orderedlist>
	  <listitem>
	    <para>Entwickler, die an einem Teil des Quellbaums arbeiten und
	      daher über die aktuellen Quellen verfügen
	      müssen.</para>
	  </listitem>

	  <listitem>
	    <para>Tester, die bereit sind, Zeit in das Lösen von
	      Problemen zu investieren und sicherstellen, dass
	      &os.current; so stabil wie möglich bleibt.  Diese Tester
	      machen Vorschläge zu Änderungen oder der
	      generellen Entwicklung von &os;  und stellen Patches
	      bereit, um diese Vorschläge zu realisieren.</para>
	  </listitem>

	  <listitem>
	    <para>Für Leute, die die Entwicklung im Auge behalten
	      wollen, oder die Quellen zu Referenzzwecken benutzen
	      wollen.  Auch diese Gruppe macht Vorschläge oder steuert
	      Quellcode bei.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Was &os.current; <emphasis>nicht</emphasis> ist!</title>

	<orderedlist>
	  <listitem>
	    <para>Der schnellste Weg, neue Funktionen vor dem
	      offiziellen Release auszuprobieren.  Bedenken Sie, dass
	      neue Funktionen noch nicht im vollen Umfang getestet
	      wurden und daher höchstwahrscheinlich Fehler
	      enthalten.</para>
	  </listitem>

	  <listitem>
	    <para>Ein schneller Weg, um an Fehlerbehebungen (engl.
	      <foreignphrase>bug fixes</foreignphrase>) zu kommen.
	      Jede Fehlerbehebung führt mit gleicher
	      Wahrscheinlichkeit neue Fehler ein, mit der sie alte
	      behebt.</para>
	  </listitem>

	  <listitem>
	    <para>In keiner Weise
	      <quote>offiziell unterstützt</quote>.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3>
	<title>Benutzen von &os.current;</title>

	<orderedlist>
	  <listitem>
	    <para>Lesen Sie die Mailinglisten &a.current.name; und
	      &a.svn-src-head.name;.  Dies ist
	      <emphasis>notwendig</emphasis>, um die Kommentare
	      über den akutellen Status des Systems und wichtige
	      Mitteilungen zum aktuellen Zustand von &os.current; zu
	      erfahren.</para>

	    <para>Die &a.svn-src-head.name; Mailingliste erfasst die
	      Commit-Logs für jede Änderung und enthält alle
	      relevanten Informationen zu möglichen
	      Seiteneffekten.</para>

	    <para>Um diese Listen zu abonnieren, besuchen Sie
	      &a.mailman.lists.link;, klicken Sie auf die gewünschte
	      Liste und folgen Sie den Anweisungen.  Wenn Sie die
	      Änderungen am gesamten Quellbaum verfolgen möchten,
	      abonnieren Sie die &a.svn-src-all.name; Liste.</para>
	  </listitem>

	  <listitem>
	    <para>Beschaffen Sie sich die Quellen von einem
	      <link linkend="mirrors">&os;-Spiegel</link>,  mit einer
	      der folgenden Methoden:</para>

	    <orderedlist>
	      <listitem>
		<para>Benutzen Sie <link linkend="svn">svn</link>, um
		den gewünschten Entwicklungs- oder Release-Zweig
		auszuchecken.  Dies ist die empfohlene Methode für den
		Zugang zur Entwicklung von &os;.  Checken Sie den
		-CURRENT Quelltext aus dem
		<literal>head</literal>-Zweig von einem der
		<link linkend="svn-mirrors">Subversion Mirror
		  Sites</link> aus.  Aufgrund der Größe des
		Repositories ist es empfehlenswert, nur die
		gewünschten Teilbäume auszuchecken.</para>
	      </listitem>

	      <listitem>
		<para>Benutzen Sie <application>CTM</application>,
		  wenn Sie über eine schlechte Internet-Anbindung
		  verfügen.  <application>CTM</application> ist eine
		  Option, aber es ist nicht so zuverlässig wie
		  <link linkend="svn">Subversion</link>.  Aus diesem
		  Grund ist <application>Subversion</application> die
		  empfohlene Methode für jedes System mit
		  Internet-Anbindung.</para>
	      </listitem>
	    </orderedlist>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie die Quellen einsetzen und nicht nur darin
	      lesen wollen, besorgen Sie sich die
	      <emphasis>kompletten</emphasis> Quellen von &os.current;
	      und nicht nur ausgesuchte Teile.  Der Grund hierfür ist,
	      dass die verschiedenen Teile der Quellen voneinander
	      abhängen.  Es ist ziemlich sicher, dass Sie in
	      Schwierigkeiten geraten, wenn Sie versuchen, nur einen
	      Teil der Quellen zu übersetzen.</para>

	    <para>Lesen Sie <filename>/usr/src/Makefile</filename>
	      sehr aufmerksam, bevor Sie
	      <indexterm><primary>-CURRENT</primary><secondary>übersetzen</secondary></indexterm>
	      &os.current; übersetzen.
	      Wenn Sie &os; das erste Mal aktualisieren, sollten Sie
	      sowohl <link linkend="makeworld">einen Kernel als auch
		das System neu installieren</link>.  Lesen Sie die
	      Mailingliste &a.current; und
	      <filename>/usr/src/UPDATING</filename>, um über
	      Änderungen im Installationsverfahren, die manchmal vor
	      der Einführung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>

	  <listitem>
	    <para>Seien Sie aktiv!  Benutzer von &os.current; werden
	      aufgefordert ihre Verbesserungsvorschläge oder
	      Fehlerbehebungen einzureichen.  Verbesserungsvorschläge,
	      die Code enthalten, werden übrigens begeistert
	      entgegengenommen!</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 xml:id="stable">
      <title>&os.stable;</title>

      <sect3>
	<title>Was ist &os.stable;?</title>

	<indexterm><primary>-STABLE</primary></indexterm>

	<para>&os.stable; ist der Entwicklungszweig, auf dem Releases
	  erstellt werden.  Dieser Zweig ändert sich langsamer als
	  &os.current; und alle Änderungen hier sollten zuvor in
	  &os.current; ausgetestet sein.  Beachten Sie, dass dies
	  <emphasis>immer noch</emphasis> ein Entwicklungszweig ist und
	  daher zu jedem Zeitpunkt die Quellen von &os.stable; verwendbar
	  sein können oder nicht.  &os.stable; ist Teil des
	  Entwicklungsprozesses und nicht für Endanwender
	  gedacht.</para>
      </sect3>

      <sect3>
	<title>Wer braucht &os.stable;?</title>

	<para>Wer daran interessiert ist den &os;-Entwicklungsprozess
	  zu verfolgen oder dazu beizutragen, insbesondere im Hinblick
	  auf das nächste Hauptversion, der sollte es in Erwägung
	  ziehen, &os.stable; zu benutzen.</para>

	<para>Auch wenn sicherheitsrelevante Fehlerbehebungen in den
	  &os.stable; Zweig einfließen, müssen Sie deswegen
	  noch lange nicht &os.stable; verfolgen.  Jeder &os;
	  Sicherheitshinweis beschreibt für jedes betroffene Release,
	  wie der sicherheitsrelevante Fehler behoben wird.

	  <footnote><para>Eine vollständige Beschreibung der
	    Sicherheitspolitik für alte &os; Releases entnehmen Sie
	    <link
	      xlink:href="&url.base;/security/">http://www.FreeBSD.org/security/</link>.</para>
	  </footnote></para>
	
	<para>Obwohl wir versuchen sicherzustellen, dass der
	  &os.stable; Zweig sich jederzeit übersetzen lässt und
	  lauffähig ist, können wir dafür keine Garantie übernehmen.
	  Auch wenn Neuentwicklungen in &os.current; stattfinden, ist
	  es jedoch so, dass mehr Leute &os.stable; anstelle von
	  &os.current; benutzen und es daher unvermeidlich ist, dass
	  Fehler und Grenzfälle erst in &os.stable; auffallen.</para>

	<para>Aus diesen Gründen empfehlen wir Ihnen
	  <emphasis>nicht</emphasis> blindlings &os.stable; zu
	  benutzen.  Es ist besonders wichtig, dass &os.stable; zuerst
	  sorgfältig in einer Testumgebung getestet wird, bevor die
	  Produktion auf &os.stable; migriert.</para>

	<para>Benutzer, die keine Ressourcen haben, um diese Tests
	  durchzuführen wird empfohlen, das aktuelle &os;-Release zu
	  verwenden und den binären Update-Mechanismus zu nutzen, um
	  auf neue Releases zu migrieren.</para>
      </sect3>

      <sect3>
	<title>Benutzen von &os.stable;</title>

	<indexterm>
	  <primary>-STABLE</primary>
	  <secondary>benutzen</secondary>
	</indexterm>

	<orderedlist>
	  <listitem>
	    <para>Lesen Sie Mailingliste &a.stable.name;, damit Sie über
	      Abhängigkeiten beim Bau von &os.stable; und Sachen, die
	      besondere Aufmerksamkeit erfordern, informiert sind.
	      Umstrittene Fehlerbehebungen oder Änderungen werden von
	      den Entwicklern auf dieser Liste bekannt gegeben.  Dies
	      erlaubt es den Benutzern, Einwände gegen die
	      vorgeschlagenen Änderungen vorzubringen.</para>

	    <para>Abonnieren Sie die passende
	      <application>SVN</application>-Liste für den jeweiligen
	      Branch, den Sie verfolgen.  Wenn Sie beispielsweise den Zweig
	      9-STABLE verfolgen, lesen Sie die &a.svn-src-stable-9.name;.
	      Diese Liste enthält zu jeder Änderung das Commit-Log,
	      das Informationen zu möglichen Seiteneffekten
	      enthält.</para>

	    <para>Um diese Listen zu abonnieren, besuchen Sie die
	      Seite &a.mailman.lists.link;.  Klicken Sie auf die
	      gewünschte Liste und folgenden Sie den Anweisungen.
	      Wenn Sie daran interessiert sind, Änderungen am gesamten
	      Quellbaum zu verfolgen, abonnieren Sie
	      &a.svn-src-all.name;.</para>
	  </listitem>

	  <listitem>
	    <para>Wenn Sie ein neues System installieren und dazu einen
	      der monatlich aus &os.stable; erzeugten Snapshots verwenden
	      wollen, sollten Sie zuerst die <link xlink:href="&url.base;/../snapshots/">Snapshot Website</link> auf
	      aktuelle Informationen überprüfen.  Alternativ
	      können Sie auch das neueste &os.stable;-Release von
	      den <link linkend="mirrors">Spiegeln</link> beziehen
	      und das System nach den folgenden Anweisungen
	      aktualisieren.</para>

	    <para>Es stehen mehrere Methoden zur Verfügung, um ein
	      System mit einem älteren Release von einem der
	      <link linkend="mirrors">&os;-Spiegel</link> zu
	      aktualisieren.</para>

	    <orderedlist>
	      <listitem>
		<para>Benutzen Sie <link linkend="svn">svn</link>, um
		  den gewünschten Entwicklungs- oder Release-Zweig
		  auszuchecken.  Dies ist die empfohlene Methode für
		  den Zugang zur Entwicklung von &os;.  Die Zweige
		  umfassen <literal>head</literal>, für den aktuellen
		  Entwicklungszweig, sowie weitere Zweige die auf der
		  <link xlink:href="&url.base;/releng/">Release Engineering Seite</link>
		  beschrieben sind, wie beispielsweise
		  <literal>stable/9</literal> oder
		  <literal>releng/9.0</literal>.  Das bevorzugte
		  URL-Präfix für <application>Subversion</application>
		  zum Auschecken des Basissystems ist
		  <literal>http://svn.freebsd.org/base/</literal>.
		  Aufgrund der Größe des Repositories ist es
		  empfehlenswert, nur die gewünschten Teilbäume
		  auszuchecken.</para>
	      </listitem>

	      <listitem>
		<indexterm>
		  <primary>-STABLE</primary>
		  <secondary>mit CTM synchronisieren</secondary>
		</indexterm>

		<para>Wenn Sie über keine schnelle Internet-Anbindung
		  verfügen, sollten Sie die Nutzung von
		  <application>CTM</application> in Betracht
		  ziehen.</para>
	      </listitem>
	   </orderedlist>
	 </listitem>

	  <listitem>
	    <para>Benutzen Sie <application>Subversion</application>,
	      wenn Sie schnellen Zugriff auf die Quellen brauchen und
	      die Bandbreite keine Rolle spielt, andernfalls benutzen
	      Sie <application>CTM</application>.</para>
	  </listitem>

	  <listitem>
	    <para>Lesen Sie <filename>/usr/src/Makefile</filename>
	      sehr aufmerksam, bevor Sie &os.stable; übersetzen.  Wenn
	      Sie &os; das erste Mal aktualisieren, sollten Sie sowohl
	      <link linkend="makeworld">einen Kernel als auch das
		System neu installieren</link>.
	      Lesen Sie die Mailingliste &a.stable; und
	      <filename>/usr/src/UPDATING</filename>, um über
	      Änderungen im Installationsverfahren, die manchmal vor
	      der Einführung eines neuen Releases notwendig sind,
	      informiert zu sein.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>
  </sect1>

  <sect1 xml:id="synching">
    <title>Synchronisation der Quellen</title>

    <para>Sie können eine Internet-Verbindung (oder E-Mail) dazu
      nutzen, Teile von &os;, wie die Quellen zu einzelnen Projekten, oder
      das Gesamtsystem, aktuell zu halten.  Die primären Dienste dafür
      sind <link linkend="svn">Subversion</link> und
      <link linkend="ctm">CTM</link>.</para>

    <warning>
      <para>Obwohl es möglich ist, nur Teile des Quellbaums zu
        aktualisieren, ist die einzige unterstütze Migrationsprozedur,
	den kompletten Quellbaum zu aktualisieren und alles neu zu
	übersetzen.  Dazu zählen alle Userland-Programme in
	<filename>/bin</filename> und <filename>/sbin</filename>,
	sowie die Kernelquellen.  Wird hingegen nur ein Teil der
	Quellen, zum Beispiel nur der Kernel oder nur die Programme
	aus dem Userland aktualisiert, treten Probleme auf, die von
	Übersetzungsfehlern über Kernel-Panics bis hin zu
	Beschädigung von Daten reichen können.</para>
    </warning>

    <indexterm>
      <primary>Subversion</primary>
    </indexterm>

    <para><application>Subversion</application> benutzt die
      <foreignphrase>Pull</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to pull</foreignphrase> =
	  <emphasis>ziehen</emphasis>.  Der Client holt sich bei dieser
	  Methode die Dateien ab.</para>
      </footnote>, um die Quellen zu aktualisieren.  Der Benutzer,
      oder ein <command>cron</command>-Skript, ruft das Programm
      <command>svn</command> auf, das die Quellen aktualisiert.
      <application>Subversion</application> ist die empfohlene
      Methode, um die lokalen Quellen zu aktualisieren.  Mit beiden
      Methoden erhalten Sie aktuelle Updates zu einem genau von Ihnen
      bestimmten Zeitpunkt.  Es ist einfach, die Prozedur auf
      bestimmte Dateien oder Verzeichnisse einschränken.  Die Updates
      werden zur Laufzeit generiert.</para>

    <indexterm>
      <primary><application>CTM</application></primary>
    </indexterm>
    <para><application>CTM</application> vergleicht die Quellen nicht
      mit denen auf einem Server.  Stattdessen läuft auf
      dem Server ein Skript, das Änderungen an Dateien gegenüber
      seinem vorigen Lauf bemerkt, die Änderungen komprimiert, mit
      einer Sequenznummer versieht und für das Verschicken per E-Mail
      kodiert.  Dabei werden nur druckbare ASCII-Zeichen verwendet.
      Wenn Sie diese <quote>CTM-Deltas</quote> erhalten haben, können
      Sie sie mit &man.ctm.rmail.1; benutzen, welches die Deltas
      dekodiert, verifiziert und dann die Änderungen an den Quellen
      vornimmt.  Dieses Verfahren ist viel effizienter als
      <application>Subversion</application> und erzeugt auch weniger
      Last auf den Servern, da es die
      <foreignphrase>Push</foreignphrase>-Methode
      <footnote>
	<para>Von engl. <foreignphrase>to push</foreignphrase> =
	  <emphasis>schieben</emphasis>.  Der Server schickt dem
	  Client die Dateien.</para>
      </footnote> verwendet.</para>

    <para>Es gibt noch weitere Unterschiede.  Wenn ein Benutzer
      unabsichtlich Teile des Archivs löschen, wird das von
      <application>Subversion</application> erkannt und repariert.
      <application>CTM</application> leistet das nicht.  Wenn ein
      Benutzer Teile des Quellbaums gelöscht hat und keine Sicherung
      besitzt, muss er von neuem, das heißt vom letzten
      <quote>Basis-Delta</quote>, starten und die Änderungen wieder
      mit <application>CTM</application> nachziehen.</para>
  </sect1>

  <sect1 xml:id="makeworld">
    <title>Das komplette Basissystem neu bauen</title>

    <indexterm>
      <primary>Bau des Basissystems</primary>
    </indexterm>

    <para>Sobald der lokalen Quellbaum mit einer bestimmten &os;
      Version, z.B. &os.stable; oder &os.current; synchronisiert
      wurde, kann dieser dazu benutzt werden das System neu zu
      bauen.</para>

    <warning>
      <title>Erstellen Sie eine Sicherungskopie!</title>

      <para>Es kann nicht oft genug betont werden, wie wichtig es ist,
	das System zu sichern, <emphasis>bevor</emphasis> die
	nachfolgenden Schritte ausgeführt werden.  Obwohl der Neubau
	des Systems eine einfache Aufgabe ist, kann dennoch vorkommen,
	dass Fehler im Quellbaum dazu führen, dass das System nicht
	mehr bootet.</para>

      <para>Stellen Sie sicher, dass Sie eine Sicherung erstellt haben
        und über ein startfähiges Installationsmedium verfügen.
	Wahrscheinlich werden die Medien nicht benötigt, aber
	gehen Sie auf Nummer sicher!</para>
    </warning>

    <warning>
      <title>Abonnieren Sie die richtige Mailingliste</title>

      <indexterm><primary>Mailingliste</primary></indexterm>
      <para>Die &os.stable; und &os.current; Zweige befinden sich in
        <emphasis>ständiger Entwicklung</emphasis>.  Die Leute, die zu
	&os; beitragen, sind Menschen und ab und zu machen sie
	Fehler.</para>

      <para>Manchmal sind diese Fehler harmlos und lassen das System
	eine Warnung ausgeben.  Die Fehler können allerdings auch
	katastrophal sein und dazu führen, dass das System nicht mehr
	booten kann, oder Dateisysteme beschädigt werden.</para>

      <para>Wenn Probleme auftauchen, wird ein <quote>heads up</quote>
	an die passende Mailingliste geschickt, welches das Problem
	erklärt und die betroffenen Systeme benennt.  Eine
	<quote>all clear</quote> Meldung wird versendet, wenn das
	Problem gelöst ist.</para>

      <para>Benutzer, die &os.stable; oder &os.current; benutzen und
	nicht die Mailinglisten &a.stable; beziehungsweise &a.current;
	lesen, bringen sich nur unnötig in Schwierigkeiten.</para>
    </warning>

    <warning>
      <title>Verwenden Sie nicht <command>make world</command></title>

      <para>Einige ältere Dokumentationen empfehlen
	<command>make world</command> für den Neubau.
	Das Kommando überspringt jedoch wichtige Schritte und sollte
	nur von Experten verwendet werden.  In fast allen Fällen ist
	<command>make world</command> falsch.  Benutzen Sie
	stattdessen die nachstehende Anleitung.</para>
    </warning>

    <sect2 xml:id="canonical-build">
      <title>Richtig aktualisieren</title>

      <para>Bevor das System aktualisiert wird, lesen Sie
	<filename>/usr/src/UPDATING</filename>, um die für
	die Quellcodeversion nötigen Aufgaben zu erledigen, bevor
	das System neu gebaut wird.  Danach kann das System mit den
	folgenden Schritten aktualisiert werden.</para>

      <para>Bei den hier dargestellten Aktualisierungsschritten wird
	davon ausgegangen, dass momentan eine alte &os;-Version
	verwendet wird, die aus einem alten Compiler, Kernel, sowie
	einem alten Basissystem und veralteten Konfigurationsdateien
	besteht.  Mit <quote>Basissystem</quote> sind hier die
	zentralen Binärdateien, Bibliotheken und Entwicklerdateien
	gemeint.  Der Compiler ist Teil des
	<quote>Basissystems</quote>, beinhaltet aber ein paar
	Besonderheiten.</para>

      <para>Es wird außerdem davon ausgegangen, dass bereits die
	Quellen für ein neues System bezogen wurden.  Falls die
	Quellen nicht auf dem aktuellen Stand sind, lesen Sie
	<xref linkend="synching"/>, um detaillierte Hilfe über die
	Aktualisierung der Quellen zu erhalten.</para>

      <para>Die Aktualisierung des Systems aus den Quellen ist ein
	wenig ausgetüftelter als es zunächst den Anschein hat. Die
        Entwickler von &os; haben es über die Jahre für Nötig
        befunden, den vorgeschlagenen Ablauf ziemlich stark zu
        verändern, da neue Arten von unvermeidlichen Abhängigkeiten
        mit der Zeit ans Licht kamen.  Der übrige Teil dieses
	Abschnitts beschreibt die Überlegungen hinter der aktuell
	empfohlenen Aktualisierungsreihenfolge.</para>

      <para>Jede erfolgreiche Aktualisierung muss sich mit den folgenden
        Sachverhalten auseinandersetzen:</para>

      <itemizedlist>
        <listitem>
          <para>Der alte Compiler ist aufgrund von Fehlern
	    möglicherweise nicht in der Lage, den neuen Kernel zu
	    übersetzen.  Deshalb sollte der neue Kernel mit dem neuen
	    Compiler übersetzt werden, was bedeutet, dass der neue
	    Compiler vor dem neuen Kernel gebaut werden muss.  Das
	    bedeutet nicht unbedingt, dass der neue Compiler auch
	    <emphasis>installiert</emphasis> werden muss, bevor
	    der neue Kernel gebaut wird.</para>
        </listitem>

        <listitem>
          <para>Das neue Basissystem benötigt eventuell neue
            Eigenschaften des Kernels. Also muss der neue Kernel installiert
            sein, bevor das neue Basissystem installiert wird.</para>
        </listitem>
      </itemizedlist>

      <para>Diese ersten beiden Sachverhalte sind die Grundlage für die
        zentrale Sequenz von <buildtarget>buildworld</buildtarget>,
        <buildtarget>buildkernel</buildtarget>,
        <buildtarget>installkernel</buildtarget> und
        <buildtarget>installworld</buildtarget>, die in den folgenden
        Abschnitten beschrieben wird.  Weitere Gründe für diese
	Vorgehensweise sind hier aufgeführt:</para>

     <itemizedlist>
       <listitem>
         <para>Das alte Basissystem wird möglicherweise nicht korrekt
           mit dem neuen Kernel funktionieren, weshalb das neue
           Basissystem sofort nach der Installation des neuen Kernels
           installiert werden muss.</para>
       </listitem>

       <listitem>
  	 <para>Manche Änderungen an der Konfiguration müssen
  	   erledigt worden sein, bevor das neue Basissystem installiert wird,
  	   jedoch können andere die Funktionalität des alten
  	   Basissystems beeinträchtigen.  Aus diesem Grund sind zwei
  	   verschiedene Schritte notwendig, um eine Aktualisierung der
  	   Konfiguration durchzuführen.</para>
       </listitem>

       <listitem>
         <para>Der Aktualisierungsprozess ersetzt zum Grossteil Dateien oder
           fügt neue hinzu, bestehende Dateien werden nicht
           gelöscht.  In wenigen Ausnahmefällen kann dies Probleme
           verursachen.  Aus diesem Grund wird der Aktualisierungsprozess
           manchmal bestimmte Dateien zum manuellen Löschen vorschlagen.
           Dies wird eventuell in der Zukunft automatisch
           durchgeführt.</para>
       </listitem>
     </itemizedlist>

     <para>Diese Bedenken haben zu der folgenden Reihenfolge geführt.
       Beachten Sie, dass der genaue Ablauf für bestimmte
       Aktualisierungen zusätzliche Schritte nach sich zieht, jedoch
       sollte der Kernprozess davon nicht beeinträchtigt werden:</para>

     <orderedlist>
       <listitem>
         <para><command>make
           buildworld</command></para>

         <para>Dieser Schritt übersetzt zuerst den neuen Compiler und
           ein paar damit zusammenhängende Werkzeuge und verwendet dann
           den neuen Compiler, um den Rest des Basissystems zu erstellen.
           Das Ergebnis landet dann in <filename>/usr/obj</filename>.</para>
       </listitem>

       <listitem>
         <para><command>make
           buildkernel</command></para>

         <para>Dieser Ansatz nutzt den <emphasis>neuen</emphasis>
	   Compiler, der in <filename>/usr/obj</filename> abgelegt
	   ist, um vor falschen Compiler-Kernel-Kombinationen zu
	   schützen.</para>
       </listitem>

       <listitem>
         <para><command>make
           installkernel</command></para>

         <para>Platziert den neuen Kernel und Kernelmodule auf der Platte,
           was es erlaubt, mit dem frisch aktualisierten Kernel zu
           starten.</para>
       </listitem>

       <listitem>
         <para>Starten Sie das System neu in den Single-User-Modus.</para>

         <para>Der Single-User-Modus minimiert Probleme mit der
           Aktualisierung von Programmen, die bereits gestartet sind.  Ebenso
           minimiert es Probleme, die mit der Verwendung des alten
           Basissystems und des neuen Kernels zu tun haben
           könnten.</para>
       </listitem>

       <listitem>
         <para><command>mergemaster -p</command></para>

         <para>Dieser Schritt aktualisiert ein paar initiale
           Konfigurationsdateien als Vorbereitung für das neue
           Basissystem.  Beispielsweise fügt es neue Benutzergruppen
           zum System oder neue Benutzernamen in die Passwortdatenbank hinzu.
           Dies wird oftmals benötigt, wenn neue Gruppen oder bestimmte
           Systembenutzerkonten seit der letzten Aktualisierung hinzu gekommen
           sind, so dass der <buildtarget>installworld</buildtarget>-Schritt
           in der Lage ist, auf dem neu installierten System die Benutzer
           oder Systemgruppennamen ohne Probleme zu verwenden.</para>
       </listitem>

       <listitem>
         <para><command>make
           installworld</command></para>

         <para>Kopiert das Basissystem aus
	   <filename>/usr/obj</filename>.  Der neue Kernel und das
	   neue Basissystem sind jetzt auf der Platte
	   installiert.</para>
       </listitem>

       <listitem>
         <para><command>mergemaster</command></para>

         <para>Aktualisiert die verbleibenden Konfigurationsdateien,
	   da nun das neue Basissystem auf der Platte ist.</para>
       </listitem>

       <listitem>
         <para>Starten Sie das System neu.</para>

         <para>Ein kompletter Systemneustart ist notwendig, um den neuen
           Kernel und das neue Basissystem mit den neuen
           Konfigurationsdateien zu laden.</para>
       </listitem>
      </orderedlist>

      <para>Beachten Sie, dass wenn Sie von einem Release des gleichen
        &os;-Zweigs auf ein aktuelleres Release des gleichen Zweigs, z.B.
        von 9.0 auf 9.1, aktualisieren, dann ist diese Vorgehensweise nicht
        unbedingt notwendig, da Sie nur sehr unwahrscheinlich in
        ungünstige Kombinationen zwischen Compiler, Kernel, Basissystem
        und den Konfigurationsdateien geraten werden.  Die ältere
        Vorgehensweise von <command>make
        world</command>, gefolgt von der Erstellung
        und Installation des neuen Kernels funktioniert möglicherweise
        gut genug, um kleinere Aktualisierungen vorzunehmen.</para>

      <para>Wenn Sie allerdings zwischen Hauptversionen aktualisieren wollen
        und befolgen diese Schritte nicht, sollten Sie sich auf Probleme
        gefasst machen.</para>

      <para>Es ist auch wichtig zu wissen, dass viele Aktualisierungen
	spezielle und zusätzliche Schritte benötigen, wie
	beispielsweise das umbenennen oder löschen von bestimmten
	Dateien vor installworld.  Lesen Sie
	<filename>/usr/src/UPDATING</filename> gründlich, besonders am
	Ende, wo die aktuell vorgeschlagene Aktualisierungssequenz
	explizit aufgelistet ist.</para>

      <para>Diese Prozedur hat sich mit der Zeit weiterentwickelt, da die
        Entwickler es für unmöglich erachtet haben, bestimmte
        Arten von Kombinationsproblemen vollständig auszuschliessen.
        Hoffentlich wird die aktuelle Aktualisierungsprozedur für lange
        Zeit stabil bleiben.</para>

      <para>Als Zusammenfassung ist hier nochmal die aktuell vorgeschlagene
        Vorgehensweise für die Aktualisierung von &os; aus den Quellen
        aufgelistet:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildworld</userinput>
&prompt.root; <userinput>make buildkernel</userinput>
&prompt.root; <userinput>make installkernel</userinput>
&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <note>
	<para>Es gibt einige, sehr seltene Situationen, in denen Sie
	  <command>mergemaster -p</command> zusätzlich
	  ausführen müssen, bevor Sie das System mit
	  <buildtarget>buildworld</buildtarget> bauen.  Diese Situationen
	  werden in <filename>UPDATING</filename> beschrieben.  Solche
	  Situationen treten aber in der Regel nur dann auf, wenn das
	  &os;-System um eine oder mehrere Hauptversionen aktualisiert
	  wird.</para>
      </note>

      <para>Nachdem <buildtarget>installkernel</buildtarget> erfolgreich
	abgeschlossen wurde, starten Sie das System durch die Eingabe
	von <command>boot -s</command> am Loaderprompt im
	Single-User-Modus.  Danach führen Sie die folgenden Kommandos
	aus:</para>

      <screen>&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>adjkerntz -i</userinput>
&prompt.root; <userinput>mergemaster -p</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput>
&prompt.root; <userinput>mergemaster</userinput>
&prompt.root; <userinput>reboot</userinput></screen>

      <warning>
	<title>Lesen Sie bitte weiter</title>

	<para>Die folgenden Abschnitte beschreiben detailliert
	  die einzelnen Schritte, insbesondere wenn eine angepasste
	  Kernelkonfiguration verwendet wird.</para>
      </warning>
    </sect2>

    <sect2 xml:id="src-updating">
      <title>Lesen Sie <filename>/usr/src/UPDATING</filename></title>

      <para>Lesen Sie vor der Aktualisierung
        <filename>/usr/src/UPDATING</filename>.  Die Datei enthält
	wichtige Informationen zu potentiellen Problemen, und gibt die
	Reihenfolge vor, in der bestimmte Kommandos gestartet werden
	müssen.  Die Anweisungen in <filename>UPDATING</filename> sind
	aktueller als die in diesem Handbuch.  Im Zweifelsfall folgen
	Sie bitte den Anweisungen aus
	<filename>UPDATING</filename>.</para>

      <important>
	<para>Das Lesen von <filename>UPDATING</filename> ersetzt nicht das
	  Abonnieren der richtigen Mailingliste.  Die beiden Voraussetzungen
	  ergänzen sich, es reicht nicht aus, nur eine zu
	  erfüllen.</para>
      </important>
    </sect2>

    <sect2 xml:id="make-conf">
      <title>Überprüfen Sie
	<filename>/etc/make.conf</filename></title>
      <indexterm>
        <primary><filename>make.conf</filename></primary>
      </indexterm>

      <para>Die verfügbaren &man.make.1;-Optionen werden in
	&man.make.conf.5; und
	<filename>/usr/share/examples/etc/make.conf</filename>
	dargestellt.  Diese Einstellungen können in
	<filename>/etc/make.conf</filename> hinzugefügt werden, um das
	Verhalten von &man.make.1; beim Übersetzen von Programmen zu
	beeinflussen.  Änderungen an einigen Einstellungen können
	weitreichende und unerwartete Auswirkungen nach sich ziehen.
	Lesen Sie die Kommentare in diesen beiden Ressourcen und
	beachten Sie, dass die Standardwerte aus einer Kombination von
	Leistung und Sicherheit gewählt wurden.</para>

      <para>Die in <filename>/etc/make.conf</filename> gesetzten
	Optionen wirken sich bei jedem Aufruf von &man.make.1; aus,
	einschließlich der Übersetzung von Programmen aus der
	Ports-Sammlung, vom Benutzer geschriebene C-Programme oder
	beim Bau des &os;-Betriebssystems.</para>
    </sect2>

    <sect2 xml:id="src-conf">
      <title><filename>/etc/src.conf</filename> überprüfen</title>

      <indexterm>
	<primary><filename>/etc/src.conf</filename></primary>
      </indexterm>

      <para><filename>/etc/src.conf</filename> kontrolliert den Bau
	des Betriebssystems aus dem Quellcode.  Im Gegensatz zu
	<filename>/etc/make.conf</filename> greifen die Optionen in
	<filename>/etc/src.conf</filename> nur dann, wenn das
	&os; Betriebssystem selbst gebaut wird.  Die vielen Optionen
	für diese Datei werden in &man.src.conf.5; beschrieben.
	Seien Sie vorsichtig mit dem Entfernen von scheinbar nicht
	mehr benötigten Kernelmodulen und Optionen.  Manchmal gibt es
	unerwartete oder subtile Wechselwirkungen.</para>
    </sect2>

    <sect2 xml:id="updating-etc">
      <title>Aktualisieren Sie die Dateien in
	<filename>/etc</filename></title>

      <para><filename>/etc</filename> enthält den Großteil der
	Konfigurationsdateien des Systems und Skripten, die beim Start
	des Systems ausgeführt werden.  Einige dieser Skripten ändern
	sich bei einer Migration auf eine neue &os;-Version.</para>

      <para>Einige der Konfigurationsdateien, wie beispielsweise
	<filename>/etc/group</filename>, werden für den Normalbetrieb
	des Systems gebraucht.</para>

      <para>Es gab Fälle, in denen die Installationsroutine von
	<command>make installworld</command> auf bestimmte
	Accounts oder Gruppen angewiesen war.  Bei einer
	Aktualisierung ist es jedoch wahrscheinlich, dass diese
	Accounts oder Gruppen noch nicht existieren.  In einigen
	Fällen prüft <command>make buildworld</command> ob die
	Accounts oder Gruppen vorhanden sind.</para>

      <para>Um dieses Problem zu umgehen, rufen Sie
	&man.mergemaster.8; im prä-buildworld-Modus auf, der mit
	<option>-p</option> aktiviert wird.  In diesem Modus werden
	nur Dateien verglichen, die für den Erfolg von
	<buildtarget>buildworld</buildtarget> oder
	<buildtarget>installworld</buildtarget> essentiell
	sind.</para>

      <tip>
	<para>Um im System nach Dateien zu suchen die der Gruppe
	  gehören, die umbenannt oder gelöscht werden soll:</para>

	<screen>&prompt.root; <userinput>find / -group <replaceable>GID</replaceable> -print</userinput></screen>

	<para>Dieses Kommando zeigt alle Dateien an, die der Gruppe
	  <replaceable>GID</replaceable> gehören.  Dies kann entweder
	  ein Gruppenname oder eine numerische ID sein.</para>
      </tip>
    </sect2>

    <sect2 xml:id="makeworld-singleuser">
      <title>Wechseln Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Sie können das System im Single-User-Modus übersetzen.
	Bei der Installation des Systems werden viele wichtige
	Dateien, wie die Standard-Systemprogramme, die Bibliotheken
	und Include-Dateien, verändert.  Sie bringen sich in
	Schwierigkeiten, wenn Sie diese Dateien auf einem laufenden
	System verändern, besonders dann, wenn zu dieser Zeit Benutzer
	auf dem System aktiv sind.</para>

      <indexterm><primary>Mehrbenutzermodus</primary></indexterm>
      <para>Bei dieser Methode übersetzen Sie das System im
	Mehrbenutzermodus und wechseln anschließend für die
	Installation in den Single-User-Modus.  Wenn Sie diese Methode
	benutzen wollen, warten Sie mit den folgenden Schritten, bis
	der Bau des Systems abgeschlossen ist.  Wechseln Sie dann in
	den Single-User-Modus, um
	<buildtarget>installkernel</buildtarget> oder
	<buildtarget>installworld</buildtarget> auszuführen.</para>

      <para>Mit dem folgenden Kommando kann ein laufendes System in
	den Single-User-Modus gebracht werden:</para>

      <screen>&prompt.root; <userinput>shutdown now</userinput></screen>

      <para>Alternativ können Sie das System mit der Option
        <quote>single user</quote> in den Single-User-Modus booten.
	Geben Sie dann die folgenden Befehle am Single-User-Modus
	Shell-Prompt ein:</para>

      <screen>&prompt.root; <userinput>fsck -p</userinput>
&prompt.root; <userinput>mount -u /</userinput>
&prompt.root; <userinput>mount -a -t ufs</userinput>
&prompt.root; <userinput>swapon -a</userinput></screen>

      <para>Die Kommandos überprüfen die Dateisysteme,
        hängen <filename>/</filename> wieder beschreibbar ein,
	hängen dann alle anderen UFS Dateisysteme aus
	<filename>/etc/fstab</filename> ein und aktivieren den
	Swap-Bereich.</para>

        <note>
	  <para>Zeigt die CMOS-Uhr die lokale Zeit und nicht GMT an
	    (dies erkennen Sie daran, dass &man.date.1; die falsche
	    Zeit und eine falsche Zeitzone anzeigt), setzen Sie das
	    folgende Kommando ab:</para>

	  <screen>&prompt.root; <userinput>adjkerntz -i</userinput></screen>

	  <para>Dies stellt sicher, dass die Zeitzone richtig
	    eingestellt ist.</para>
        </note>
    </sect2>

    <sect2 xml:id="cleaning-usr-obj">
      <title>Entfernen Sie <filename>/usr/obj</filename></title>

      <para>Die neu gebauten Teile des Systems werden in der Voreinstellung
        unter <filename>/usr/obj</filename> gespeichert.  Die Verzeichnisse
	dort spiegeln die Struktur unter
	<filename>/usr/src</filename>.</para>

      <para>Um den <command>make buildworld</command> Prozess zu
	beschleunigen und Ärger aufgrund von Abhängigkeiten zu
	vermeiden, können Sie dieses Verzeichnis entfernen.</para>

      <para>Einige Dateien unter <filename>/usr/obj</filename> haben
	vielleicht die <option>immutable</option>-Option gesetzt, die
	zuvor mit &man.chflags.1; entfernt werden muss:</para>

      <screen>&prompt.root; <userinput>cd /usr/obj</userinput>
&prompt.root; <userinput>chflags -R noschg *</userinput>
&prompt.root; <userinput>rm -rf *</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-upgrading-compilebase">
      <title>Übersetzen der Quellen des Basissystems</title>

      <sect3>
	<title>Sichern der Ausgaben</title>

	<para>Es ist ratsam, die Ausgaben von &man.make.1; in einer
	  Datei zu sichern.  Wenn etwas schief geht, kann eine Kopie
	  der Fehlermeldung zu einer der &os;-Mailinglisten gesendet
	  werden.</para>

	<para>Dazu können Sie einfach das Kommando &man.script.1;
	  benutzen, dem Sie beim Aufruf als Parameter den Dateinamen
	  für die Ausgaben mitgeben.  Setzen Sie das Kommando
	  unmittelbar vor dem Neubau ab und geben Sie
	  <userinput>exit</userinput> ein, wenn der Bau abgeschlossen
	  ist:</para>

	<screen>&prompt.root; <userinput>script /var/tmp/mw.out</userinput>
Script started, output file is /var/tmp/mw.out
&prompt.root; <userinput>make TARGET</userinput>
<emphasis>&hellip; Ausgaben des Kommandos &hellip;</emphasis>
&prompt.root; <userinput>exit</userinput>
Script done, &hellip;</screen>

	<para>Sichern Sie die Ausgaben <emphasis>nicht</emphasis> in
	  <filename>/tmp</filename>, da dieses Verzeichnis beim
	  nächsten Reboot aufgeräumt werden kann.  Ein geeigneteres
	  Verzeichnis ist <filename>/var/tmp</filename>, oder das
	  Heimatverzeichnis von <systemitem
	    class="username">root</systemitem>.</para>
      </sect3>

      <sect3 xml:id="make-buildworld">
	<title>Übersetzen des Basissystems</title>

	<para>Wechseln Sie in das Verzeichnis, in dem die Quellen liegen
	  (in der Voreinstellung ist das
	  <filename>/usr/src</filename>):</para>

	<screen>&prompt.root; <userinput>cd /usr/src</userinput></screen>

	<indexterm><primary><command>make</command></primary></indexterm>

	<para>Benutzen Sie &man.make.1;, um das Basissystem neu zu
	  bauen.  Dieses Kommando liest Anweisungen aus einem
	  <filename>Makefile</filename>, wechles beschreibt, wie die
	  Programme, aus denen &os; besteht, zu bauen sind und in
	  welcher Reihenfolge diese zu bauen sind.</para>

	<para>Ein typischer Aufruf von <command>make</command> sieht wie
	  folgt aus:</para>

	<screen>&prompt.root; <userinput>make -<replaceable>x</replaceable> -D<replaceable>VARIABLE</replaceable> <replaceable>target</replaceable></userinput></screen>

	<para>In diesem Beispiel ist
	  <option>-<replaceable>x</replaceable></option> eine Option,
	  die an &man.make.1; weitergegeben wird.  Eine Liste gültiger
	  Optionen finden Sie in &man.make.1;.</para>

	<para>Das Verhalten eines <filename>Makefile</filename>s wird von
	  Variablen bestimmt.  Mit
	  <option>-D<replaceable>VARIABLE</replaceable></option> setzen Sie
	  eine Variable.  Diese Variablen sind dieselben, die auch in
	  <filename>/etc/make.conf</filename> gesetzt werden, dies ist nur
	  ein alternativer Weg, Variablen zu setzen.</para>

	<para>Um zu verhindern, dass die <quote>profiled</quote>
	  Bibliotheken gebaut werden, rufen Sie <command>make</command> wie
	  folgt auf:</para>
	<screen>&prompt.root; <userinput>make -DNO_PROFILE <replaceable>target</replaceable></userinput></screen>

	<para>Dieser Aufruf entspricht dem folgenden Eintrag in
	  <filename>/etc/make.conf</filename>:</para>

	<programlisting>NO_PROFILE=    true     #    Avoid compiling profiled libraries</programlisting>

	<para>Jedes <filename>Makefile</filename> definiert einige
	  <quote>Ziele</quote>, die festlegen, was genau zu tun ist.  Mit
	  <replaceable>target</replaceable> wählen Sie eins dieser
	  Ziele aus.</para>

	<para>Einige Ziele im <filename>Makefile</filename> werden
	  verwendet, um den Bauprozess in eine Reihe von
	  Einzelschritten zu unterteilen.</para>

	<para>Im Regelfall müssen &man.make.1; keine Parameter
	  mitgegeben werden, so dass die Kommandozeile wie folgt
	  aussehen wird:</para>

	<screen>&prompt.root; <userinput>make <replaceable>target</replaceable></userinput></screen>

	<para><replaceable>target</replaceable> steht dabei für
	  die verschiedenen Ziele.  Das erste Ziel sollte immer
	  <varname>buildworld</varname> sein.</para>

	<para>Mit <buildtarget>buildworld</buildtarget> wird ein
	  kompletter Baum unterhalb von <filename>/usr/obj</filename>
	  gebaut, der mit <buildtarget>installworld</buildtarget> auf
	  dem System installiert werden kann.</para>

	<para>Über separate Optionen zu verfügen, ist aus mehreren
	  Gründen nützlich.  Erstens können Sie das System gefahrlos
	  auf einem laufenden System bauen, da die Bauprozedur vom
	  Rest des Systems isoliert ist.  Das System lässt sich im
	  Mehrbenutzermodus ohne negative Seiteneffekte bauen.  Die
	  Installation mit <buildtarget>installworld</buildtarget>
	  sollte aber immer noch im Single-User-Modus erfolgen.</para>

	<para>Zweitens kann NFS benutzt werden, um mehrere Maschinen
	  in einem Netzwerk zu aktualisieren.  Um die Maschinen
	  <systemitem>A</systemitem>, <systemitem>B</systemitem> und
	  <systemitem>C</systemitem> zu aktualisieren, lassen Sie
	  <command>make buildworld</command> und
	  <command>make installworld</command> auf
	  <systemitem>A</systemitem> laufen.  Auf den Maschinen
	  <systemitem>B</systemitem> und <systemitem>C</systemitem>
	  können Sie die Verzeichnisse <filename>/usr/src</filename>
	  und <filename>/usr/obj</filename> von
	  <systemitem>A</systemitem> einhängen und brauchen dort nur
	  noch <command>make installworld</command> auszuführen, um
	  die Bauresultate zu installieren.</para>

	<para>Obwohl das Ziel <buildtarget>world</buildtarget> noch
	  existiert, sollte es wirklich nicht mehr benutzt
	  werden.</para>

	<para>Benutzen Sie stattdessen:</para>

	<screen>&prompt.root; <userinput>make buildworld</userinput></screen>

	<para>Mit <option>-j</option> können Sie
	  <command>make</command> anweisen, mehrere Prozesse zu
	  starten.  Besonders effektiv ist das auf
	  Mehrprozessor-Systemen.  Da aber der Übersetzungsprozess
	  hauptsächlich von I/O statt der CPU bestimmt wird, ist diese
	  Option auch auf Einprozessor-Systemen nützlich.</para>

	<para>Auf einem typischen Einprozessor-System können Sie den
	  folgenden Befehl eingeben:</para>

	<screen>&prompt.root; <userinput>make -j4 buildworld</userinput></screen>

	<para>&man.make.1; wird dann bis zu vier Prozesse gleichzeitig
	  laufen lassen.  Erfahrungsberichte aus den Mailinglisten zeigen,
	  dass dieser Aufruf typischerweise den besten
	  Geschwindigkeitsgewinn bringt.</para>

	<para>Wenn Sie ein Mehrprozessor-System besitzen und SMP im
	  Kernel konfiguriert ist, probieren Sie Werte zwischen 6 und
	  10 aus.</para>
      </sect3>

      <sect3>
	<title>Laufzeiten</title>
	<indexterm>
	  <primary>Bau des Basissystems</primary>
	  <secondary>Laufzeiten</secondary>
	</indexterm>

	<para>Die Laufzeit eines Baus wird von vielen Faktoren
	  beeinflusst, ein aktuelles System benötigt aber etwa
	  zwei Stunden um &os.stable; zu bauen.  Der Bau von
	  &os.current; dauert etwas länger.</para>
      </sect3>
    </sect2>

    <sect2 xml:id="new-kernel">
      <title>Übersetzen und Installation des Kernels</title>
      <indexterm>
        <primary>Kernel</primary>
	<secondary>Übersetzen</secondary>
      </indexterm>

      <para>Kompilieren Sie einen neuen Kernel, um den vollen Nutzen
	aus dem System zu ziehen.  Praktisch gesehen ist das sogar
	notwendig, da sich einige Datenstrukturen geändert haben und
	Programme wie &man.ps.1; und &man.top.1; nur mit einem Kernel
	zusammen arbeiten, der auch zu dem entsprechenden Quellcode
	passt.</para>

      <para>Am einfachsten und sichersten bauen Sie dazu den
	<filename>GENERIC</filename> Kernel.  Obwohl der
	<filename>GENERIC</filename> Kernel vielleicht nicht alle
	Geräte unterstützt, sollte er alles enthalten, um das System
	in den Single-User-Modus zu booten.  Dies ist auch ein guter
	Test, um zu sehen, dass das System ordnungsgemäß funktioniert.
	Nachdem das System mit <filename>GENERIC</filename> gebootet
	wurde und sichergestellt ist, dass das System funktioniert,
	kann ein neuer Kernel basierend auf einer angepassten
        Konfigurationsdatei erstellt werden.</para>

      <para>In &os; müssen Sie das
	<link linkend="make-buildworld">Basissystem neu bauen</link>,
	bevor Sie einen neuen Kernel erstellen.</para>

      <note>
	<para>Verwenden Sie
	<literal>KERNCONF=<replaceable>MYKERNEL</replaceable></literal>,
	um einen Kernel mit einer vorhandenen, angepassten
	Konfigurationsdatei zu erstellen:</para>

        <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make buildkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput>
&prompt.root; <userinput>make installkernel KERNCONF=<replaceable>MYKERNEL</replaceable></userinput></screen>

      </note>

      <para>Wenn <varname>kern.securelevel</varname> einen Wert
	größer als <literal>1</literal> besitzt
	<emphasis>und</emphasis> der Kernel mit
	<literal>noschg</literal> oder ähnlichen Optionen geschützt
	ist, müssen Sie <buildtarget>installkernel</buildtarget> im
	Single-User-Modus ausführen.  Andernfalls laufen diese beiden
	Kommandos problemlos im Mehrbenutzermodus.  Weitere
	Informationen über <varname>kern.securelevel</varname> finden
	Sie in &man.init.8;.  Optionen, die auf Dateien gesetzt werden
	können, werden in &man.chflags.1; detailliert
	erläutert.</para>
    </sect2>

    <sect2 xml:id="new-kernel-singleuser">
      <title>Booten Sie in den Single-User-Modus</title>
      <indexterm><primary>Single-User-Modus</primary></indexterm>

      <para>Booten Sie in den Single-User-Modus, um zu prüfen ob der
	neue Kernel funktioniert.  Folgen Sie dazu den Anweisungen aus
	<xref linkend="makeworld-singleuser"/>.</para>
    </sect2>

    <sect2 xml:id="make-installworld">
      <title>Installation des Systems</title>

      <para>Nun kann das neue System mit
	<buildtarget>installworld</buildtarget> installiert
	werden:</para>

      <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make installworld</userinput></screen>

      <note>
	<para>Wenn mit <command>make buildworld</command> Variablen
	  verwendet werden, müssen dieselben Variablen auch bei
	  <command>make installworld</command> angegeben werden.  Auf
	  die anderen Optionen trifft das nur bedingt zu:
	  <option>-j</option> darf mit
	  <buildtarget>installworld</buildtarget> nicht benutzt
	  werden.</para>

	<para>Haben Sie zum Bauen die folgende Kommandozeile
	  verwendet:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE buildworld</userinput></screen>

	<para>dann installieren Sie das Ergebnis mit:</para>

	<screen>&prompt.root; <userinput>make -DNO_PROFILE installworld</userinput></screen>

	<para>Andernfalls würde das System bei der Installation
	  versuchen, die <quote>profiled</quote> Bibliotheken, die
	  aber gar nicht gebaut wurden, zu installieren.</para>
      </note>
    </sect2>

    <sect2 xml:id="post-installworld-updates">
      <title>Aktualisieren der von <command>make installworld</command>
        ausgelassenen Dateien</title>

      <para>Neue oder geänderte Konfigurationsdateien aus einigen
	Verzeichnissen, besonders <filename>/etc</filename>,
	<filename>/var</filename> und <filename>/usr</filename> werden
	bei der Installationsprozedur nicht berücksichtigt.</para>

      <para>Diese Dateien können einfach mit &man.mergemaster.8;
	aktualisiert werden.  Sichern Sie
	<filename>/etc</filename> für den Fall, dass während der
	Aktualisierung etwas schief geht.</para>

      <sect3 xml:id="mergemaster">
        <info><title><command>mergemaster</command></title>
	  <authorgroup>
	    <author><personname><firstname>Tom</firstname><surname>Rhodes</surname></personname><contrib>Beigetragen von </contrib></author>
	  </authorgroup>
        </info>
	
        <indexterm><primary><command>mergemaster</command></primary></indexterm>

	<para>&man.mergemaster.8; ist ein Bourne-Shell Skript, das
	  dabei behilflich ist die Unterschiede zwischen den
	  Konfigurationsdateien in <filename>/etc</filename> und denen
	  im Quellbaum unter <filename>/usr/src/etc</filename> zu
	  finden.  <command>mergemaster</command> ist der empfohlene
	  Weg, die Systemkonfiguration mit dem Quellbaum
	  abzugleichen.</para>

	<para>Um zu beginnen, rufen Sie <command>mergemaster</command>
	  auf.  Ausgehend von <filename>/</filename> wird
	  <command>mergemaster</command> einen virtuellen Root-Baum
	  aufbauen und darin die neuen Konfigurationsdateien ablegen.
	  Diese Dateien werden dann mit den auf dem System
	  installierten Dateien verglichen.  Unterschiede zwischen den
	  Dateien werden im &man.diff.1;-Format dargestellt.  Neue
	  oder geänderte Zeilen werden mit <option>+</option>
	  gekennzeichnet.  Zeilen die gelöscht oder ersetzt werden,
	  sind mit <option>-</option> gekennzeichnet.  Das
	  Anzeigeformat wird in &man.diff.1; genauer erklärt.</para>

	<para>&man.mergemaster.8; zeigt Ihnen jede geänderte Datei an
	  und Sie haben die Wahl, die neue Datei (in
	  <command>mergemaster</command> wird sie temporäre Datei
	  genannt) zu löschen, sie unverändert zu installieren,
	  den Inhalt der neuen Datei mit dem Inhalt der alten Datei
	  abzugleichen, oder die &man.diff.1; Ausgabe noch einmal zu
	  sehen.</para>

	<para>Wenn Sie die temporäre Datei löschen, geht
	  <command>mergemaster</command> davon aus, dass Sie die
	  aktuelle Datei unverändert behalten möchten.  Wählen Sie die
	  Option nur dann, wenn Sie keinen Grund sehen, die aktuelle
	  Datei zu ändern.</para>

	<para>Wenn Sie die temporäre Datei installieren, wird Ihre
	  aktuelle Datei mit der neuen Datei überschrieben.  Sie
	  sollten alle unveränderten Konfigurationsdateien auf diese
	  Weise aktualisieren.</para>

	<para>Wenn Sie sich entschließen den Inhalt beider Dateien
	  abzugleichen, wird ein Texteditor aufgerufen, in dem Sie
	  beide Dateien nebeneinander betrachten können.  Mit der
	  Taste <keycap>l</keycap> übernehmen Sie die aktuelle Zeile
	  der links dargestellten Datei, mit der Taste
	  <keycap>r</keycap> übernehmen Sie die Zeile der rechts
	  dargestellten Datei.  Das Ergebnis ist eine Datei, die aus
	  Teilen der beiden ursprünglichen Dateien besteht und
	  installiert werden kann.  Dieses Verfahren wird gewöhnlich
	  bei veränderten Dateien genutzt.</para>

	<para>Haben Sie sich entschieden die Differenzen noch einmal
	  anzuzeigen, zeigt &man.mergemaster.8; dieselbe Ausgabe, die
	  bereits vor der Eingabeaufforderung ausgegeben wurde.</para>

	<para>Wenn &man.mergemaster.8; alle Systemdateien abgearbeitet
	  hat, werden weitere Optionen abgefragt.  Sie werden unter
	  Umständen gefragt, ob die Passwort-Datei neu gebaut werden
	  soll.  Am Ende haben Sie die Möglichkeit, die restlichen
	  temporären Dateien zu löschen.</para>
      </sect3>

      <sect3>
	<title>Manueller Abgleich der Konfigurationsdateien</title>

	<para>Wenn Sie den Abgleich lieber selbst ausführen wollen,
	  beachten Sie bitte, dass Sie nicht einfach die Dateien aus
	  <filename>/usr/src/etc</filename> nach <filename>/etc</filename>
	  kopieren können.  Einige dieser Dateien müssen zuerst
	  <emphasis>installiert</emphasis> werden, bevor sie benutzt werden
	  können.  Das liegt daran, dass
	  <filename>/usr/src/etc</filename> keine exakte Kopie von
	  <filename>/etc</filename> ist.  Zudem gibt es Dateien, die sich
	  in <filename>/etc</filename> befinden aber nicht in
	  <filename>/usr/src/etc</filename>.</para>

	<para>Wenn Sie, wie empfohlen, <command>mergemaster</command>
	  benutzen, können Sie direkt in den nächsten
	  <link linkend="updating-upgrading-rebooting">Abschnitt</link>
	  wechseln.</para>

	<para>Am einfachsten ist es, wenn Sie die neuen Dateien in ein
	  temporäres Verzeichnis installieren und sie nacheinander auf
	  Differenzen zu den bestehenden Dateien durchsehen.</para>

	<warning>
	  <title>Sichern Sie die Inhalte von <filename>/etc</filename></title>

	  <para>Es wird empfohlen, zuerst das bestehende
	    <filename>/etc</filename> an einen sicheren Ort zu
	    kopieren:</para>

	    <screen>&prompt.root; <userinput>cp -Rp /etc /etc.old</userinput></screen>

	    <para>Mit <option>-R</option> wird rekursiv kopiert und
	      <option>-p</option> erhält die Attribute der kopierten
	      Dateien, wie Zugriffszeiten und Eigentümer.</para>
	</warning>

	<para>Als nächstes müssen Sie ein temporäres Verzeichnis für
	  die Installation der neuen Dateien in
	  <filename>/etc</filename> erstellen.
	  <filename>/var/tmp/root</filename> ist eine gute
	  Wahl:</para>

        <screen>&prompt.root; <userinput>mkdir /var/tmp/root</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root distrib-dirs distribution</userinput></screen>

	<para>Die obigen Kommandos bauen die nötige
	  Verzeichnisstruktur auf und installieren die neuen Dateien in
	  diese Struktur.  Unterhalb von <filename>/var/tmp/root</filename>
	  wurden einige leere Verzeichnisse angelegt, die Sie am besten wie
	  folgt entfernen:</para>

        <screen>&prompt.root; <userinput>cd /var/tmp/root</userinput>
&prompt.root; <userinput>find -d . -type d | xargs rmdir 2&gt;/dev/null</userinput></screen>

	<para>Dadurch werden alle leeren Verzeichnisse entfernt.  Um
	  die Warnungen über nicht leere Verzeichnisse zu
	  unterdrücken, wurde die Standardfehlerausgabe nach
	  <filename>/dev/null</filename> umgeleitet.</para>

	<para><filename>/var/tmp/root</filename> enthält nun alle
	  Dateien, die unterhalb von <filename>/</filename>
	  installiert werden sollten.  Sie müssen nun jede dieser
	  Dateien mit den schon existierenden Dateien des Systems
	  vergleichen.</para>

	<para>Einige der installierten Dateien unter
	  <filename>/var/tmp/root</filename> beginnen mit einem
	  <quote>.</quote>.  Verwenden Sie <command>ls -a</command> um
	  sicherzustellen, dass Sie alle derartigen Dateien
	  finden.</para>

	<para>Benutzen Sie &man.diff.1;, um zwei Dateien zu
	  vergleichen:</para>

        <screen>&prompt.root; <userinput>diff /etc/shells /var/tmp/root/etc/shells</userinput></screen>

	<para>Dieses Kommando zeigt die Unterschiede zwischen der
	  installierten Version von <filename>/etc/shells</filename>
	  und der neuen Version in
	  <filename>/var/tmp/root/etc/shells</filename>.  Entscheiden
	  Sie anhand der Unterschiede, ob Sie beide Dateien
	  abgleichen, oder die alte Version durch die neue Version
	  ersetzen wollen.</para>

	<tip>
	  <title>Versehen Sie das temporäre Verzeichnis
	    <filename>/var/tmp/root</filename> mit einem
	    Zeitstempel</title>

	  <para>Wenn das System oft neu gebaut wird, muss auch
	    <filename>/etc</filename> genauso oft aktualisiert werden.
	    Dies kann mit der Zeit ein bisschen mühsam werden.</para>

	  <para>Um diesen Prozess zu beschleunigen, behalten Sie
	    eine Kopie der Dateien, die zuletzt nach
	    <filename>/etc</filename> installiert wurden.</para>

	  <procedure>
	    <step>
	      <para>Folgen Sie der normalen Prozedur um das System zu
	        bauen.  Wenn Sie <filename>/etc</filename> und die anderen
		Verzeichnisse aktualisieren wollen, geben Sie dem
		temporären Verzeichnis einen Namen, der das aktuelle
		Datum enthält.</para>

	      <screen>&prompt.root; <userinput>mkdir /var/tmp/root-20130214</userinput>
&prompt.root; <userinput>cd /usr/src/etc</userinput>
&prompt.root; <userinput>make DESTDIR=/var/tmp/root-20130214 \
    distrib-dirs distribution</userinput></screen>
	    </step>

	    <step>
	      <para>Gleichen Sie die Änderungen entsprechend der
		Anleitung von oben ab.  Wenn Sie fertig sind,
		entfernen Sie das Verzeichnis
		<filename>/var/tmp/root-20130214</filename>
		<emphasis>nicht</emphasis>.</para>
	    </step>

	    <step>
	      <para>Nachdem die neuen Quellen heruntergeladen und
		gebaut haben, folgen Sie Schritt 1.  Erstellen Sie
		ein neues Verzeichnis mit einem aktuellen Datum.
		Dieses Beispiel verwendet
		<filename>/var/tmp/root-20130221</filename>.</para>
	    </step>

	    <step>
	      <para>Vergleichen Sie die Unterschiede, die sich in
		einer Woche ergeben haben, indem Sie &man.diff.1;
		rekursiv anwenden:</para>

	      <screen>&prompt.root; <userinput>cd /var/tmp</userinput>
&prompt.root; <userinput>diff -r root-20130214 root-20130221</userinput></screen>

	      <para>Üblicherweise sind diese Differenzen kleiner, als
		die Differenzen zwischen
		<filename>/var/tmp/root-20130221/etc</filename> und
		<filename>/etc</filename>.  Da die angezeigten Differenzen
		kleiner sind, ist es jetzt einfacher den Abgleich der
		Dateien in <filename>/etc</filename>
		durchzuführen.</para>
	    </step>

	    <step>
	      <para>Wenn Sie fertig sind, können Sie das ältere der
		beiden  <filename>/var/tmp/root-*</filename>
		Verzeichnisse entfernen:</para>

	      <screen>&prompt.root; <userinput>rm -rf /var/tmp/root-20130214</userinput></screen>
	    </step>

	    <step>
	      <para>Wiederholen Sie diesen Prozess jedes Mal wenn Sie
		Dateien in <filename>/etc</filename> abgleichen
		müssen.</para>
	    </step>
	  </procedure>

	  <para>Benutzen Sie &man.date.1;, um die Verzeichnisnamen
	    automatisch zu erzeugen:</para>

	  <screen>&prompt.root; <userinput>mkdir /var/tmp/root-`date "+%Y%m%d"`</userinput></screen>
	</tip>
      </sect3>
    </sect2>

    <sect2 xml:id="updating-upgrading-rebooting">
      <title>Das System neu starten</title>

      <para>Nachdem Sie sich davon überzeugt haben, dass alle Dateien
	an der richtigen Stelle sind, starten Sie das System mit
	&man.shutdown.8; neu:</para>

      <screen>&prompt.root; <userinput>shutdown -r now</userinput></screen>

      <para>Herzlichen Glückwunsch!  Sie haben gerade erfolgreich ein
        &os; System aktualisiert.</para>

      <para>Es ist leicht einen Teil des Systems wiederherzustellen,
	für den Fall, dass Ihnen ein kleiner Fehler unterlaufen ist.
	Wenn beispielsweise während des Updates oder Abgleichs
	<filename>/etc/magic</filename> aus Versehen gelöscht wurde,
	wird &man.file.1; nicht mehr funktionieren.  In diesem Fall
	kann das Problem mit dem folgenden Kommando behoben
	werden:</para>

	<screen>&prompt.root; <userinput>cd /usr/src/usr.bin/file</userinput>
&prompt.root; <userinput>make all install</userinput></screen>
    </sect2>

    <sect2 xml:id="updating-questions">
      <title>Fragen</title>

      <qandaset>
	<qandaentry>
	  <question>
	    <para>Muss ich wirklich immer alles neu bauen, wenn sich
	      etwas geändert hat?</para>
	  </question>

	  <answer>
	    <para>Darauf gibt es keine einfache Antwort.  Was zu tun ist,
	      hängt von den Änderungen ab.  Es lohnt
	      wahrscheinlich nicht, alles neu zu bauen, wenn sich bei einem
	      <application>svn</application>-Lauf nur die folgenden
	      Dateien geändert haben:</para>

	    <screen><filename>src/games/cribbage/instr.c</filename>
<filename>src/games/sail/pl_main.c</filename>
<filename>src/release/sysinstall/config.c</filename>
<filename>src/release/sysinstall/media.c</filename>
<filename>src/share/mk/bsd.port.mk</filename></screen>

	    <para>In diesem Fall können Sie in die entsprechenden
	      Unterverzeichnisse wechseln und dort <command>make all
	      install</command> ausführen.  Wenn sich allerdings etwas
	      Wichtiges, wie <filename>src/lib/libc/stdlib</filename>,
	      geändert hat, sollten Sie die Welt oder
	      mindestens die statisch gelinkten Teile des Systems
	      neu bauen.</para>

	    <para>Letztendlich ist das Ihre Entscheidung.  Sie sind
	      vielleicht damit zufrieden, das System alle zwei Wochen neu
	      zu bauen und in der Zwischenzeit die anfallenden
	      Änderungen zu sammeln.  Wenn Sie sich zutrauen, alle
	      Abhängigkeiten zu erkennen, bauen Sie vielleicht auch
	      nur die geänderten Sachen neu.</para>

	    <para>Das hängt auch noch davon ab, wie oft
	      Sie ein Update durchführen wollen und ob Sie &os.stable;
	      oder &os.current; benutzen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Der Bau bricht mit vielen
	      <errorname>Signal 11</errorname>-Fehlern (oder anderen
	      Signalnummern) ab.  Was ist da passiert?</para>
	  </question>

	  <answer>
	    <indexterm><primary>Signal 11</primary></indexterm>

	    <para>Normalerweise zeigen diese Meldungen Hardwarefehler
	      an.  Ein Neubau der Welt ist ein guter Belastungstest
	      für die Hardware und zeigt oft Probleme mit dem Speicher
	      auf.  Dies äußert sich darin, dass der Compiler mit
	      seltsamen Signalen abbricht.</para>

	    <para>Es liegt garantiert ein Hardwarefehler vor, wenn
	      <command>make</command> neu gestartet wird und an einer
	      anderen Stelle abbricht.</para>

	    <para>In diesem Fall können nur einzelne Komponenten des
	      Systems getauscht werden, um zu bestimmen, welche
	      Komponente den Fehler verursacht.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann <filename>/usr/obj</filename> entfernt werden,
	      wenn ich fertig bin?</para>
	  </question>

	  <answer>
	    <para>Kurze Antwort: Ja.</para>

	    <para>In <filename>/usr/obj</filename> werden alle Dateien
	      abgelegt, die während der Übersetzungsphase erstellt
	      wurden.  Dieses Verzeichnis wird in einem der ersten
	      Schritte von <command>make buildworld</command>
	      entfernt.  Es macht daher wenig Sinn, dieses Verzeichnis
	      zu behalten.  Zudem wird ungefähr 2&nbsp;GB
	      Plattenspeicher freigegeben, wenn dieses Verzeichnis
	      gelöscht wird.</para>

	    <para>Erfahrene Benutzer können
	      <command>make buildworld</command> anweisen, diesen
	      Schritt zu überspringen.  Nachfolgende Bauprozeduren
	      werden dadurch erheblich schneller, da die meisten
	      Quelldateien nicht mehr neu übersetzt werden müssen.
	      Dafür können aber subtile Abhängigkeitsprobleme
	      entstehen, die dazu führen, dass der Bau auf
	      merkwürdige Weise abbrechen kann.  Dies führt häufig zu
	      unnötigen Diskussionen auf den &os; Mailinglisten, wenn
	      sich jemand über einen kaputten Bau beschwert, aber
	      nicht sieht, dass er Probleme hat, weil er eine
	      Abkürzung genommen hat.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Kann ein abgebrochener Bau weitergeführt
	      werden?</para>
	  </question>

	  <answer>
	    <para>Das hängt davon ab, wieweit der Bauprozess
	      fortgeschritten ist.</para>

	    <para>Üblicherweise werden durch
	      <command>make buildworld</command> essentielle
	      Werkzeuge, wie &man.gcc.1; und &man.make.1;,
	      und die Systembibliotheken neu erstellt.  Die neu
	      erstellten Werkzeuge und Bibliotheken werden dann
	      benutzt, um sich selbst noch einmal zu bauen, und wieder
	      installiert.  Anschließend wird das Gesamtsystem,
	      einschließlich der normalen Benutzerprogramme wie
	      &man.ls.1; und &man.grep.1;, mit den neu erstellten
	      Systemdateien gebaut.</para>

	    <para>Während der letzten Phase können Sie relativ
	      gefahrlos folgende Kommandos ausführen:</para>

	    <screen><emphasis>&hellip; Fehler beheben &hellip;</emphasis>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make -DNO_CLEAN all</userinput></screen>

	    <para>Diese Variablen verhindern,
	      dass <command>make buildworld</command> die vorher erstellten
	      Dateien löscht.</para>

	    <para>Das Sie sich im letzten Schritt der Bauprozedur
	      befinden, erkennen Sie daran, dass Sie in der Ausgabe
	      von <command>make buildworld</command> die folgenden
	      Zeilen finden:</para>

	      <screen>--------------------------------------------------------------
Building everything..
--------------------------------------------------------------</screen>

	    <para>Wenn diese Meldung nicht angezeigt wird, oder Sie
	      sich nicht sicher sind, dann ist es besser, noch einmal
	      ganz von Vorne anzufangen.</para>
	  </answer>
	</qandaentry>

	<qandaentry>
	  <question>
	    <para>Wie kann ich den Bauprozess beschleunigen?</para>
          </question>

          <answer>
	    <itemizedlist>
	      <listitem>
		<para>Bauen Sie im Single-User-Modus.</para>
	      </listitem>

	      <listitem>
		<para>Legen Sie <filename>/usr/src</filename> und
		  <filename>/usr/obj</filename> in getrennte Dateisysteme auf
		  unterschiedliche Festplatten.  Benutzen Sie nach
		  Möglichkeit auch getrennte Platten-Controller.</para>
	      </listitem>

	      <listitem>
		<para>Alternativ können diese Dateisysteme mit
		  &man.ccd.4; auf mehrere Festplatten verteilt
		  werden.</para>
	      </listitem>

	      <listitem>
		<para>Deaktivieren Sie den Bau der
		  <quote>profiled</quote>-Bibliotheken, indem Sie
		  <literal>NO_PROFILE=true</literal> in
		  <filename>/etc/make.conf</filename>
		  aufnehmen.</para>
	      </listitem>

	      <listitem>
		<para>Benutzen Sie <command>make</command> zusammen
		  mit <option>-j<replaceable>n</replaceable></option>,
		  um mehrere Prozesse parallel laufen zu lassen.
		  Normalerweise beschleunigt dies den Bauprozess
		  auf Einprozessor- und Mehrprozessorsystemen.</para>
	      </listitem>

	      <listitem>
		<para>Das Dateisystem <filename>/usr/src</filename>
		  kann mit der Option <option>noatime</option>
		  eingehangen werden.  Dies verhindert, dass die
		  Zugriffszeiten der Dateien aktualisiert
		  werden.</para>

		<screen>&prompt.root; <userinput>mount -u -o noatime /usr/src</userinput></screen>

		<warning>
		  <para>Das Beispiel geht davon aus, dass sich
		    <filename>/usr/src</filename> auf einem separaten
		    Dateisystem befindet.  Wenn es Teil des
		    <filename>/usr</filename> Dateisystems ist,
		    muss dieses Dateisystem als Mountpoint angegeben
		    werden.</para>
		</warning>
	      </listitem>

	      <listitem>
		<para>Das Dateisystem, in dem sich
		  <filename>/usr/obj</filename> befindet, kann mit
		  <option>async</option> eingehangen werden, so dass
		  Schreibzugriffe auf die Platte asynchron
		  stattfinden.  Das heißt ein Schreibzugriff ist
		  sofort beendet, die Daten werden allerdings erst
		  einige Sekunden später geschrieben.  Dadurch können
		  Schreibzugriffe zusammengefasst werden, was einen
		  erheblichen Geschwindigkeitszuwachs mit sich bringen
		  kann.</para>

		<warning>
		  <para>Beachten Sie, dass dies das Dateisystem
		    anfälliger für Fehler macht.  Im Fall eines
		    Stromausfalls besteht eine erhöhte
		    Wahrscheinlichkeit, dass das Dateisystem beim
		    Start der Maschine zerstört ist.</para>

		  <para>Wenn <filename>/usr/obj</filename> das einzige
		    Verzeichnis auf auf diesem Dateisystem ist, stellt
		    das kein Problem dar.  Wenn sich allerdings auf
		    diesem Dateisystem noch andere wertvolle Daten
		    befinden, stellen Sie sicher, dass Sie über
		    aktuelle Sicherungen verfügen.</para>
		</warning>

		<screen>&prompt.root; <userinput>mount -u -o async /usr/obj</userinput></screen>

		<warning>
		  <para>Ersetzen Sie <filename>/usr/obj</filename> durch
		    den Mountpoint des entsprechenden Dateisystems, wenn es
		    sich nicht auf einem eigenen Dateisystem
		    befindet.</para>
		</warning>
	      </listitem>
	    </itemizedlist>
	  </answer>
	</qandaentry>

        <qandaentry>
          <question>
	    <para>Was mache ich, wenn etwas nicht funktioniert?</para>
          </question>

          <answer>
	    <para>Stellen Sie sicher, dass sich in Ihrer Umgebung
	      keine Reste eines vorherigen Baus befinden:</para>

            <screen>&prompt.root; <userinput>chflags -R noschg /usr/obj/usr</userinput>
&prompt.root; <userinput>rm -rf /usr/obj/usr</userinput>
&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make cleandir</userinput>
&prompt.root; <userinput>make cleandir</userinput></screen>

	    <para>Ja, <command>make cleandir</command> muss wirklich
	      zweimal aufgerufen werden.</para>

	    <para>Danach starten Sie den Bauprozess wieder mit
	      <command>make buildworld</command>.</para>

	    <para>Wenn Sie immer noch Probleme haben, schicken Sie die
	      Fehlermeldungen und die Ausgabe von <command>uname
	        -a</command> an die Mailingliste &a.de.questions;.  Bereiten
	      Sie sich darauf vor, weitere Fragen zu Ihrer Umgebung zu
	      beantworten.</para>
          </answer>
        </qandaentry>
      </qandaset>
    </sect2>
  </sect1>

  <sect1 xml:id="make-delete-old">
    <info><title>Veraltete Dateien, Verzeichnisse und Bibliotheken
      löschen</title>
      <authorgroup>
	<author><personname><firstname>Anton</firstname><surname>Shterenlikht</surname></personname><contrib>Basiert auf Notizen von </contrib></author>
      </authorgroup>
    </info>

    
    <indexterm>
      <primary>Veraltete Dateien, Verzeichnisse und Bibliotheken
	löschen</primary>
    </indexterm>

    <para>Aufgrund der ständigen Weiterentwicklung von &os; kann es
      dazu kommen, dass Dateien und deren Inhalte obsolet werden, weil
      deren Funktionalität entweder in anderen Dateien implementiert
      wurde, sich die Versionsnummer der Bibliothek geändert hat
      oder deren Funktion nicht mehr benötigt wird.  Dies kann
      sowohl Dateien und Verzeichnisse, aber auch Bibliotheken
      betreffen.  Diese veralteten Dateien sollten daher entfernt
      werden, wenn das System aktualisiert wird.  Der Vorteil besteht
      darin, dass das System von nicht mehr benötigten Dateien
      befreit wird.  Falls die obsolete Bibliothek Sicherheits- oder
      Stabilitätsprobleme aufweist, sollte das System ebenfalls
      aktualisiert werden, um das System sicher zu halten und/oder
      durch die fehlerhafte Bibliothek verursachte Systemabstürze zu
      vermeiden.  Veraltete Dateien, Verzeichnisse und Bibliotheken
      sind in der Datei
      <filename>/usr/src/ObsoleteFiles.inc</filename> aufgelistet.
      Verwenden Sie die folgenden Anweisungen, um diese Dateien
      während der Systemaktualisierung zu entfernen.</para>

    <para>Folgen Sie den Anweisungen von
      <xref linkend="canonical-build"/>.  Nachdem Sie
      <command>make installworld</command>
      sowie <command>mergemaster</command> erfolgreich ausgeführt
      haben, überprüfen Sie das System auf veraltete Dateien und
      Bibliotheken:</para>

    <screen>&prompt.root; <userinput>cd /usr/src</userinput>
&prompt.root; <userinput>make check-old</userinput></screen>

    <para>Werden dabei veraltete Dateien gefunden, können diese
      mit dem folgenden Kommando entfernt werden:</para>

    <screen>&prompt.root; <userinput>make delete-old</userinput></screen>

    <tip>
      <para>Weitere interessante
	<foreignphrase>targets</foreignphrase> finden Sie in
	<filename>/usr/src/Makefile</filename>.</para>
    </tip>

    <para>Bei jeder Datei wird nachgefragt, ob Sie diese wirklich
      löschen wollen.  Es ist aber auch möglich, alle
      Dateien automatisch löschen zu lassen.  Dies erreichen Sie,
      indem Sie die Umgebungsvariable
      <varname>BATCH_DELETE_OLD_FILES</varname> setzen:</para>

    <screen>&prompt.root; <userinput>make -DBATCH_DELETE_OLD_FILES delete-old</userinput></screen>

    <para>Alternativ können Sie auch <command>yes</command>
      einsetzen und somit die Antwort <literal>yes</literal>
      an die einzelnen Abfragen weiterreichen:</para>

    <screen>&prompt.root; <userinput>yes | make delete-old</userinput></screen>

    <warning>
      <title>Warnung</title>
	<para>Das Löschen veralteter Dateien kann dazu führen,
	  dass Programme, die auf diese Dateien angewiesen sind, nicht mehr
	  funktionieren.  Dies gilt insbesondere für veraltete
	  Bibliotheken.  In den meisten Fällen ist es dann notwendig,
	  Programme, Ports und Bibliotheken, welche die veraltete
	  Bibliothek verwenden, neu zu bauen, bevor Sie den Befehl
	  <command>make
	  delete-old-libs</command>
	  ausführen.</para>
    </warning>

    <para>Die Ports-Sammlung enthält Werkzeuge, die Ihnen beim
      Prüfen von Bibliothek-Abhängigkeiten helfen können:
      <package>sysutils/libchk</package>
      sowie <package>sysutils/bsdadminscripts</package>.</para>

    <para>Veraltete Bibliotheken können zu Konflikten mit neueren
      Bibliotheken führen und beispielsweise folgende
      Meldungen verursachen:</para>

    <screen>/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may conflict with libz.so.5
/usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/local/lib/libXext.so, may conflict with librpcsvc.so.5</screen>

    <para>Um diese Probleme zu lösen, müssen Sie zuerst
      herausfinden, welcher Port die Bibliothek installiert hat:</para>

    <screen>&prompt.root; <userinput>pkg_info -W  /usr/local/lib/libtiff.so</userinput>
/usr/local/lib/libtiff.so was installed by package tiff-3.9.4
&prompt.root; <userinput>pkg_info -W /usr/local/lib/libXext.so</userinput>
/usr/local/lib/libXext.so was installed by package libXext-1.1.1,1</screen>

    <para>Danach deinstallieren Sie den Port und bauen ihn neu, um ihn
      danach erneut zu installieren.  Dieser Vorgang kann durch den
      Einsatz von <package>ports-mgmt/portmaster</package> automatisiert
      werden.  Nachdem alle Ports neu gebaut wurden und keine alten
      alten Bibliotheken mehr verwenden werden, können Sie die alten
      Bibliotheken endgültig entfernen:</para>

    <screen>&prompt.root; <userinput>make delete-old-libs</userinput></screen>
  </sect1>

  <sect1 xml:id="small-lan">
    <info><title>Installation mehrerer Maschinen</title>
      <authorgroup>
	<author><personname><firstname>Mike</firstname><surname>Meyer</surname></personname><contrib>Beigetragen von </contrib></author>
      </authorgroup>
    </info>
    

    <para>Wenn Sie mehrere Maschinen alle auf dem gleichen Stand
      halten wollen, ist es eine Verschwendung von
      Ressourcen, die Quellen auf jeder Maschine vorzuhalten und zu
      übersetzen.  Die Lösung dazu ist, eine Maschine den
      Großteil der Arbeit durchführen zu lassen und den anderen
      Maschinen das Ergebnis mit NFS zur Verfügung zu stellen.  Dieser
      Abschnitt zeigt Ihnen wie das geht.</para>

    <sect2 xml:id="small-lan-preliminaries">
      <title>Voraussetzungen</title>

      <para>Stellen Sie zuerst eine Liste der Maschinen zusammen, die auf
        demselben Stand sein sollen.  Wir nennen diese Maschinen die
	<emphasis>Baugruppe</emphasis>.  Jede dieser Maschinen kann mit
	einem eigenen Kernel laufen, doch sind die Programme des Userlands
	auf allen Maschinen gleich.  Wählen Sie aus der Baugruppe eine
	Maschine aus, auf der der Bau durchgeführt wird, den
	<emphasis>Bau-Master</emphasis>.  Dies sollte eine Maschine sein,
	die über die nötigen Ressourcen für
	<command>make buildworld</command> und
	<command>make installworld</command> verfügt.
	Sie brauchen auch eine
	<emphasis>Testmaschine</emphasis>, auf der Sie die Updates testen,
	bevor Sie sie in Produktion installieren.  Dies sollte eine
	Maschine, eventuell der Bau-Master, sein, die über einen
	längeren Zeitraum nicht zur Verfügung stehen kann.</para>

      <para>Alle Maschinen der Baugruppe müssen
        <filename>/usr/obj</filename> und <filename>/usr/src</filename> von
	derselben Maschine an gleichem Ort einhängen.  Idealerweise
	befinden sich die beiden Verzeichnisse auf dem Bau-Master auf
	verschiedenen Festplatten, sie können allerdings auch auf dem
	Bau-Master über NFS zur Verfügung gestellt werden.  Wenn
	Sie mehrere Baugruppen haben, sollte sich
	<filename>/usr/src</filename> auf einem Bau-Master befinden und
	über NFS für den Rest der Maschinen zur Verfügung
	gestellt werden.</para>

      <para>Stellen Sie sicher, dass
        <filename>/etc/make.conf</filename> und
        <filename>/etc/src.conf</filename> auf allen Maschinen einer
	Baugruppe mit der Datei des Bau-Masters übereinstimmt.  Der
	Bau-Master muss jeden Teil des Systems bauen, den irgendeine
	Maschine der Baugruppe benötigt.  Auf dem Bau-Master
	müssen in <filename>/etc/make.conf</filename> alle zu bauenden
	Kernel mit der Variablen <varname>KERNCONF</varname> bekannt gegeben
	werden.  Geben Sie dabei den Kernel des Bau-Masters zuerst an.
	Für jeden zu bauenden Kernel muss auf dem Bau-Master die
	entsprechende Konfigurationsdatei unter
	<filename>/usr/src/sys/<replaceable>arch</replaceable>/conf</filename>
	abgelegt werden.</para>
    </sect2>

    <sect2 xml:id="small-lan-base-system">
      <title>Installation des Basissystems</title>

      <para>Bauen Sie auf dem Bau-Master, wie in <xref
	  linkend="make-buildworld"/> beschrieben, den Kernel und die
	Welt, installieren Sie aber nichts.  Wechseln Sie auf die
	Testmaschine und installieren Sie den gerade gebauten Kernel.
	Wenn diese Maschine <filename>/usr/src</filename> und
	<filename>/usr/obj</filename> über NFS bekommt, müssen Sie das
	Netzwerk im Single-User-Modus aktivieren und die beiden
	Dateisysteme einhängen.  Am einfachsten ist dies, wenn Sie
	auf der Testmaschine vom Mehrbenutzermodus mit
	<command>shutdown now</command> in den Single-User-Modus
	wechseln.  Sie können dann mit der normalen Prozedur den neuen
	Kernel und das System installieren und anschließend
	<command>mergemaster</command> laufen lassen.  Wenn Sie damit
	fertig sind, können Sie die Maschine wieder in den
	Mehrbenutzermodus booten.</para>

      <para>Nachdem Sie sichergestellt haben, dass die Testmaschine
        einwandfrei funktioniert, wiederholen Sie diese Prozedur für
	jede Maschine in der Baugruppe.</para>
    </sect2>

    <sect2 xml:id="small-lan-ports">
      <title>Die Ports-Sammlung</title>

      <para>Dasselbe Verfahren können Sie auch für die
        Ports-Sammlung anwenden.  Zuerst müssen alle Maschinen einer
	Baugruppe <filename>/usr/ports</filename> von derselben Maschine
	über NFS zur Verfügung gestellt bekommen.  Setzen Sie
	dann ein Verzeichnis für die Quellen auf, das sich alle
	Maschinen teilen.  Dieses Verzeichnis können Sie in
	<filename>/etc/make.conf</filename> mit der Variablen
	<varname>DISTDIR</varname> angeben.  Das Verzeichnis sollte
	für den Benutzer beschreibbar sein, auf den der Benutzer
	<systemitem class="username">root</systemitem> vom NFS Subsystem abgebildet wird.  Jede
	Maschine sollte noch <varname>WRKDIRPREFIX</varname> auf ein
	lokales Bauverzeichnis setzen.  Wenn Sie vorhaben, Pakete zu bauen
	und zu verteilen, sollten Sie <varname>PACKAGES</varname> auf ein
	Verzeichnis mit den gleichen Eigenschaften wie
	<varname>DISTDIR</varname> setzen.</para>
    </sect2>
  </sect1>
</chapter>
